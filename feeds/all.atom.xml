<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Techshack Weekly</title><link href="https://www.soasme.com/techshack.weekly/" rel="alternate"></link><link href="https://www.soasme.com/techshack.weekly/feeds/all.atom.xml" rel="self"></link><id>https://www.soasme.com/techshack.weekly/</id><updated>2018-12-17T00:00:00+00:00</updated><entry><title>Rumps - Mac os x Python Statusbar apps</title><link href="https://www.soasme.com/techshack.weekly/verses/2e20fc99-76ba-4286-b1a4-fa9984504934.html" rel="alternate"></link><published>2018-12-17T00:00:00+00:00</published><updated>2018-12-17T00:00:00+00:00</updated><author><name>Ju Lin</name></author><id>tag:www.soasme.com,2018-12-17:/techshack.weekly/verses/2e20fc99-76ba-4286-b1a4-fa9984504934.html</id><summary type="html">&lt;p&gt;&lt;a href="https://rumps.readthedocs.io/en/latest/examples.html"&gt;查看原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Rumps 是一个写 MacOS 的 Statusbar 的应用。使用 py2app 进行打包，打包出来的 .app 应用可以直接运行。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;rumps&lt;/span&gt;

&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;AwesomeStatusBarApp&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;rumps&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;App&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="fm"&gt;__init__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="nb"&gt;super&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;AwesomeStatusBarApp&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="fm"&gt;__init__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;Awesome App&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;menu&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;Preferences&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;Silly button&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;Say hi&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;

    &lt;span class="nd"&gt;@rumps.clicked&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;Preferences&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;prefs&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;_&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="n"&gt;rumps&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;alert&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;jk! no preferences available!&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

    &lt;span class="nd"&gt;@rumps.clicked …&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</summary><content type="html">&lt;p&gt;&lt;a href="https://rumps.readthedocs.io/en/latest/examples.html"&gt;查看原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Rumps 是一个写 MacOS 的 Statusbar 的应用。使用 py2app 进行打包，打包出来的 .app 应用可以直接运行。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;rumps&lt;/span&gt;

&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;AwesomeStatusBarApp&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;rumps&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;App&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="fm"&gt;__init__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="nb"&gt;super&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;AwesomeStatusBarApp&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="fm"&gt;__init__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;Awesome App&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;menu&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;Preferences&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;Silly button&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;Say hi&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;

    &lt;span class="nd"&gt;@rumps.clicked&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;Preferences&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;prefs&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;_&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="n"&gt;rumps&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;alert&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;jk! no preferences available!&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

    &lt;span class="nd"&gt;@rumps.clicked&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;Silly button&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;onoff&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;sender&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="n"&gt;sender&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;state&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="ow"&gt;not&lt;/span&gt; &lt;span class="n"&gt;sender&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;state&lt;/span&gt;

    &lt;span class="nd"&gt;@rumps.clicked&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;Say hi&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;sayhi&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;_&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="n"&gt;rumps&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;notification&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;Awesome title&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;amazing subtitle&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;hi!!1&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="vm"&gt;__name__&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;__main__&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;AwesomeStatusBarApp&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;run&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</content></entry><entry><title>CNAB Spec</title><link href="https://www.soasme.com/techshack.weekly/verses/4a413faa-86f4-4ae1-91c2-a4d4cde394a3.html" rel="alternate"></link><published>2018-12-17T00:00:00+00:00</published><updated>2018-12-17T00:00:00+00:00</updated><author><name>Ju Lin</name></author><id>tag:www.soasme.com,2018-12-17:/techshack.weekly/verses/4a413faa-86f4-4ae1-91c2-a4d4cde394a3.html</id><summary type="html">&lt;p&gt;&lt;a href="https://github.com/deislabs/cnab-spec"&gt;查看原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;CNAB （Cloud Native Application Bundles） 是关于打包，安装，管理分布式应用的规约。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;https://github.com/deislabs/cnab-spec/blob/master/100-CNAB.md&lt;ul&gt;
&lt;li&gt;它可以打包多种运行时的安装工具，例如 Helm，Terraform。&lt;/li&gt;
&lt;li&gt;他可以支持打包到多种后端，各个云平台，甚至离线的环境。例如，openstack, azure, kubernetes, nomad, local docker, aci, 甚至 IoT。&lt;/li&gt;
&lt;li&gt;bundle.json 中定义了元信息，invocation image（简单来说，有点像桌面系统的安装器），可让用户自定义的参数，executable images，以及镜像们所需要的环境变量和密钥。&lt;/li&gt;
&lt;li&gt;bundle.json 是未签名的，bundle …&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;</summary><content type="html">&lt;p&gt;&lt;a href="https://github.com/deislabs/cnab-spec"&gt;查看原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;CNAB （Cloud Native Application Bundles） 是关于打包，安装，管理分布式应用的规约。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;https://github.com/deislabs/cnab-spec/blob/master/100-CNAB.md&lt;ul&gt;
&lt;li&gt;它可以打包多种运行时的安装工具，例如 Helm，Terraform。&lt;/li&gt;
&lt;li&gt;他可以支持打包到多种后端，各个云平台，甚至离线的环境。例如，openstack, azure, kubernetes, nomad, local docker, aci, 甚至 IoT。&lt;/li&gt;
&lt;li&gt;bundle.json 中定义了元信息，invocation image（简单来说，有点像桌面系统的安装器），可让用户自定义的参数，executable images，以及镜像们所需要的环境变量和密钥。&lt;/li&gt;
&lt;li&gt;bundle.json 是未签名的，bundle.cnab 是签名的。&lt;/li&gt;
&lt;li&gt;thin bundle：只包含了 definition 的包。&lt;/li&gt;
&lt;li&gt;thick bundle：包含了 definition 以及所有经过编码的 invocation image，execution images。&lt;/li&gt;
&lt;li&gt;一个 bundle 包含了元信息和至少一个 invocation image。invocation image 安装依赖到 host environment。&lt;/li&gt;
&lt;li&gt;run tool：bundle 的入口程序。&lt;/li&gt;
&lt;li&gt;claim: 安装历史，用于追踪 bundle 的安装。&lt;/li&gt;
&lt;li&gt;bundle repositories: 存放 bundle 的仓库。&lt;/li&gt;
&lt;li&gt;image: 可以是 container 镜像，也可以是 VM 镜像。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;衍生思考：CNAB 尝试要解决的问题是个很大的命题，如何安装云端的应用程序。我们有太多的工具和工具链，出现一个标准是个好事。&lt;/p&gt;</content></entry><entry><title>Docker App and CNAB</title><link href="https://www.soasme.com/techshack.weekly/verses/7c7e4ef2-53ca-4472-b23a-f3ed6e929efc.html" rel="alternate"></link><published>2018-12-17T00:00:00+00:00</published><updated>2018-12-17T00:00:00+00:00</updated><author><name>Ju Lin</name></author><id>tag:www.soasme.com,2018-12-17:/techshack.weekly/verses/7c7e4ef2-53ca-4472-b23a-f3ed6e929efc.html</id><summary type="html">&lt;p&gt;&lt;a href="https://blog.docker.com/2018/12/docker-app-and-cnab/"&gt;查看原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Docker App 可用于部署应用到 docker 中。它基于 CNAB Spec。应用开发者可以将应用打包成 CNAB bundles，其中包含了一些metadata，需要的 image，运行的 service 等等。应用使用者使用 &lt;code&gt;docker-app install&lt;/code&gt; 安装应用。&lt;/p&gt;</summary><content type="html">&lt;p&gt;&lt;a href="https://blog.docker.com/2018/12/docker-app-and-cnab/"&gt;查看原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Docker App 可用于部署应用到 docker 中。它基于 CNAB Spec。应用开发者可以将应用打包成 CNAB bundles，其中包含了一些metadata，需要的 image，运行的 service 等等。应用使用者使用 &lt;code&gt;docker-app install&lt;/code&gt; 安装应用。&lt;/p&gt;</content></entry><entry><title>Loki - like Prometheus, but for logs</title><link href="https://www.soasme.com/techshack.weekly/verses/e7dc89fd-5012-44c6-b6c8-9a91b6455589.html" rel="alternate"></link><published>2018-12-17T00:00:00+00:00</published><updated>2018-12-17T00:00:00+00:00</updated><author><name>Ju Lin</name></author><id>tag:www.soasme.com,2018-12-17:/techshack.weekly/verses/e7dc89fd-5012-44c6-b6c8-9a91b6455589.html</id><summary type="html">&lt;p&gt;&lt;a href="https://docs.google.com/document/d/11tjK_lvp1-SVsFZjgOTr1vV3-q6vBAsZYIQ5ZeYBkyM/view"&gt;查看原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文是Grafana Loki service的设计文档。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;解决的问题：Metrics 和 Alerts 只能揭示预定义的问题，未知的问题还得从 Log 里面去细细查找。常见的 Incident Response 流程是：alert -&amp;gt; metric dashboard -&amp;gt; adhoc query -&amp;gt; log -&amp;gt; distribution tracing -&amp;gt; fix。 日志和 Metric 分在两个系统，这增加了 Operations 的 Context Switch。&lt;/li&gt;
&lt;li&gt;现存方案：full-text search systems to index logs。缺点：不好 scale，运维复杂。&lt;/li&gt;
&lt;li&gt;解决方案：预装 agent 到各个节点，收集日志，将 …&lt;/li&gt;&lt;/ul&gt;</summary><content type="html">&lt;p&gt;&lt;a href="https://docs.google.com/document/d/11tjK_lvp1-SVsFZjgOTr1vV3-q6vBAsZYIQ5ZeYBkyM/view"&gt;查看原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文是Grafana Loki service的设计文档。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;解决的问题：Metrics 和 Alerts 只能揭示预定义的问题，未知的问题还得从 Log 里面去细细查找。常见的 Incident Response 流程是：alert -&amp;gt; metric dashboard -&amp;gt; adhoc query -&amp;gt; log -&amp;gt; distribution tracing -&amp;gt; fix。 日志和 Metric 分在两个系统，这增加了 Operations 的 Context Switch。&lt;/li&gt;
&lt;li&gt;现存方案：full-text search systems to index logs。缺点：不好 scale，运维复杂。&lt;/li&gt;
&lt;li&gt;解决方案：预装 agent 到各个节点，收集日志，将 log stream 的 metadata 作为索引，而非 log stream 本身。metadata 可以用 Prometheus-style multi-dimensional labels 定义。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;见代码：&lt;a href="https://github.com/grafana/loki"&gt;https://github.com/grafana/loki&lt;/a&gt;&lt;/p&gt;</content></entry><entry><title>使用 Deep Learning 做时间序列分析</title><link href="https://www.soasme.com/techshack.weekly/verses/650a9371-3054-483f-9066-87c3d4fb3083.html" rel="alternate"></link><published>2018-12-14T00:00:00+00:00</published><updated>2018-12-14T00:00:00+00:00</updated><author><name>Ju Lin</name></author><id>tag:www.soasme.com,2018-12-14:/techshack.weekly/verses/650a9371-3054-483f-9066-87c3d4fb3083.html</id><summary type="html">&lt;p&gt;&lt;a href="https://medium.com/@alexrachnog/deep-learning-the-final-frontier-for-signal-processing-and-time-series-analysis-734307167ad6"&gt;查看原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文介绍了哪些数据是时间序列数据，以及如何使用深度学习做时间序列分析。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;时间序列数据可以是来自外太空的能量信号，也可以是股票，销售数据等等。人体本身也是产生时间序列数据的很好的数据源：心跳，体温等等。&lt;/li&gt;
&lt;li&gt;Classic Approach：测量时间序列如何基于时间发生值的大小变化，频率变化，邻近时间点数据变化，(S)AR(I)MA(X) models（基于linear self-dependence计算相关度），非线性变化等等。&lt;/li&gt;
&lt;li&gt;Deep Learning：从操作上来说，堆叠几个喜欢的 Framework 层层计算，小心 overfitting。（近年来的使用发现这种方法适用非常多的场景，包括时间序列分析）&lt;ul&gt;
&lt;li&gt;Recurrent neural nets: 这个方法这一找出时间序列中的隐藏状态，并给予时间找到它们的依赖。缺点是只适合短时间序列（10-100 time steps）&lt;/li&gt;
&lt;li&gt;Convolutional neural nets: 一般它用于寻找 3D 或图像数据的 pattern，但它也可以用于处理 …&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;</summary><content type="html">&lt;p&gt;&lt;a href="https://medium.com/@alexrachnog/deep-learning-the-final-frontier-for-signal-processing-and-time-series-analysis-734307167ad6"&gt;查看原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文介绍了哪些数据是时间序列数据，以及如何使用深度学习做时间序列分析。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;时间序列数据可以是来自外太空的能量信号，也可以是股票，销售数据等等。人体本身也是产生时间序列数据的很好的数据源：心跳，体温等等。&lt;/li&gt;
&lt;li&gt;Classic Approach：测量时间序列如何基于时间发生值的大小变化，频率变化，邻近时间点数据变化，(S)AR(I)MA(X) models（基于linear self-dependence计算相关度），非线性变化等等。&lt;/li&gt;
&lt;li&gt;Deep Learning：从操作上来说，堆叠几个喜欢的 Framework 层层计算，小心 overfitting。（近年来的使用发现这种方法适用非常多的场景，包括时间序列分析）&lt;ul&gt;
&lt;li&gt;Recurrent neural nets: 这个方法这一找出时间序列中的隐藏状态，并给予时间找到它们的依赖。缺点是只适合短时间序列（10-100 time steps）&lt;/li&gt;
&lt;li&gt;Convolutional neural nets: 一般它用于寻找 3D 或图像数据的 pattern，但它也可以用于处理 1D 数据（时间序列），只需要把 ResNet，DenseNet 的 2D convolutions 替换出 1D 即可。这个方法性能不错，算得快，能并行优化，能归类能回归。作者认为它当下的基线模型就是 Logistic regression and 2-3 layers CNN&lt;/li&gt;
&lt;li&gt;CNN+RNN: &lt;/li&gt;
&lt;li&gt;Autoregressive neural nets: 简化 RNN，使用最近 N steps dilated convolutions。
  &lt;img alt="" src="https://cdn-images-1.medium.com/max/1600/0*ud5IIi3iI8YEGeuw.gif"&gt;&lt;/li&gt;
&lt;li&gt;Clustering: 聚类算法诸如 k-means 性能不太好。&lt;/li&gt;
&lt;li&gt;Anomaly detection: 从数据中找到预期不应该看到的pattern。可以用  GANs，也可以用 autoencoders 把数据埋进一个新的 space。&lt;/li&gt;
&lt;li&gt;Hybrid: 混合 https://eng.uber.com/neural-networks/&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;结论：对于sequantial modeling，Autoregressive CNN &amp;gt; CNN &amp;gt; RNN, 结合  DL 和数学模型。&lt;/p&gt;</content></entry><entry><title>Stack Overflow 如何监控之 2018 版</title><link href="https://www.soasme.com/techshack.weekly/verses/69894c16-36f0-455e-9d0b-4f9d8b5033c0.html" rel="alternate"></link><published>2018-12-14T00:00:00+00:00</published><updated>2018-12-14T00:00:00+00:00</updated><author><name>Ju Lin</name></author><id>tag:www.soasme.com,2018-12-14:/techshack.weekly/verses/69894c16-36f0-455e-9d0b-4f9d8b5033c0.html</id><summary type="html">&lt;p&gt;&lt;a href="https://nickcraver.com/blog/2018/11/29/stack-overflow-how-we-do-monitoring/"&gt;查看原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文介绍了 Stack Overflow 当下（2018）的监控技术栈。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;监控是什么？是裸眼时不时扫头上那三五台大电视屏幕，是被开发搞的飞起的上线事故应急响应，如此种种。得操心监控阈值设定，高了不行，低了不行，节假日要换个阈值，有时候又没法自动化。&lt;/li&gt;
&lt;li&gt;监控什么？三大类：日志，健康检查，监控指标。&lt;ul&gt;
&lt;li&gt;日志: 主程序错误丢到 Windows 套餐的 Opserver，其他服务像 Redis，Elasticsearch，SQLServer 做本地 disk logging + log rotation。HAProxy 会把负载均衡的服务的总体流量和响应时间记下来，排查问题时很有用。默认的 HAProxy 日志中会有以下四个数据：&lt;/li&gt;
&lt;li&gt;TR: Time a client took to send us the …&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;</summary><content type="html">&lt;p&gt;&lt;a href="https://nickcraver.com/blog/2018/11/29/stack-overflow-how-we-do-monitoring/"&gt;查看原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文介绍了 Stack Overflow 当下（2018）的监控技术栈。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;监控是什么？是裸眼时不时扫头上那三五台大电视屏幕，是被开发搞的飞起的上线事故应急响应，如此种种。得操心监控阈值设定，高了不行，低了不行，节假日要换个阈值，有时候又没法自动化。&lt;/li&gt;
&lt;li&gt;监控什么？三大类：日志，健康检查，监控指标。&lt;ul&gt;
&lt;li&gt;日志: 主程序错误丢到 Windows 套餐的 Opserver，其他服务像 Redis，Elasticsearch，SQLServer 做本地 disk logging + log rotation。HAProxy 会把负载均衡的服务的总体流量和响应时间记下来，排查问题时很有用。默认的 HAProxy 日志中会有以下四个数据：&lt;/li&gt;
&lt;li&gt;TR: Time a client took to send us the request (fairly useless when keepalive is in play)&lt;/li&gt;
&lt;li&gt;Tw: Time spent waiting in queues&lt;/li&gt;
&lt;li&gt;Tc: Time spent waiting to connect to the web server&lt;/li&gt;
&lt;li&gt;Tr: Time the web server took to fully render a response&lt;/li&gt;
&lt;li&gt;健康检查。绿色（ok），红色（not-ok），红色（不正常了），灰色（不晓得啥事情）。负载均衡会根据这个分派流量到健康的节点去。健康检查有可能会做的很频繁，几秒或者一分钟一次不等。每个数据中心有两个 ISP 用来做冗余，一个主，一个备。他们使用 Pingdom 做全球 ping 监控。&lt;/li&gt;
&lt;li&gt;监控指标：time series data。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Alert：一个内部的告警平台Bosun，外加 PagerDuty 找 OnCall&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/bosun-monitor/"&gt;Bosun&lt;/a&gt;: 用 Go 写的 agent 程序，使用 OpenTSDB 做后端时间序列存储。他们会把一个 alert 近期的监控 pattern 记录下来，这样子会很容易发现这个 pattern。&lt;/li&gt;
&lt;li&gt;Grafana：监控面板。&lt;/li&gt;
&lt;li&gt;网站加载：https://teststackoverflow.com/&lt;/li&gt;
&lt;li&gt;MiniProfiler：对每个请求做低精度的 profile，看哪个函数调用耗时&lt;/li&gt;
&lt;li&gt;接下来的优化&lt;ul&gt;
&lt;li&gt;做一个服务的健康依赖链条。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;衍生思考：这位作者正在做的事情其实就是我在公司做的事情。对于存在依赖链条的多服务的监控，一个树形的服务健康面版对于 Ops 的重要性不言而喻。他的 HealthResult/HealthStatus 定义的没问题，HealthResult 里面可以再带上些 Playbook，Pagerduty 什么的还可以加速异常的处理。&lt;/p&gt;</content></entry><entry><title>Sops - an editor of encrypted files</title><link href="https://www.soasme.com/techshack.weekly/verses/4451d8b1-2ce7-4b85-941c-e97fa0258788.html" rel="alternate"></link><published>2018-12-13T00:00:00+00:00</published><updated>2018-12-13T00:00:00+00:00</updated><author><name>Ju Lin</name></author><id>tag:www.soasme.com,2018-12-13:/techshack.weekly/verses/4451d8b1-2ce7-4b85-941c-e97fa0258788.html</id><summary type="html">&lt;p&gt;&lt;a href="https://github.com/mozilla/sops"&gt;查看原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Sops 可以对 YAML，JSON，BINARY 加密，使用 AWS KMS, GCP KMS, Azure Key VAult 以及 PGP。&lt;/p&gt;
&lt;p&gt;需要提前配置云平台的验证信息。&lt;/p&gt;
&lt;p&gt;可以在保留文件数据结构的情况下，对部分字段加密解密。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="err"&gt;# file.yaml is in cleartext&lt;/span&gt;
&lt;span class="err"&gt;$ sops -e -i /path/to/existing/file.yaml&lt;/span&gt;
&lt;span class="err"&gt;# file.yaml is now encrypted&lt;/span&gt;
&lt;span class="err"&gt;$ sops -d -i /path/to/existing/file.yaml&lt;/span&gt;
&lt;span class="err"&gt;# file.yaml is back …&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</summary><content type="html">&lt;p&gt;&lt;a href="https://github.com/mozilla/sops"&gt;查看原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Sops 可以对 YAML，JSON，BINARY 加密，使用 AWS KMS, GCP KMS, Azure Key VAult 以及 PGP。&lt;/p&gt;
&lt;p&gt;需要提前配置云平台的验证信息。&lt;/p&gt;
&lt;p&gt;可以在保留文件数据结构的情况下，对部分字段加密解密。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="err"&gt;# file.yaml is in cleartext&lt;/span&gt;
&lt;span class="err"&gt;$ sops -e -i /path/to/existing/file.yaml&lt;/span&gt;
&lt;span class="err"&gt;# file.yaml is now encrypted&lt;/span&gt;
&lt;span class="err"&gt;$ sops -d -i /path/to/existing/file.yaml&lt;/span&gt;
&lt;span class="err"&gt;# file.yaml is back in cleartext&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</content></entry><entry><title>Kubernetes Logging Architecture</title><link href="https://www.soasme.com/techshack.weekly/verses/dc8d97cc-4e31-4eae-9dba-7d1382bc65d5.html" rel="alternate"></link><published>2018-12-13T00:00:00+00:00</published><updated>2018-12-13T00:00:00+00:00</updated><author><name>Ju Lin</name></author><id>tag:www.soasme.com,2018-12-13:/techshack.weekly/verses/dc8d97cc-4e31-4eae-9dba-7d1382bc65d5.html</id><summary type="html">&lt;p&gt;&lt;a href="https://kubernetes.io/docs/concepts/cluster-administration/logging/"&gt;查看原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Kubernetes 没有内建的日志收集组件，需要自行安装。对于服务器端程序，日志收集的重要性不言而喻。
在 k8s 的环境中，有一个特殊的需求：container/pod/node 挂了，我们还需要看到它们的日志。
这就要求我们需要在 cluster 内部实现 cluster-level-logging，外部配置一个 logging 后端。&lt;/p&gt;
&lt;p&gt;日志分两种，容器日志和非容器日志（例如 kubelet），
所有系统日志都会通过 stdout，stderr 输出到 &lt;code&gt;/var/log&lt;/code&gt; (glog 库)。
所有容器日志都会输出到 logdriver. Kubernetes 本身不负责 logrotate，Logdriver 例如 Docker 会有 log-opt 这样的工具来做。&lt;/p&gt;
&lt;p&gt;一些 Cluster-level logging architectures 的解决方案 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;&lt;a href="https://kubernetes.io/docs/concepts/cluster-administration/logging/"&gt;查看原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Kubernetes 没有内建的日志收集组件，需要自行安装。对于服务器端程序，日志收集的重要性不言而喻。
在 k8s 的环境中，有一个特殊的需求：container/pod/node 挂了，我们还需要看到它们的日志。
这就要求我们需要在 cluster 内部实现 cluster-level-logging，外部配置一个 logging 后端。&lt;/p&gt;
&lt;p&gt;日志分两种，容器日志和非容器日志（例如 kubelet），
所有系统日志都会通过 stdout，stderr 输出到 &lt;code&gt;/var/log&lt;/code&gt; (glog 库)。
所有容器日志都会输出到 logdriver. Kubernetes 本身不负责 logrotate，Logdriver 例如 Docker 会有 log-opt 这样的工具来做。&lt;/p&gt;
&lt;p&gt;一些 Cluster-level logging architectures 的解决方案：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用 DaemonSet 安装 logging agent 到每台节点&lt;/li&gt;
&lt;li&gt;Application pod 安装 sidecar container 专门用于日志处理&lt;/li&gt;
&lt;li&gt;Application 内部直接用 Push 日志到后端。&lt;/li&gt;
&lt;/ul&gt;</content></entry><entry><title>Kind - Kubernetes IN Docker - local clusters for testing Kubernetes</title><link href="https://www.soasme.com/techshack.weekly/verses/1c98db78-e60a-42e4-a3d8-dffc518e5e4f.html" rel="alternate"></link><published>2018-12-12T00:00:00+00:00</published><updated>2018-12-12T00:00:00+00:00</updated><author><name>Ju Lin</name></author><id>tag:www.soasme.com,2018-12-12:/techshack.weekly/verses/1c98db78-e60a-42e4-a3d8-dffc518e5e4f.html</id><summary type="html">&lt;p&gt;&lt;a href="https://github.com/kubernetes-sigs/kind/blob/master/docs/design/design.md"&gt;查看原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Kind 是一个运行在本地的 k8s 测试工具，每个 docker container 都可视作单独的node。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;宿主机运行 kind cli 管理 docker.&lt;/li&gt;
&lt;li&gt;"node" container: 安装了 systemd, kubelet, kube-proxy 等等组件。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt="" src="https://github.com/kubernetes-sigs/kind/blob/master/docs/images/diagram.png"&gt;&lt;/p&gt;</summary><content type="html">&lt;p&gt;&lt;a href="https://github.com/kubernetes-sigs/kind/blob/master/docs/design/design.md"&gt;查看原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Kind 是一个运行在本地的 k8s 测试工具，每个 docker container 都可视作单独的node。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;宿主机运行 kind cli 管理 docker.&lt;/li&gt;
&lt;li&gt;"node" container: 安装了 systemd, kubelet, kube-proxy 等等组件。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt="" src="https://github.com/kubernetes-sigs/kind/blob/master/docs/images/diagram.png"&gt;&lt;/p&gt;</content></entry><entry><title>Hawk - HTTP Holder-Of-Key Authentication Scheme</title><link href="https://www.soasme.com/techshack.weekly/verses/235a91f7-e807-4972-b923-b644aeb261e4.html" rel="alternate"></link><published>2018-12-12T00:00:00+00:00</published><updated>2018-12-12T00:00:00+00:00</updated><author><name>Ju Lin</name></author><id>tag:www.soasme.com,2018-12-12:/techshack.weekly/verses/235a91f7-e807-4972-b923-b644aeb261e4.html</id><summary type="html">&lt;p&gt;&lt;a href="https://github.com/hueniverse/hawk"&gt;查看原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Hawk 是一个使用 MAC 对 HTTP 请求头，请求参数进行加密校验的算法。
Hawk 的主要用例是进行服务端和客户端的 two-legged 授权验证。&lt;/p&gt;
&lt;p&gt;范例：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="nf"&gt;GET&lt;/span&gt; &lt;span class="nn"&gt;/resource/1?b=1&amp;amp;a=2&lt;/span&gt; &lt;span class="kr"&gt;HTTP&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="m"&gt;1.1&lt;/span&gt;
&lt;span class="na"&gt;Host&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="l"&gt;example.com:8000&lt;/span&gt;
&lt;span class="na"&gt;Authorization&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="l"&gt;Hawk id=&amp;quot;dh37fgj492je&amp;quot;, ts=&amp;quot;1353832234&amp;quot;, nonce=&amp;quot;j4h3g2&amp;quot;, ext=&amp;quot;some-app-ext-data&amp;quot;, mac=&amp;quot;6R4rV5iE+NPoym+WwjeHzjAGXUtLNIxmo1vpMofpLAE=&amp;quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;它需要客户端和服务端都有一个 加密用的 key。协议本身不提供获取和传送密钥的手段，一般需要使用者使用 TLS 先行建立一个传输层的安全连接。协议只是验证请求头和部分请求参数没被篡改，所以不可以就把敏感数据放进去 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;&lt;a href="https://github.com/hueniverse/hawk"&gt;查看原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Hawk 是一个使用 MAC 对 HTTP 请求头，请求参数进行加密校验的算法。
Hawk 的主要用例是进行服务端和客户端的 two-legged 授权验证。&lt;/p&gt;
&lt;p&gt;范例：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="nf"&gt;GET&lt;/span&gt; &lt;span class="nn"&gt;/resource/1?b=1&amp;amp;a=2&lt;/span&gt; &lt;span class="kr"&gt;HTTP&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="m"&gt;1.1&lt;/span&gt;
&lt;span class="na"&gt;Host&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="l"&gt;example.com:8000&lt;/span&gt;
&lt;span class="na"&gt;Authorization&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="l"&gt;Hawk id=&amp;quot;dh37fgj492je&amp;quot;, ts=&amp;quot;1353832234&amp;quot;, nonce=&amp;quot;j4h3g2&amp;quot;, ext=&amp;quot;some-app-ext-data&amp;quot;, mac=&amp;quot;6R4rV5iE+NPoym+WwjeHzjAGXUtLNIxmo1vpMofpLAE=&amp;quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;它需要客户端和服务端都有一个 加密用的 key。协议本身不提供获取和传送密钥的手段，一般需要使用者使用 TLS 先行建立一个传输层的安全连接。协议只是验证请求头和部分请求参数没被篡改，所以不可以就把敏感数据放进去。
&lt;code&gt;nonce&lt;/code&gt; 最好使用 cryptographically secure PRNGs 生成。&lt;/p&gt;
&lt;p&gt;它的对比方案是HTTP Digest。Hawk 的好处是不需要额外与服务器做一次通信就能得到 nonce。&lt;/p&gt;</content></entry><entry><title>Secure HTTP Headers and Cookies</title><link href="https://www.soasme.com/techshack.weekly/verses/aaa8775f-8430-48aa-aa01-854dc7f33196.html" rel="alternate"></link><published>2018-12-12T00:00:00+00:00</published><updated>2018-12-12T00:00:00+00:00</updated><author><name>Ju Lin</name></author><id>tag:www.soasme.com,2018-12-12:/techshack.weekly/verses/aaa8775f-8430-48aa-aa01-854dc7f33196.html</id><summary type="html">&lt;p&gt;&lt;a href="https://github.com/cakinney/secure"&gt;查看原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/cakinney/secure"&gt;https://github.com/cakinney/secure&lt;/a&gt; 这个库列出了一些应当被妥当设置的安全相关的请求头：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Server: 默认设为 NULL，避免暴露服务器的信息&lt;/li&gt;
&lt;li&gt;Strict-Transport-Security (HSTS): 服务不允许被降级为 HTTP 运行。&lt;code&gt;max-age=63072000; includeSubdomains&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;X-Frame-Options (XFO)：防止 clickjacking。&lt;code&gt;SAMEORIGIN&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;X-XSS-Protection: &lt;code&gt;1; mode=block&lt;/code&gt;: 防止扩展脚本运行&lt;/li&gt;
&lt;li&gt;X-Content-Type-Options：&lt;code&gt;nosniff&lt;/code&gt;：不允许 MIME-sniffing&lt;/li&gt;
&lt;li&gt;Content-Security-Policy (CSP): &lt;code&gt;script-src 'self'; object-src 'self'&lt;/code&gt; 防止跨域注入&lt;/li&gt;
&lt;li&gt;Referrer-Policy： &lt;code&gt;no-referrer, strict-origin-when-cross-origin&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Cache-control / Pragma: &lt;code&gt;no-cache, no-store, must-revalidate / no-cache&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Feature-Policy …&lt;/li&gt;&lt;/ul&gt;</summary><content type="html">&lt;p&gt;&lt;a href="https://github.com/cakinney/secure"&gt;查看原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/cakinney/secure"&gt;https://github.com/cakinney/secure&lt;/a&gt; 这个库列出了一些应当被妥当设置的安全相关的请求头：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Server: 默认设为 NULL，避免暴露服务器的信息&lt;/li&gt;
&lt;li&gt;Strict-Transport-Security (HSTS): 服务不允许被降级为 HTTP 运行。&lt;code&gt;max-age=63072000; includeSubdomains&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;X-Frame-Options (XFO)：防止 clickjacking。&lt;code&gt;SAMEORIGIN&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;X-XSS-Protection: &lt;code&gt;1; mode=block&lt;/code&gt;: 防止扩展脚本运行&lt;/li&gt;
&lt;li&gt;X-Content-Type-Options：&lt;code&gt;nosniff&lt;/code&gt;：不允许 MIME-sniffing&lt;/li&gt;
&lt;li&gt;Content-Security-Policy (CSP): &lt;code&gt;script-src 'self'; object-src 'self'&lt;/code&gt; 防止跨域注入&lt;/li&gt;
&lt;li&gt;Referrer-Policy： &lt;code&gt;no-referrer, strict-origin-when-cross-origin&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Cache-control / Pragma: &lt;code&gt;no-cache, no-store, must-revalidate / no-cache&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Feature-Policy: 关掉这些特性：&lt;code&gt;accelerometer 'none'; ambient-light-sensor 'none'; autoplay 'none'; camera 'none'; encrypted-media 'none'; fullscreen 'none'; geolocation 'none'; gyroscope 'none'; magnetometer 'none'; microphone 'none'; midi 'none'; payment 'none'; picture-in-picture 'none'; speaker 'none'; sync-xhr 'none'; usb 'none'; vr 'none';"&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;</content></entry><entry><title>Vega - A Visualization Grammar</title><link href="https://www.soasme.com/techshack.weekly/verses/e417c8ba-39a6-4f2e-b9fa-0a6df299d616.html" rel="alternate"></link><published>2018-12-12T00:00:00+00:00</published><updated>2018-12-12T00:00:00+00:00</updated><author><name>Ju Lin</name></author><id>tag:www.soasme.com,2018-12-12:/techshack.weekly/verses/e417c8ba-39a6-4f2e-b9fa-0a6df299d616.html</id><summary type="html">&lt;p&gt;&lt;a href="https://vega.github.io/vega/docs/"&gt;查看原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Vega 是一个试图对可视化进行规范的语法。它通过定义一个描述式的语言来定义可交互的图表。这个语言可使用 JSON 定义，生成 Canvas 或者 SVG。
通过它可以定义 transformation，scale，map projection，axes，legends，graphical marks 等等。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://vega.github.io/vega/tutorials/bar-chart/"&gt;Tutorial&lt;/a&gt; 有一个 vega 的概览。
[vega v/s chart.js](https://js.libhunt.com/compare-vega-vs-chart-js）：这个项目目前流行度还不太高。&lt;/p&gt;</summary><content type="html">&lt;p&gt;&lt;a href="https://vega.github.io/vega/docs/"&gt;查看原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Vega 是一个试图对可视化进行规范的语法。它通过定义一个描述式的语言来定义可交互的图表。这个语言可使用 JSON 定义，生成 Canvas 或者 SVG。
通过它可以定义 transformation，scale，map projection，axes，legends，graphical marks 等等。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://vega.github.io/vega/tutorials/bar-chart/"&gt;Tutorial&lt;/a&gt; 有一个 vega 的概览。
[vega v/s chart.js](https://js.libhunt.com/compare-vega-vs-chart-js）：这个项目目前流行度还不太高。&lt;/p&gt;</content></entry><entry><title>Pyparsing - A Python Parsing Module</title><link href="https://www.soasme.com/techshack.weekly/verses/208d1102-a710-4e9f-bef1-cbc460dec98e.html" rel="alternate"></link><published>2018-12-11T00:00:00+00:00</published><updated>2018-12-11T00:00:00+00:00</updated><author><name>Ju Lin</name></author><id>tag:www.soasme.com,2018-12-11:/techshack.weekly/verses/208d1102-a710-4e9f-bef1-cbc460dec98e.html</id><summary type="html">&lt;p&gt;&lt;a href="https://github.com/pyparsing/pyparsing"&gt;查看原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Pyparsing 是一个 lex/yacc 的替代方案，可以用 Python 的语法写出 DSL。
使用起来的体验是语法部分可以用编辑器的高亮和 Linting 做语法检查。&lt;/p&gt;
&lt;p&gt;写了一个例子可以做四则运算，逻辑比较，函数调用。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://gist.github.com/soasme/1685e80a6f70311dbb801823ac8827fa"&gt;https://gist.github.com/soasme/1685e80a6f70311dbb801823ac8827fa&lt;/a&gt;&lt;/p&gt;
&lt;script src="https://gist.github.com/soasme/1685e80a6f70311dbb801823ac8827fa.js"&gt;&lt;/script&gt;</summary><content type="html">&lt;p&gt;&lt;a href="https://github.com/pyparsing/pyparsing"&gt;查看原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Pyparsing 是一个 lex/yacc 的替代方案，可以用 Python 的语法写出 DSL。
使用起来的体验是语法部分可以用编辑器的高亮和 Linting 做语法检查。&lt;/p&gt;
&lt;p&gt;写了一个例子可以做四则运算，逻辑比较，函数调用。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://gist.github.com/soasme/1685e80a6f70311dbb801823ac8827fa"&gt;https://gist.github.com/soasme/1685e80a6f70311dbb801823ac8827fa&lt;/a&gt;&lt;/p&gt;
&lt;script src="https://gist.github.com/soasme/1685e80a6f70311dbb801823ac8827fa.js"&gt;&lt;/script&gt;</content></entry><entry><title>Zero Downtime deployments with Terraform</title><link href="https://www.soasme.com/techshack.weekly/verses/507b2b90-34a1-47b3-9487-16645827d0e9.html" rel="alternate"></link><published>2018-12-04T00:00:00+00:00</published><updated>2018-12-04T00:00:00+00:00</updated><author><name>Ju Lin</name></author><id>tag:www.soasme.com,2018-12-04:/techshack.weekly/verses/507b2b90-34a1-47b3-9487-16645827d0e9.html</id><summary type="html">&lt;p&gt;&lt;a href="https://checklyhq.com/blog/2018/08/an-in-depth-look-at-100-zero-downtime-deployments-with-terraform/"&gt;查看原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文介绍了 Checkly 的工程团队如何使用 AWS EC2 / SQS / Terraform 完成队列 worker 的 zero downtime。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;目标&lt;ul&gt;
&lt;li&gt;worker 在不伤害用户体验的情况下可以杀掉&lt;/li&gt;
&lt;li&gt;多版本 worker 可以共存&lt;/li&gt;
&lt;li&gt;每个 worker 都可以独立升级&lt;/li&gt;
&lt;li&gt;新 worker 一旦就绪立马工作&lt;/li&gt;
&lt;li&gt;当新 worker 都起来以后 老 worker 要被杀掉&lt;/li&gt;
&lt;li&gt;release 出错时停止继续部署&lt;/li&gt;
&lt;li&gt;可以被部署到多个 region&lt;/li&gt;
&lt;li&gt;新 worker 自动加入监控&lt;/li&gt;
&lt;li&gt;release 出错时可以触发警告&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;实现&lt;ul&gt;
&lt;li&gt;使用 cron 发送消息到 sqs 队列。&lt;/li&gt;
&lt;li&gt;workers 订阅一个队列，每台机器 5 …&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;</summary><content type="html">&lt;p&gt;&lt;a href="https://checklyhq.com/blog/2018/08/an-in-depth-look-at-100-zero-downtime-deployments-with-terraform/"&gt;查看原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文介绍了 Checkly 的工程团队如何使用 AWS EC2 / SQS / Terraform 完成队列 worker 的 zero downtime。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;目标&lt;ul&gt;
&lt;li&gt;worker 在不伤害用户体验的情况下可以杀掉&lt;/li&gt;
&lt;li&gt;多版本 worker 可以共存&lt;/li&gt;
&lt;li&gt;每个 worker 都可以独立升级&lt;/li&gt;
&lt;li&gt;新 worker 一旦就绪立马工作&lt;/li&gt;
&lt;li&gt;当新 worker 都起来以后 老 worker 要被杀掉&lt;/li&gt;
&lt;li&gt;release 出错时停止继续部署&lt;/li&gt;
&lt;li&gt;可以被部署到多个 region&lt;/li&gt;
&lt;li&gt;新 worker 自动加入监控&lt;/li&gt;
&lt;li&gt;release 出错时可以触发警告&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;实现&lt;ul&gt;
&lt;li&gt;使用 cron 发送消息到 sqs 队列。&lt;/li&gt;
&lt;li&gt;workers 订阅一个队列，每台机器 5 个 workers。每个 workers 是一个 docker nodejs 进程。&lt;/li&gt;
&lt;li&gt;任务成功调用 &lt;code&gt;done()&lt;/code&gt; 任务失败调用 &lt;code&gt;done(err)&lt;/code&gt;, 任务失败解除锁定重新进入队列。&lt;/li&gt;
&lt;li&gt;autoscaling 可以基于机器的负载自动扩容。&lt;/li&gt;
&lt;li&gt;terraform 设置 aws_instance create_before_destroy=true, 并且基于 &lt;code&gt;while ps|grep xxx; do sleep 5; done&lt;/code&gt; 阻塞执行直到进程启动。aws_instance 的环境变量通过配置 &lt;code&gt;/root/.profile&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;terraform module 可以完成不同 region 配置不同参数。&lt;/li&gt;
&lt;li&gt;部署失败时会处于不确定的状态，不建议自动处理，可能需要人工干预。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;</content></entry><entry><title>Pampy - Pattern Matching for Python</title><link href="https://www.soasme.com/techshack.weekly/verses/69012a7e-a3c7-4e50-a4c4-ab7c27b9f3db.html" rel="alternate"></link><published>2018-12-04T00:00:00+00:00</published><updated>2018-12-04T00:00:00+00:00</updated><author><name>Ju Lin</name></author><id>tag:www.soasme.com,2018-12-04:/techshack.weekly/verses/69012a7e-a3c7-4e50-a4c4-ab7c27b9f3db.html</id><summary type="html">&lt;p&gt;&lt;a href="https://github.com/santinic/pampy"&gt;查看原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Pampy 是一个 Python 的模式匹配的库。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;pampy&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;match&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;_&lt;/span&gt;

&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;fibonacci&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;match&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="n"&gt;_&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;lambda&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;fibonacci&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;fibonacci&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;可以对 dict 进行解构：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="err"&gt;&amp;gt;&amp;gt;&amp;gt; print(match({&amp;quot;a&amp;quot;: &amp;quot;b&amp;quot;, &amp;quot;c&amp;quot;: &amp;quot;d&amp;quot;}, {&amp;quot;a&amp;quot;: _, _: &amp;quot;d&amp;quot;}, lambda x, y: (x, y)))&lt;/span&gt;
&lt;span class="err"&gt;(&amp;quot;b&amp;quot;, &amp;quot;c&amp;quot;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;能简化不少代码 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;&lt;a href="https://github.com/santinic/pampy"&gt;查看原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Pampy 是一个 Python 的模式匹配的库。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;pampy&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;match&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;_&lt;/span&gt;

&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;fibonacci&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;match&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="n"&gt;_&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;lambda&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;fibonacci&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;fibonacci&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;可以对 dict 进行解构：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="err"&gt;&amp;gt;&amp;gt;&amp;gt; print(match({&amp;quot;a&amp;quot;: &amp;quot;b&amp;quot;, &amp;quot;c&amp;quot;: &amp;quot;d&amp;quot;}, {&amp;quot;a&amp;quot;: _, _: &amp;quot;d&amp;quot;}, lambda x, y: (x, y)))&lt;/span&gt;
&lt;span class="err"&gt;(&amp;quot;b&amp;quot;, &amp;quot;c&amp;quot;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;能简化不少代码，缺点是 _ 可能会被别的库用作别的用途。&lt;/p&gt;</content></entry><entry><title>12 Factor CLI Apps</title><link href="https://www.soasme.com/techshack.weekly/verses/7a18cf9b-1b8a-4369-9a15-8ab4e80a59ec.html" rel="alternate"></link><published>2018-12-03T00:00:00+00:00</published><updated>2018-12-03T00:00:00+00:00</updated><author><name>Ju Lin</name></author><id>tag:www.soasme.com,2018-12-03:/techshack.weekly/verses/7a18cf9b-1b8a-4369-9a15-8ab4e80a59ec.html</id><summary type="html">&lt;p&gt;&lt;a href="https://medium.com/@jdxcode/12-factor-cli-apps-dd3c227a0e46"&gt;查看原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文在推广一种写命令行工具的方法论 - 12 Factor CLI Apps.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;提供 &lt;code&gt;-h/--help&lt;/code&gt; / shell completion&lt;/li&gt;
&lt;li&gt;优先使用 flags，而不是 args；flags 也有利于 autocomplete；对于要把参数传给子进程的命令，可以用 &lt;code&gt;--&lt;/code&gt; 分隔开本命令和子进程要用的参数。&lt;/li&gt;
&lt;li&gt;提供 &lt;code&gt;version&lt;/code&gt;, &lt;code&gt;--version&lt;/code&gt;, &lt;code&gt;-V&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;区分开 stdout 和 stderr&lt;/li&gt;
&lt;li&gt;出错时可以提供更多有用信息：error code，error title，error description，how to fix the error，还有 url； 可以在 DEBUG 模式把更多信息打出来。&lt;/li&gt;
&lt;li&gt;打出颜色，进度条，但也支持 NO_PROGRESS …&lt;/li&gt;&lt;/ul&gt;</summary><content type="html">&lt;p&gt;&lt;a href="https://medium.com/@jdxcode/12-factor-cli-apps-dd3c227a0e46"&gt;查看原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文在推广一种写命令行工具的方法论 - 12 Factor CLI Apps.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;提供 &lt;code&gt;-h/--help&lt;/code&gt; / shell completion&lt;/li&gt;
&lt;li&gt;优先使用 flags，而不是 args；flags 也有利于 autocomplete；对于要把参数传给子进程的命令，可以用 &lt;code&gt;--&lt;/code&gt; 分隔开本命令和子进程要用的参数。&lt;/li&gt;
&lt;li&gt;提供 &lt;code&gt;version&lt;/code&gt;, &lt;code&gt;--version&lt;/code&gt;, &lt;code&gt;-V&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;区分开 stdout 和 stderr&lt;/li&gt;
&lt;li&gt;出错时可以提供更多有用信息：error code，error title，error description，how to fix the error，还有 url； 可以在 DEBUG 模式把更多信息打出来。&lt;/li&gt;
&lt;li&gt;打出颜色，进度条，但也支持 NO_PROGRESS, NO_COLOR&lt;/li&gt;
&lt;li&gt;没给参数的时候可以进入交互模式让用户填参数&lt;/li&gt;
&lt;li&gt;打印表格&lt;/li&gt;
&lt;li&gt;快速启动&lt;/li&gt;
&lt;li&gt;使用子命令 &lt;code&gt;$ cmd subcommand&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;可以使用环境变量定义一些配置文件&lt;/li&gt;
&lt;/ul&gt;</content></entry><entry><title>What Happen When K8S</title><link href="https://www.soasme.com/techshack.weekly/verses/c509f2fc-5a02-42a7-8fa9-c97ca00a863e.html" rel="alternate"></link><published>2018-12-03T00:00:00+00:00</published><updated>2018-12-03T00:00:00+00:00</updated><author><name>Ju Lin</name></author><id>tag:www.soasme.com,2018-12-03:/techshack.weekly/verses/c509f2fc-5a02-42a7-8fa9-c97ca00a863e.html</id><summary type="html">&lt;p&gt;&lt;a href="https://github.com/jamiehannaford/what-happens-when-k8s"&gt;查看原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文介绍了在命令行运行 &lt;code&gt;kubectl run --image=nginx --replicas=3&lt;/code&gt; 时 Kubernetes 服务端和客户端的运行时。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;kubectl&lt;/code&gt; 会做 client-side validation, 通过校验的会通过 kubectl generator 组装 HTTP 请求可以发送到 kube-apiserver, 例如 deployment 会组装 DeploymentV1Beta1.&lt;/li&gt;
&lt;li&gt;本地有一个 ~/.kube/cache/dicovery 用于缓存资源的 apiVersion, 例如，deployment 属于 apps/v1.&lt;/li&gt;
&lt;li&gt;kubectl 会根据 &lt;code&gt;--kubeconfig&lt;/code&gt; 或者 &lt;code&gt;$KUBECONFIG&lt;/code&gt; 读取 kubeconfig.&lt;/li&gt;
&lt;li&gt;解析 kubeconfig, 获得 current context, current …&lt;/li&gt;&lt;/ol&gt;</summary><content type="html">&lt;p&gt;&lt;a href="https://github.com/jamiehannaford/what-happens-when-k8s"&gt;查看原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文介绍了在命令行运行 &lt;code&gt;kubectl run --image=nginx --replicas=3&lt;/code&gt; 时 Kubernetes 服务端和客户端的运行时。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;kubectl&lt;/code&gt; 会做 client-side validation, 通过校验的会通过 kubectl generator 组装 HTTP 请求可以发送到 kube-apiserver, 例如 deployment 会组装 DeploymentV1Beta1.&lt;/li&gt;
&lt;li&gt;本地有一个 ~/.kube/cache/dicovery 用于缓存资源的 apiVersion, 例如，deployment 属于 apps/v1.&lt;/li&gt;
&lt;li&gt;kubectl 会根据 &lt;code&gt;--kubeconfig&lt;/code&gt; 或者 &lt;code&gt;$KUBECONFIG&lt;/code&gt; 读取 kubeconfig.&lt;/li&gt;
&lt;li&gt;解析 kubeconfig, 获得 current context, current user, 在即将发出的请求上会附加 token.&lt;/li&gt;
&lt;li&gt;kube-apiserver 启动是需要配置 &lt;code&gt;--client-ca-file&lt;/code&gt; 或者 &lt;code&gt;--token-auth-file&lt;/code&gt;. 启动后就能处理 token&lt;/li&gt;
&lt;li&gt;Authorization: 身份验证通过后，kube-apiserver  会做授权验证，衍生这个 token 对应的身份是否有权限操作这个资源。&lt;/li&gt;
&lt;li&gt;kube-apiserver 接下来会做 admission control - 看这个资源能否被应用在 cluster 上，一般这些操作包括：安全，资源上限等等。&lt;/li&gt;
&lt;li&gt;kube-apiserver 接下来访问 etcd 更新资源。&lt;/li&gt;
&lt;li&gt;kube-controller-manager 接下来会负责在具体的机器上创建资源。例如对于 Deployment，它会创建 RepilcaSet / Pod。&lt;/li&gt;
&lt;li&gt;此时资源还处于 Pending 状态；Scheduler 会监听事件并达到预期状态。例如，Pod 会被 scheduler 分配到一台 Node 上。&lt;/li&gt;
&lt;li&gt;kubelet 感知到自己需要创建 Pod(大约每 20 秒轮询)，于是开始运行自己: 调用 CRI 启动容器，并登记到 Pod 元信息中。Pod 还需要 CNI 插件分配 IP 地址。不同机器间的 Pod 通信通过 overlay networking 实现 - 它可以将路由表同步到多台机器去。&lt;/li&gt;
&lt;li&gt;container 被运行起来，流程大约是 pull image，create container，register resource，报告状态。&lt;/li&gt;
&lt;/ol&gt;</content></entry><entry><title>Things Nobody Told Me About Being a Software Engineer</title><link href="https://www.soasme.com/techshack.weekly/verses/208b7547-75c8-419c-8ad7-9789a05f9ae7.html" rel="alternate"></link><published>2018-12-01T00:00:00+00:00</published><updated>2018-12-01T00:00:00+00:00</updated><author><name>Ju Lin</name></author><id>tag:www.soasme.com,2018-12-01:/techshack.weekly/verses/208b7547-75c8-419c-8ad7-9789a05f9ae7.html</id><summary type="html">&lt;p&gt;&lt;a href="https://anaulin.org/blog/things-nobody-told-me-about-being-a-software-engineer/"&gt;查看原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文描述了一个老工程师的心得。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;测试代码远高于 production code。&lt;/li&gt;
&lt;li&gt;用于 build/release/tooling 的时间跟花在写代码的时间是一样的。这还不计入 on-call, operations, ...&lt;/li&gt;
&lt;li&gt;要部署代码进入生产环境，写代码真的只是很小的一部分。&lt;/li&gt;
&lt;li&gt;时间在前进，轮子也在不停的重造。&lt;/li&gt;
&lt;li&gt;在 debug 和 code review 中要学习如何找到激情。&lt;/li&gt;
&lt;li&gt;工资和技术不强相关。&lt;/li&gt;
&lt;li&gt;CSS 很难！&lt;/li&gt;
&lt;li&gt;闪亮的技术不一定就能风生水起,很经常就莫名其妙死了。&lt;/li&gt;
&lt;li&gt;沟通时挑选 Emoji 是个技术活 &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;衍生思考：☝️  👍 👏&lt;/p&gt;</summary><content type="html">&lt;p&gt;&lt;a href="https://anaulin.org/blog/things-nobody-told-me-about-being-a-software-engineer/"&gt;查看原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文描述了一个老工程师的心得。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;测试代码远高于 production code。&lt;/li&gt;
&lt;li&gt;用于 build/release/tooling 的时间跟花在写代码的时间是一样的。这还不计入 on-call, operations, ...&lt;/li&gt;
&lt;li&gt;要部署代码进入生产环境，写代码真的只是很小的一部分。&lt;/li&gt;
&lt;li&gt;时间在前进，轮子也在不停的重造。&lt;/li&gt;
&lt;li&gt;在 debug 和 code review 中要学习如何找到激情。&lt;/li&gt;
&lt;li&gt;工资和技术不强相关。&lt;/li&gt;
&lt;li&gt;CSS 很难！&lt;/li&gt;
&lt;li&gt;闪亮的技术不一定就能风生水起,很经常就莫名其妙死了。&lt;/li&gt;
&lt;li&gt;沟通时挑选 Emoji 是个技术活 &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;衍生思考：☝️  👍 👏&lt;/p&gt;</content></entry><entry><title>Minio Docs</title><link href="https://www.soasme.com/techshack.weekly/verses/4d587a7b-0b73-4cd4-b61b-45cdb16f902d.html" rel="alternate"></link><published>2018-12-01T00:00:00+00:00</published><updated>2018-12-01T00:00:00+00:00</updated><author><name>Ju Lin</name></author><id>tag:www.soasme.com,2018-12-01:/techshack.weekly/verses/4d587a7b-0b73-4cd4-b61b-45cdb16f902d.html</id><summary type="html">&lt;p&gt;&lt;a href="https://docs.minio.io/"&gt;查看原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Minio 是一个 AWS S3 的兼容工具，可以自己选择搭在想要的机房里。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://docs.minio.io/docs/minio-server-configuration-guide.html"&gt;conf&lt;/a&gt;: 可用配置文件和环境变量，然后用 &lt;code&gt;minio server /data&lt;/code&gt; 启动。&lt;/li&gt;
&lt;li&gt;有 liveness 和 readiness proble: &lt;code&gt;/minio/health/live&lt;/code&gt;, &lt;code&gt;/minio/health/ready&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;a href="https://docs.minio.io/docs/minio-federation-quickstart-guide.html"&gt;fed&lt;/a&gt;: 可使用 etcd_endpoints 作为后端完成 federation&lt;/li&gt;
&lt;li&gt;【client](https://docs.minio.io/docs/minio-client-quickstart-guide.html): 客户端提供 &lt;code&gt;mc ls&lt;/code&gt;, &lt;code&gt;mc cat&lt;/code&gt;, 等一系列 UNIX 兼容的命令。&lt;/li&gt;
&lt;/ul&gt;</summary><content type="html">&lt;p&gt;&lt;a href="https://docs.minio.io/"&gt;查看原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Minio 是一个 AWS S3 的兼容工具，可以自己选择搭在想要的机房里。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://docs.minio.io/docs/minio-server-configuration-guide.html"&gt;conf&lt;/a&gt;: 可用配置文件和环境变量，然后用 &lt;code&gt;minio server /data&lt;/code&gt; 启动。&lt;/li&gt;
&lt;li&gt;有 liveness 和 readiness proble: &lt;code&gt;/minio/health/live&lt;/code&gt;, &lt;code&gt;/minio/health/ready&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;a href="https://docs.minio.io/docs/minio-federation-quickstart-guide.html"&gt;fed&lt;/a&gt;: 可使用 etcd_endpoints 作为后端完成 federation&lt;/li&gt;
&lt;li&gt;【client](https://docs.minio.io/docs/minio-client-quickstart-guide.html): 客户端提供 &lt;code&gt;mc ls&lt;/code&gt;, &lt;code&gt;mc cat&lt;/code&gt;, 等一系列 UNIX 兼容的命令。&lt;/li&gt;
&lt;/ul&gt;</content></entry><entry><title>Pulumi - Guestbook App Tutorial</title><link href="https://www.soasme.com/techshack.weekly/verses/4e22fb2e-6800-49be-bf7f-9907b59329d0.html" rel="alternate"></link><published>2018-12-01T00:00:00+00:00</published><updated>2018-12-01T00:00:00+00:00</updated><author><name>Ju Lin</name></author><id>tag:www.soasme.com,2018-12-01:/techshack.weekly/verses/4e22fb2e-6800-49be-bf7f-9907b59329d0.html</id><summary type="html">&lt;p&gt;&lt;a href="https://pulumi.io/quickstart/kubernetes/tutorial-guestbook.html"&gt;查看原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Pulumi 最近发布的 IAAS 工具包看起来像个 terraform 的 copy。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用 &lt;code&gt;plum new kubernetes-typescript&lt;/code&gt; 新建一个项目。&lt;/li&gt;
&lt;li&gt;写 JS 代码写 YAML。
  &lt;code&gt;let redisMasterService = new k8s.core.v1.Service("redid-master": {"metadata": {…
  let redisMasterDeployment = new k8s.apps.v1.Deployment("redis-master", {spec: {…&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;运行：&lt;code&gt;pulumi up&lt;/code&gt;, 运行前也跟 Terraform 一样需要经过确认。工具可自己决定是创建还是更新。&lt;/li&gt;
&lt;li&gt;也提供跟 Terraform output 一样的功能。&lt;code&gt;pulumi stack output frontendIP …&lt;/code&gt;&lt;/li&gt;&lt;/ul&gt;</summary><content type="html">&lt;p&gt;&lt;a href="https://pulumi.io/quickstart/kubernetes/tutorial-guestbook.html"&gt;查看原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Pulumi 最近发布的 IAAS 工具包看起来像个 terraform 的 copy。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用 &lt;code&gt;plum new kubernetes-typescript&lt;/code&gt; 新建一个项目。&lt;/li&gt;
&lt;li&gt;写 JS 代码写 YAML。
  &lt;code&gt;let redisMasterService = new k8s.core.v1.Service("redid-master": {"metadata": {…
  let redisMasterDeployment = new k8s.apps.v1.Deployment("redis-master", {spec: {…&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;运行：&lt;code&gt;pulumi up&lt;/code&gt;, 运行前也跟 Terraform 一样需要经过确认。工具可自己决定是创建还是更新。&lt;/li&gt;
&lt;li&gt;也提供跟 Terraform output 一样的功能。&lt;code&gt;pulumi stack output frontendIP&lt;/code&gt;, 前提是代码里定义了如何获取这个 output。
  &lt;code&gt;export let frontendIP: plum.Output&amp;lt;string&amp;gt;;
  frontendIP = frontendService.status.apply(status =&amp;gt; status.loadBalancer.ingress[0].ip);&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;</content></entry><entry><title>AWS CNI Proposal</title><link href="https://www.soasme.com/techshack.weekly/verses/da1002e3-2c7f-4c9f-9ebf-57837f31d74b.html" rel="alternate"></link><published>2018-12-01T00:00:00+00:00</published><updated>2018-12-01T00:00:00+00:00</updated><author><name>Ju Lin</name></author><id>tag:www.soasme.com,2018-12-01:/techshack.weekly/verses/da1002e3-2c7f-4c9f-9ebf-57837f31d74b.html</id><summary type="html">&lt;p&gt;&lt;a href="https://github.com/aws/amazon-vpc-cni-k8s/blob/master/docs/cni-proposal.md"&gt;查看原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;AWS VPS CNI K8S&lt;/p&gt;
&lt;p&gt;本文是 aws-cni 的设计文档。AWS Kubernetes CNI 插件可用于在 EKS 中提供类似 Flannel, Calico 这类网络软件的功能 - 为 Pod 配置必要的网络。&lt;/p&gt;
&lt;p&gt;更具体的，它的设计目标：
* 为成为 kubernetes 节点的每个 ec2 实例创建多个 Elastic network interface（ENI），分配二级 IP 地址
* 为每个 Pod 挑选一个可用的二级 IP 地址，把主机跟 Pod 的网络连起来，允许 Pod-Pod, Pod-PodInAnotherHost, Pod-AWSService, Pod-DC, Pod-Internet 多个级别的通信。&lt;/p&gt;
&lt;p&gt;它的需求是 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;&lt;a href="https://github.com/aws/amazon-vpc-cni-k8s/blob/master/docs/cni-proposal.md"&gt;查看原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;AWS VPS CNI K8S&lt;/p&gt;
&lt;p&gt;本文是 aws-cni 的设计文档。AWS Kubernetes CNI 插件可用于在 EKS 中提供类似 Flannel, Calico 这类网络软件的功能 - 为 Pod 配置必要的网络。&lt;/p&gt;
&lt;p&gt;更具体的，它的设计目标：
* 为成为 kubernetes 节点的每个 ec2 实例创建多个 Elastic network interface（ENI），分配二级 IP 地址
* 为每个 Pod 挑选一个可用的二级 IP 地址，把主机跟 Pod 的网络连起来，允许 Pod-Pod, Pod-PodInAnotherHost, Pod-AWSService, Pod-DC, Pod-Internet 多个级别的通信。&lt;/p&gt;
&lt;p&gt;它的需求是：
* Pod 网络必须有高吞吐，高可用，低延迟，Jitter
* 用户可以在不同的粒度控制网络 Policy
* 网络操作简单，能够将 VPC routing policies，security groups 等等粘合起来。
* Pod 网络能够秒级启动。
* 至多管理 2000 台机器。&lt;/p&gt;
&lt;p&gt;VPC 中的 EC2 每台机器都可以有多个 ENI，每个 ENI都可以用多个 IP 地址。主 ENI IP 地址是实例创建时自动分配的，所有的二级地址由 host owner 自己管理，在这个工具中，就是由 aws-cni 插件来完成的。&lt;/p&gt;
&lt;p&gt;能创建的 IP 上线取决于你的 VPC 的 CIDR block，例如 10.0.0.0/16. 假设，每台实例有 N 个ENI，每个 ENI 可以有 M 个地址，那最多可分配的 IP 要么是子网的可用 IP 数量，要么是 N * M - N.&lt;/p&gt;
&lt;p&gt;架构：
&lt;img alt="" src="https://camo.githubusercontent.com/1ee17863f5b874bfdce2e15a198401d5525d0cd0/68747470733a2f2f73332d75732d776573742d312e616d617a6f6e6177732e636f6d2f6c6977656e2d7075626c69632f776972652d6e6574776f726b2e706e67"&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Pod 内部 eth0 inet 是由 ENI 分配的二级地址，例如 10.0.97.30&lt;/li&gt;
&lt;li&gt;Pod 内部的路由表默认路由到 169.254.1.1， 一个写死的 IP&lt;/li&gt;
&lt;li&gt;宿主机这边每块路由表里面也会有相应的 Pod IP 对应的规则&lt;/li&gt;
&lt;li&gt;Pod 到 Pod 通信需要如下配置&lt;ul&gt;
&lt;li&gt;配置 veth pair：host namespace veth &amp;amp; pod namespace veth。&lt;/li&gt;
&lt;li&gt;在 pod namespace 里写入 Pod 的二级地址&lt;/li&gt;
&lt;li&gt;在宿主机的路由表里加上一个 route 规则，让Pod二级地址的数据包可以路由到 veth 对应的 namespace 去。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Local IP Address Manager （L-IPAM） 是用来管理可用二级IP地址池子的工具。当 kubelet 接收到添加 Pod 的请求时，L-IPAM 会马上从池子里分配一个二级IP给 Pod。当可用 IP 低于阈值了，L-IPAM 会自动创建 ENI 分配给实例，然后当其可用时再分配二级 IP。当可用 IP 超过上限时，就销掉回收 ENI。CNI Plugin 本身是通过 gPRC 与 L-IPAM 通信的。&lt;/p&gt;
&lt;p&gt;一些使用上的 Caveats：
* 遇到过 Kubernetes 无论如何也无法成功创建 Pod，Pod 一直处于 ContainerCreating 的状态。当时的原因是同时遇到了 aws-cni 自己的 bug，以及二级 IP 不够用了。
* 在 EKS 的 kube-system namespace 里面有一些叫做 aws-node 的 Pod，它们就是 aws-cni 的 daemonset 创建出来的。&lt;/p&gt;</content></entry><entry><title>Whats new in Python_3_7</title><link href="https://www.soasme.com/techshack.weekly/verses/e6b75fe4-80e0-4e8a-ad82-5473ad74f529.html" rel="alternate"></link><published>2018-12-01T00:00:00+00:00</published><updated>2018-12-01T00:00:00+00:00</updated><author><name>Ju Lin</name></author><id>tag:www.soasme.com,2018-12-01:/techshack.weekly/verses/e6b75fe4-80e0-4e8a-ad82-5473ad74f529.html</id><summary type="html">&lt;p&gt;&lt;a href="https://speakerdeck.com/matrixise/whats-new-in-python-3-dot-7"&gt;查看原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Python 3.7 的新货。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;内建 breakpoint() 函数，在需要的地方插上 &lt;code&gt;breakpoint()&lt;/code&gt; 就能启动调试了。以及，可以通过 PYTHONBREAKPOINT 环境变量配置想用什么软件做当调试器，例如 web-pdb&lt;/li&gt;
&lt;li&gt;Data Class 单纯的数据类，可以约束乱用 dict 的现象。&lt;/li&gt;
&lt;li&gt;可以在 module 级别写 &lt;code&gt;__getattr__&lt;/code&gt; // 有点像 quixote 的 &lt;code&gt;_q_lookup&lt;/code&gt;..&lt;/li&gt;
&lt;li&gt;也可以在 module 级别写 &lt;code&gt;__dir()__ -&amp;gt; List[str]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;time.time_ns() 可以获得纳秒时间了，适合在 performance 排查时使用。&lt;/li&gt;
&lt;li&gt;DeprecationWarning 只在测试和 &lt;strong&gt;main&lt;/strong&gt; 的时候启用。&lt;/li&gt;
&lt;li&gt;可用标准库的 &lt;code&gt;contextvars …&lt;/code&gt;&lt;/li&gt;&lt;/ul&gt;</summary><content type="html">&lt;p&gt;&lt;a href="https://speakerdeck.com/matrixise/whats-new-in-python-3-dot-7"&gt;查看原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Python 3.7 的新货。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;内建 breakpoint() 函数，在需要的地方插上 &lt;code&gt;breakpoint()&lt;/code&gt; 就能启动调试了。以及，可以通过 PYTHONBREAKPOINT 环境变量配置想用什么软件做当调试器，例如 web-pdb&lt;/li&gt;
&lt;li&gt;Data Class 单纯的数据类，可以约束乱用 dict 的现象。&lt;/li&gt;
&lt;li&gt;可以在 module 级别写 &lt;code&gt;__getattr__&lt;/code&gt; // 有点像 quixote 的 &lt;code&gt;_q_lookup&lt;/code&gt;..&lt;/li&gt;
&lt;li&gt;也可以在 module 级别写 &lt;code&gt;__dir()__ -&amp;gt; List[str]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;time.time_ns() 可以获得纳秒时间了，适合在 performance 排查时使用。&lt;/li&gt;
&lt;li&gt;DeprecationWarning 只在测试和 &lt;strong&gt;main&lt;/strong&gt; 的时候启用。&lt;/li&gt;
&lt;li&gt;可用标准库的 &lt;code&gt;contextvars&lt;/code&gt; 实现类似 Flask g 的功能。&lt;/li&gt;
&lt;li&gt;以前要想读取包的非 Python 部分的文件，需要用 &lt;code&gt;read(open(dirname/'data.txt'))&lt;/code&gt; 这样的代码，现在可以用 &lt;code&gt;importlib.resources.read_binary('this.is.my.module', 'data.txt')&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;有序 Dict。&lt;/li&gt;
&lt;li&gt;Async/Await 是关键字。&lt;/li&gt;
&lt;li&gt;不用操作 asyncio loop 了，可以用 &lt;code&gt;asyncio.run(coro)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;python -X dev&lt;/code&gt;：开发者向的很多 debug 工具和运行时检查，也打开了 asyncio 的 debug mode，crash 的时候有 dump。&lt;/li&gt;
&lt;/ul&gt;</content></entry><entry><title>GlusterFS Architecture</title><link href="https://www.soasme.com/techshack.weekly/verses/40288b32-c0f1-4cbb-9dcd-cb3803809384.html" rel="alternate"></link><published>2018-11-30T00:00:00+00:00</published><updated>2018-11-30T00:00:00+00:00</updated><author><name>Ju Lin</name></author><id>tag:www.soasme.com,2018-11-30:/techshack.weekly/verses/40288b32-c0f1-4cbb-9dcd-cb3803809384.html</id><summary type="html">&lt;p&gt;&lt;a href="https://docs.gluster.org/en/latest/Quick-Start-Guide/Architecture/"&gt;查看原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;GlusterFS 是一个分布式的文件系统，基本存储单元是 Brick，一组 Bricks 组成一个 Volume，一个 Volume 通过 FUSE 挂载到 Mount Point 上。大多数操作的基本单元是 Volume。&lt;/p&gt;
&lt;p&gt;GlusterFS 可以使用多种 Volume：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;默认：文件存储于单个 Brick 上。这也意味着数据可能因为硬件原因造成丢失。
  &lt;img alt="Distributed Volume" src="https://cloud.githubusercontent.com/assets/10970993/7412364/ac0a300c-ef5f-11e4-8599-e7d06de1165c.png" title="Distributed Volume"&gt;&lt;/li&gt;
&lt;li&gt;Replicated Glusterfs Volume: 文件 Replicate 到多个 Bricks 上。一般首选该模式。
  &lt;img alt="Replicated Clusterfs Volume" src="https://cloud.githubusercontent.com/assets/10970993/7412379/d75272a6-ef5f-11e4-869a-c355e8505747.png"&gt;&lt;/li&gt;
&lt;li&gt;Distributed Replicated Glusterfs Volume: 文件 Replicate 到某个 Volume 的多个 Bricks 上。
  &lt;img alt="Distributed Replicated Glusterfs Volume" src="https://cloud.githubusercontent.com/assets/10970993/7412402/23a17eae-ef60-11e4-8813-a40a2384c5c2.png"&gt;&lt;/li&gt;
&lt;li&gt;Striped Glusterfs Volume …&lt;/li&gt;&lt;/ul&gt;</summary><content type="html">&lt;p&gt;&lt;a href="https://docs.gluster.org/en/latest/Quick-Start-Guide/Architecture/"&gt;查看原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;GlusterFS 是一个分布式的文件系统，基本存储单元是 Brick，一组 Bricks 组成一个 Volume，一个 Volume 通过 FUSE 挂载到 Mount Point 上。大多数操作的基本单元是 Volume。&lt;/p&gt;
&lt;p&gt;GlusterFS 可以使用多种 Volume：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;默认：文件存储于单个 Brick 上。这也意味着数据可能因为硬件原因造成丢失。
  &lt;img alt="Distributed Volume" src="https://cloud.githubusercontent.com/assets/10970993/7412364/ac0a300c-ef5f-11e4-8599-e7d06de1165c.png" title="Distributed Volume"&gt;&lt;/li&gt;
&lt;li&gt;Replicated Glusterfs Volume: 文件 Replicate 到多个 Bricks 上。一般首选该模式。
  &lt;img alt="Replicated Clusterfs Volume" src="https://cloud.githubusercontent.com/assets/10970993/7412379/d75272a6-ef5f-11e4-869a-c355e8505747.png"&gt;&lt;/li&gt;
&lt;li&gt;Distributed Replicated Glusterfs Volume: 文件 Replicate 到某个 Volume 的多个 Bricks 上。
  &lt;img alt="Distributed Replicated Glusterfs Volume" src="https://cloud.githubusercontent.com/assets/10970993/7412402/23a17eae-ef60-11e4-8813-a40a2384c5c2.png"&gt;&lt;/li&gt;
&lt;li&gt;Striped Glusterfs Volume: 大文件被切分成小 Chunk，再被分别存储于多个 Volume 的 Bricks 上。
  &lt;img alt="Striped Glusterfs Volume" src="https://cloud.githubusercontent.com/assets/10970993/7412387/f411fa56-ef5f-11e4-8e78-a0896a47625a.png"&gt;&lt;/li&gt;
&lt;li&gt;Distributed Striped Glusterfs Volume: 与上面类似，改进是每个 Volume 的多个 Bricks 上。
  &lt;img alt="Distributed Striped Glusterfs Volume" src="https://cloud.githubusercontent.com/assets/10970993/7412394/0ce267d2-ef60-11e4-9959-43465a2a25f7.png"&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;GlusterFS 通过 FUSE 挂载到文件系统去。作为用户态的文件系统，所有 libfuse 与 FUSE 内核代码的通信都是通过一个特殊的文件描述符 &lt;code&gt;/dev/fuse&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;Translator 是 GlusterFS 中的核心概念 - 所有请求都被 Translator 处理，进而 a) 产生新的请求 2) 被拦截 3) 修改请求。 Translators 包括：负责读写数据到本地文件系统的 Storage，处理Bricks分布式读写的 Cluster，加解密 Encryption，通信协议 Protocol，权限管理的 System，决定如何调度写请求到集群的 Scheduler 等等。整个 Translator 的两条链 Client-stack 和 Server-stack 穿起来就构成了一次完整的集群读写请求。&lt;/p&gt;</content></entry><entry><title>GlusterFS Quickstart</title><link href="https://www.soasme.com/techshack.weekly/verses/a0dead75-ecf6-40ff-a123-6ea14f15ce66.html" rel="alternate"></link><published>2018-11-30T00:00:00+00:00</published><updated>2018-11-30T00:00:00+00:00</updated><author><name>Ju Lin</name></author><id>tag:www.soasme.com,2018-11-30:/techshack.weekly/verses/a0dead75-ecf6-40ff-a123-6ea14f15ce66.html</id><summary type="html">&lt;p&gt;&lt;a href="https://docs.gluster.org/en/latest/Quick-Start-Guide/Quickstart/"&gt;查看原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;安装 GlusterFS 需要至少 3台服务器，每台服务器一块 disk 装 OS，另一块放数据。需要在每台机器上把 &lt;code&gt;/data&lt;/code&gt; 目录建在 &lt;code&gt;/dev/sdb1&lt;/code&gt; (假设是这块 disk），然后配置到 &lt;code&gt;/etc/fstab&lt;/code&gt; 中，可通过 mount 立即挂载。需要启动 glusterfs-server, 配置防火墙，每台 server 需要配置对应集群机器的 peer probe。最后集群启动好以后就可以通过 &lt;code&gt;gluster volume create&lt;/code&gt; 创建 Volume。&lt;/p&gt;</summary><content type="html">&lt;p&gt;&lt;a href="https://docs.gluster.org/en/latest/Quick-Start-Guide/Quickstart/"&gt;查看原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;安装 GlusterFS 需要至少 3台服务器，每台服务器一块 disk 装 OS，另一块放数据。需要在每台机器上把 &lt;code&gt;/data&lt;/code&gt; 目录建在 &lt;code&gt;/dev/sdb1&lt;/code&gt; (假设是这块 disk），然后配置到 &lt;code&gt;/etc/fstab&lt;/code&gt; 中，可通过 mount 立即挂载。需要启动 glusterfs-server, 配置防火墙，每台 server 需要配置对应集群机器的 peer probe。最后集群启动好以后就可以通过 &lt;code&gt;gluster volume create&lt;/code&gt; 创建 Volume。&lt;/p&gt;</content></entry><entry><title>Stellar - A Simplified Container System</title><link href="https://www.soasme.com/techshack.weekly/verses/b95d451a-8928-4653-a4fd-82d989c57c3e.html" rel="alternate"></link><published>2018-11-21T00:00:00+00:00</published><updated>2018-11-21T00:00:00+00:00</updated><author><name>Ju Lin</name></author><id>tag:www.soasme.com,2018-11-21:/techshack.weekly/verses/b95d451a-8928-4653-a4fd-82d989c57c3e.html</id><summary type="html">&lt;p&gt;&lt;a href="https://github.com/ehazlett/stellar"&gt;查看原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Stellar 是一个低功耗的 kubernetes 替代方案。使用 containerd 运行容器，CNI 搭建 multihost 网络，普通 DNS 做服务发现，NATS 实现集群的事件系统。&lt;/p&gt;
&lt;p&gt;部署需要：安装 containerd, 把 sctl, stellar, stellar-cni-ipam 丢进 $BIN, 然后添加配置，在多节点上运行即可。&lt;/p&gt;</summary><content type="html">&lt;p&gt;&lt;a href="https://github.com/ehazlett/stellar"&gt;查看原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Stellar 是一个低功耗的 kubernetes 替代方案。使用 containerd 运行容器，CNI 搭建 multihost 网络，普通 DNS 做服务发现，NATS 实现集群的事件系统。&lt;/p&gt;
&lt;p&gt;部署需要：安装 containerd, 把 sctl, stellar, stellar-cni-ipam 丢进 $BIN, 然后添加配置，在多节点上运行即可。&lt;/p&gt;</content></entry><entry><title>Observability time series vs logging vs tracing</title><link href="https://www.soasme.com/techshack.weekly/verses/18544b0c-6f3a-42bd-acbe-557e461313f5.html" rel="alternate"></link><published>2018-11-07T00:00:00+00:00</published><updated>2018-11-07T00:00:00+00:00</updated><author><name>Ju Lin</name></author><id>tag:www.soasme.com,2018-11-07:/techshack.weekly/verses/18544b0c-6f3a-42bd-acbe-557e461313f5.html</id><summary type="html">&lt;p&gt;&lt;a href="https://kubedex.com/observability-time-series-vs-logging-vs-tracing/"&gt;查看原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文就 Monitoring 涉及到的三种数据结构：Time Series, Log Event, Tracing Span 提供了通用解决方案。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://i0.wp.com/kubedex.com/wp-content/uploads/2018/10/Screen-Shot-2018-10-18-at-14.38.51.png?resize=1024%2C441&amp;amp;ssl=1"&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;TimeSeries: 监控的时间序列数据，自搭首选 Prometheus，买服务用 DataDog。InfluxDB 可以作为 Prometheus 的另外一个方案。不推荐 Cassandra， Elastic，写性能太差。&lt;/li&gt;
&lt;li&gt;Log Event: 应用产生的日子条目，数据量大，自搭首选 Elastic 全家桶，买服务用 Splunk。这里的日志特指已经把日志解析成 JSON 这样的结构化数据。&lt;/li&gt;
&lt;li&gt;Tracing：服务追踪产生的数据，首选 Jaeger(k8s), Zipkin，OpenAPM。这类服务太贵了，建议自搭。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;结论：要想做好服务的 Observability，这三类数据是无论如何要收集好的 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;&lt;a href="https://kubedex.com/observability-time-series-vs-logging-vs-tracing/"&gt;查看原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文就 Monitoring 涉及到的三种数据结构：Time Series, Log Event, Tracing Span 提供了通用解决方案。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://i0.wp.com/kubedex.com/wp-content/uploads/2018/10/Screen-Shot-2018-10-18-at-14.38.51.png?resize=1024%2C441&amp;amp;ssl=1"&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;TimeSeries: 监控的时间序列数据，自搭首选 Prometheus，买服务用 DataDog。InfluxDB 可以作为 Prometheus 的另外一个方案。不推荐 Cassandra， Elastic，写性能太差。&lt;/li&gt;
&lt;li&gt;Log Event: 应用产生的日子条目，数据量大，自搭首选 Elastic 全家桶，买服务用 Splunk。这里的日志特指已经把日志解析成 JSON 这样的结构化数据。&lt;/li&gt;
&lt;li&gt;Tracing：服务追踪产生的数据，首选 Jaeger(k8s), Zipkin，OpenAPM。这类服务太贵了，建议自搭。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;结论：要想做好服务的 Observability，这三类数据是无论如何要收集好的。Prometheus, Grafana, Elastic, Kibana 这几个工具经过蛮多年的积累，已经挺不错够成熟了。&lt;/p&gt;</content></entry><entry><title>File parts in pathlib</title><link href="https://www.soasme.com/techshack.weekly/verses/25190cf0-7cd6-4040-9fa1-312bd4ba5684.html" rel="alternate"></link><published>2018-11-07T00:00:00+00:00</published><updated>2018-11-07T00:00:00+00:00</updated><author><name>Ju Lin</name></author><id>tag:www.soasme.com,2018-11-07:/techshack.weekly/verses/25190cf0-7cd6-4040-9fa1-312bd4ba5684.html</id><summary type="html">&lt;p&gt;&lt;a href="https://amir.rachum.com/blog/2018/06/29/file-parts/"&gt;查看原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文给出文件路径的几个部分的术语：&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://amir.rachum.com/images/posts/file-parts.PNG"&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;/path/to/README.en.md&lt;/code&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;root: /&lt;/li&gt;
&lt;li&gt;parent: /path/to&lt;/li&gt;
&lt;li&gt;stem: README.en&lt;/li&gt;
&lt;li&gt;suffix: .md&lt;/li&gt;
&lt;li&gt;suffixes: .en.md&lt;/li&gt;
&lt;li&gt;name: README.en.md&lt;/li&gt;
&lt;/ul&gt;</summary><content type="html">&lt;p&gt;&lt;a href="https://amir.rachum.com/blog/2018/06/29/file-parts/"&gt;查看原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文给出文件路径的几个部分的术语：&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://amir.rachum.com/images/posts/file-parts.PNG"&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;/path/to/README.en.md&lt;/code&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;root: /&lt;/li&gt;
&lt;li&gt;parent: /path/to&lt;/li&gt;
&lt;li&gt;stem: README.en&lt;/li&gt;
&lt;li&gt;suffix: .md&lt;/li&gt;
&lt;li&gt;suffixes: .en.md&lt;/li&gt;
&lt;li&gt;name: README.en.md&lt;/li&gt;
&lt;/ul&gt;</content></entry><entry><title>Envoy and gRPC-Web - an alternative to REST</title><link href="https://www.soasme.com/techshack.weekly/verses/e0acf8ee-35f7-4fb2-9c5a-b84b4880102b.html" rel="alternate"></link><published>2018-11-07T00:00:00+00:00</published><updated>2018-11-07T00:00:00+00:00</updated><author><name>Ju Lin</name></author><id>tag:www.soasme.com,2018-11-07:/techshack.weekly/verses/e0acf8ee-35f7-4fb2-9c5a-b84b4880102b.html</id><summary type="html">&lt;p&gt;&lt;a href="https://blog.envoyproxy.io/envoy-and-grpc-web-a-fresh-new-alternative-to-rest-6504ce7eb880"&gt;查看原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文描述了这样一套框架：使用 gRPC-web 作为前端，gRPC 作为通信协议，Envoy 作为暴露 gRPC 服务的代理。如果后端的各种内部服务都选用 gRPC 接口的话，这套方法可以作为 REST 的替代品，毕竟干嘛不全部用一套接口呢。&lt;/p&gt;</summary><content type="html">&lt;p&gt;&lt;a href="https://blog.envoyproxy.io/envoy-and-grpc-web-a-fresh-new-alternative-to-rest-6504ce7eb880"&gt;查看原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文描述了这样一套框架：使用 gRPC-web 作为前端，gRPC 作为通信协议，Envoy 作为暴露 gRPC 服务的代理。如果后端的各种内部服务都选用 gRPC 接口的话，这套方法可以作为 REST 的替代品，毕竟干嘛不全部用一套接口呢。&lt;/p&gt;</content></entry><entry><title>Tabnine - all-language autocompleter</title><link href="https://www.soasme.com/techshack.weekly/verses/e151c011-b4da-4b01-959a-f6ab37ada8f5.html" rel="alternate"></link><published>2018-11-07T00:00:00+00:00</published><updated>2018-11-07T00:00:00+00:00</updated><author><name>Ju Lin</name></author><id>tag:www.soasme.com,2018-11-07:/techshack.weekly/verses/e151c011-b4da-4b01-959a-f6ab37ada8f5.html</id><summary type="html">&lt;p&gt;&lt;a href="https://tabnine.com/"&gt;查看原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Tabnine 是一款用机器学习模型的思路做 autocompleter。经过试用我觉得对于曾经写过的代码，要写类似代码的时候表现的很惊艳。&lt;/p&gt;
&lt;p&gt;基本思路：项目代码排除 gitignore 后以后的文件，进入 Text Domain，算出 words。写代码的时候，编辑器插件发出即时 query，比对接下来要打哪些字。&lt;/p&gt;
&lt;p&gt;项目超过 200kb 的话需要买 license。&lt;/p&gt;</summary><content type="html">&lt;p&gt;&lt;a href="https://tabnine.com/"&gt;查看原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Tabnine 是一款用机器学习模型的思路做 autocompleter。经过试用我觉得对于曾经写过的代码，要写类似代码的时候表现的很惊艳。&lt;/p&gt;
&lt;p&gt;基本思路：项目代码排除 gitignore 后以后的文件，进入 Text Domain，算出 words。写代码的时候，编辑器插件发出即时 query，比对接下来要打哪些字。&lt;/p&gt;
&lt;p&gt;项目超过 200kb 的话需要买 license。&lt;/p&gt;</content></entry><entry><title>What I learned by bringing down linkedin</title><link href="https://www.soasme.com/techshack.weekly/verses/e915e6c8-6de7-46ef-a7c6-9ad2c0eec4da.html" rel="alternate"></link><published>2018-11-07T00:00:00+00:00</published><updated>2018-11-07T00:00:00+00:00</updated><author><name>Ju Lin</name></author><id>tag:www.soasme.com,2018-11-07:/techshack.weekly/verses/e915e6c8-6de7-46ef-a7c6-9ad2c0eec4da.html</id><summary type="html">&lt;p&gt;&lt;a href="https://venturebeat.com/2018/10/13/what-i-learned-by-bringing-down-linkedin-com/"&gt;查看原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Linkedin 的 SRE 工程师搞挂了一个多小时的网站。起因是把线上环境弄脏了，回滚的时候又把一半的服务拿去做滚动升级，最后发生了雪崩 - 剩下的那一半服务器不够承载流量直到挂了。&lt;/p&gt;
&lt;p&gt;事故管理：大部分事故都不是一个人的责任，它一定是环环相扣导致的。事故管理对事故不对人，找到原因，做出改进，就这样。&lt;/p&gt;</summary><content type="html">&lt;p&gt;&lt;a href="https://venturebeat.com/2018/10/13/what-i-learned-by-bringing-down-linkedin-com/"&gt;查看原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Linkedin 的 SRE 工程师搞挂了一个多小时的网站。起因是把线上环境弄脏了，回滚的时候又把一半的服务拿去做滚动升级，最后发生了雪崩 - 剩下的那一半服务器不够承载流量直到挂了。&lt;/p&gt;
&lt;p&gt;事故管理：大部分事故都不是一个人的责任，它一定是环环相扣导致的。事故管理对事故不对人，找到原因，做出改进，就这样。&lt;/p&gt;</content></entry><entry><title>Think twice before using Helm</title><link href="https://www.soasme.com/techshack.weekly/verses/f4e8cece-9d04-4e0b-acf8-3c9e77250f96.html" rel="alternate"></link><published>2018-11-07T00:00:00+00:00</published><updated>2018-11-07T00:00:00+00:00</updated><author><name>Ju Lin</name></author><id>tag:www.soasme.com,2018-11-07:/techshack.weekly/verses/f4e8cece-9d04-4e0b-acf8-3c9e77250f96.html</id><summary type="html">&lt;p&gt;&lt;a href="https://medium.com/virtuslab/think-twice-before-using-helm-25fbb18bc822"&gt;查看原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文作者的一家之言是使用 Helm 之前需要三思，列举了几样 Helm 的缺点，想使用 Helm 的同学一定要想清楚怎么克服这些困难。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;它貌似没带来什么价值。&lt;/li&gt;
&lt;li&gt;需要额外在 k8s 的 auth/access control 外再加一层 tiller 的 auth/access control, 负担大。&lt;/li&gt;
&lt;li&gt;模板工具其实可以用 &lt;code&gt;k apply --dry-run&lt;/code&gt; 来做类似的事情&lt;/li&gt;
&lt;li&gt;Kubernetes Secrets 的管理没有变的更简单。&lt;/li&gt;
&lt;li&gt;Helm 无法做  Infrastructure 级别的组件管理，例如 kibe-dns, cni provider, cluster autoscaler.&lt;/li&gt;
&lt;li&gt;Helm state 存在 ConfigMap 里面，有 1MB 的限制 …&lt;/li&gt;&lt;/ul&gt;</summary><content type="html">&lt;p&gt;&lt;a href="https://medium.com/virtuslab/think-twice-before-using-helm-25fbb18bc822"&gt;查看原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文作者的一家之言是使用 Helm 之前需要三思，列举了几样 Helm 的缺点，想使用 Helm 的同学一定要想清楚怎么克服这些困难。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;它貌似没带来什么价值。&lt;/li&gt;
&lt;li&gt;需要额外在 k8s 的 auth/access control 外再加一层 tiller 的 auth/access control, 负担大。&lt;/li&gt;
&lt;li&gt;模板工具其实可以用 &lt;code&gt;k apply --dry-run&lt;/code&gt; 来做类似的事情&lt;/li&gt;
&lt;li&gt;Kubernetes Secrets 的管理没有变的更简单。&lt;/li&gt;
&lt;li&gt;Helm 无法做  Infrastructure 级别的组件管理，例如 kibe-dns, cni provider, cluster autoscaler.&lt;/li&gt;
&lt;li&gt;Helm state 存在 ConfigMap 里面，有 1MB 的限制&lt;/li&gt;
&lt;li&gt;太经常会把东西升挂，error handling 也不友好，很可能最后要 helm delete —purge 清干净再来一遍&lt;/li&gt;
&lt;li&gt;Tiller 没有 HA，有单点故障的风险。&lt;/li&gt;
&lt;li&gt;下一代？可能不走 CS 模型，不需要部署 Tiller，内嵌 Lua 脚本。但是还是在 Charts 里面加了不少复杂度进去。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;衍生思考：我觉得 helm 带来的价值至少有： yaml 动态渲染，社区维护的模块。基本同意他列举的问题。&lt;/p&gt;</content></entry><entry><title>Microservice Architecture at Medium</title><link href="https://www.soasme.com/techshack.weekly/verses/11f5fb91-6b28-42d3-b430-f179acef8542.html" rel="alternate"></link><published>2018-11-06T00:00:00+00:00</published><updated>2018-11-06T00:00:00+00:00</updated><author><name>Ju Lin</name></author><id>tag:www.soasme.com,2018-11-06:/techshack.weekly/verses/11f5fb91-6b28-42d3-b430-f179acef8542.html</id><summary type="html">&lt;p&gt;&lt;a href="https://medium.engineering/microservice-architecture-at-medium-9c33805eb74f"&gt;查看原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文介绍了 Medium 的 Microservices 架构。Medium 跟进的比较晚，在不伤害开发的生产力的前提下，他们总结出了几点策略：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;新服务需要有价值，要么是产品上的，要么是工程上的。&lt;/li&gt;
&lt;li&gt;服务之间不要共享存储。具体来说，可以抽象一个服务专门处理一类数据，或者 grpc/http pubsub, 或者用 ETL 管线同步数据。
  &lt;img alt="" src="https://cdn-images-1.medium.com/max/2000/1*PRdrp_MZ3C2KwKHRr83XbA.png"&gt;&lt;/li&gt;
&lt;li&gt;区分 building a service &amp;amp; running a service。&lt;/li&gt;
&lt;li&gt;服务需要很容易被观测&lt;/li&gt;
&lt;li&gt;不是每个服务都需要从头撸&lt;/li&gt;
&lt;li&gt;仔细处理服务失效&lt;/li&gt;
&lt;li&gt;防止 microservice syndromes 粗线：用 微服务会引入更多问题。例如需要仔细建模，衡量引入的语言和技术栈，服务耦合，observability，倾向于开发新服务而不是修bug。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Medium 目前的技术栈是：一个大 Node 应用为主，一些小服务为辅 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;&lt;a href="https://medium.engineering/microservice-architecture-at-medium-9c33805eb74f"&gt;查看原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文介绍了 Medium 的 Microservices 架构。Medium 跟进的比较晚，在不伤害开发的生产力的前提下，他们总结出了几点策略：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;新服务需要有价值，要么是产品上的，要么是工程上的。&lt;/li&gt;
&lt;li&gt;服务之间不要共享存储。具体来说，可以抽象一个服务专门处理一类数据，或者 grpc/http pubsub, 或者用 ETL 管线同步数据。
  &lt;img alt="" src="https://cdn-images-1.medium.com/max/2000/1*PRdrp_MZ3C2KwKHRr83XbA.png"&gt;&lt;/li&gt;
&lt;li&gt;区分 building a service &amp;amp; running a service。&lt;/li&gt;
&lt;li&gt;服务需要很容易被观测&lt;/li&gt;
&lt;li&gt;不是每个服务都需要从头撸&lt;/li&gt;
&lt;li&gt;仔细处理服务失效&lt;/li&gt;
&lt;li&gt;防止 microservice syndromes 粗线：用 微服务会引入更多问题。例如需要仔细建模，衡量引入的语言和技术栈，服务耦合，observability，倾向于开发新服务而不是修bug。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Medium 目前的技术栈是：一个大 Node 应用为主，一些小服务为辅。&lt;/p&gt;</content></entry><entry><title>What is the SSL Certificate Subject Alternative Name</title><link href="https://www.soasme.com/techshack.weekly/verses/433ca577-e597-4700-89e2-8d466d64f7cf.html" rel="alternate"></link><published>2018-11-06T00:00:00+00:00</published><updated>2018-11-06T00:00:00+00:00</updated><author><name>Ju Lin</name></author><id>tag:www.soasme.com,2018-11-06:/techshack.weekly/verses/433ca577-e597-4700-89e2-8d466d64f7cf.html</id><summary type="html">&lt;p&gt;&lt;a href="https://support.dnsimple.com/articles/what-is-ssl-san/"&gt;查看原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;SSL SAN 是一个 SSL 证书的扩展，允许在证书里面声明额外的域名。&lt;/p&gt;
&lt;p&gt;一般的证书只能适配一个域名，例如 一个 enqueuezero.com 的证书是不可以用在 donate.enqueuezero.com 网站上的（Technically，你可以，但是浏览器会标记网站不安全，可能会被窃听）。&lt;/p&gt;
&lt;p&gt;SAN 可以让你在给 enqueuezero.com 签发的证书里面再塞入一个 Subject Alternative Name，例如 *.enqueuezero.com。这样这个证书可以同时使用在 enqueuezero.com, donate.enqueuezero.com 上。&lt;/p&gt;
&lt;p&gt;衍生思考：为什么要有这么个东西? 估计是最开始设计证书这一套的人没有想到大家会有这样的需求吧。。。&lt;/p&gt;</summary><content type="html">&lt;p&gt;&lt;a href="https://support.dnsimple.com/articles/what-is-ssl-san/"&gt;查看原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;SSL SAN 是一个 SSL 证书的扩展，允许在证书里面声明额外的域名。&lt;/p&gt;
&lt;p&gt;一般的证书只能适配一个域名，例如 一个 enqueuezero.com 的证书是不可以用在 donate.enqueuezero.com 网站上的（Technically，你可以，但是浏览器会标记网站不安全，可能会被窃听）。&lt;/p&gt;
&lt;p&gt;SAN 可以让你在给 enqueuezero.com 签发的证书里面再塞入一个 Subject Alternative Name，例如 *.enqueuezero.com。这样这个证书可以同时使用在 enqueuezero.com, donate.enqueuezero.com 上。&lt;/p&gt;
&lt;p&gt;衍生思考：为什么要有这么个东西? 估计是最开始设计证书这一套的人没有想到大家会有这样的需求吧。。。&lt;/p&gt;</content></entry><entry><title>GitHub October 21 事故分析</title><link href="https://www.soasme.com/techshack.weekly/verses/add18dc5-ee9d-4a4f-8a79-b8fbd3f4b948.html" rel="alternate"></link><published>2018-11-06T00:00:00+00:00</published><updated>2018-11-06T00:00:00+00:00</updated><author><name>Ju Lin</name></author><id>tag:www.soasme.com,2018-11-06:/techshack.weekly/verses/add18dc5-ee9d-4a4f-8a79-b8fbd3f4b948.html</id><summary type="html">&lt;p&gt;&lt;a href="https://blog.github.com/2018-10-30-oct21-post-incident-analysis/"&gt;查看原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文总结了为什么 GitHub 挂了一天多。&lt;/p&gt;
&lt;p&gt;简单来说，有那么 43 秒的时间，东海岸的网络hub跟机房网络不通，导致 MySQL Raft Orchestrator 把 master 从东海岸切到了西海岸。就是一次脑裂，东西两边都有数据写进了数据库。工程师们决定保障数据一致性，所以就给服务降级，再慢慢迁移数据。&lt;/p&gt;
&lt;p&gt;思考：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;应急响应的博客服务怎么可以用自家服务呢，还是尽量用第三方服务/或者完全在别的地方托管比较好。&lt;/li&gt;
&lt;li&gt;是否可以增加一份预算，当备份传输太慢的时候，直接让工程师带上硬盘，用几小时直飞到另外一个机房去作为 Plan B?&lt;/li&gt;
&lt;li&gt;公有云的 blob 服务是否合适用于备份 TB 级别的数据？解压出来进新的 MysQL 服务器也需要很久时间。最能治本的方案可以在 Raft 集群外再做一个热备的 master，也即是文末提到的 multiple data centers in an active …&lt;/li&gt;&lt;/ul&gt;</summary><content type="html">&lt;p&gt;&lt;a href="https://blog.github.com/2018-10-30-oct21-post-incident-analysis/"&gt;查看原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文总结了为什么 GitHub 挂了一天多。&lt;/p&gt;
&lt;p&gt;简单来说，有那么 43 秒的时间，东海岸的网络hub跟机房网络不通，导致 MySQL Raft Orchestrator 把 master 从东海岸切到了西海岸。就是一次脑裂，东西两边都有数据写进了数据库。工程师们决定保障数据一致性，所以就给服务降级，再慢慢迁移数据。&lt;/p&gt;
&lt;p&gt;思考：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;应急响应的博客服务怎么可以用自家服务呢，还是尽量用第三方服务/或者完全在别的地方托管比较好。&lt;/li&gt;
&lt;li&gt;是否可以增加一份预算，当备份传输太慢的时候，直接让工程师带上硬盘，用几小时直飞到另外一个机房去作为 Plan B?&lt;/li&gt;
&lt;li&gt;公有云的 blob 服务是否合适用于备份 TB 级别的数据？解压出来进新的 MysQL 服务器也需要很久时间。最能治本的方案可以在 Raft 集群外再做一个热备的 master，也即是文末提到的 multiple data centers in an active/active/active design.。&lt;/li&gt;
&lt;li&gt;Chaos Engineering 还没介入他们的工程文化。&lt;/li&gt;
&lt;li&gt;本次事故，跨机房的 leader 切换是根源。Leader 选举不是万金油，Raft 它不能保证任意时刻只有一个 Leader（脑裂）。关于这个话题，欢迎查看我的一篇讨论：&lt;a href="https://enqueuezero.com/raft-and-the-nature-of-time.html"&gt;Raft and The Nature of Time&lt;/a&gt;。&lt;/li&gt;
&lt;/ul&gt;</content></entry><entry><title>AWK FAQ</title><link href="https://www.soasme.com/techshack.weekly/verses/ddbc65b9-9202-4c87-a68a-cd8bd40929e2.html" rel="alternate"></link><published>2018-11-06T00:00:00+00:00</published><updated>2018-11-06T00:00:00+00:00</updated><author><name>Ju Lin</name></author><id>tag:www.soasme.com,2018-11-06:/techshack.weekly/verses/ddbc65b9-9202-4c87-a68a-cd8bd40929e2.html</id><summary type="html">&lt;p&gt;&lt;a href="http://www.faqs.org/faqs/computer-lang/awk/faq/"&gt;查看原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文整理了关于 AWK 的书籍和资源。目前有十多种 awk 的实现，其中 gawk 用的比较多。不用 perl 而用 awk 的原因是 awk 很可能已经预装在各种系统里面马上就能用。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;clear perl code is better than unclear awk code; but NOTHING comes close to unclear perl code&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在 awk 中使用环境变量比较简单的办法：&lt;code&gt;awk -v name="$USER" '{print name}'&lt;/code&gt; 或者 &lt;code&gt;awk '{print ENVIRON["USER"]}'&lt;/code&gt;&lt;/p&gt;</summary><content type="html">&lt;p&gt;&lt;a href="http://www.faqs.org/faqs/computer-lang/awk/faq/"&gt;查看原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文整理了关于 AWK 的书籍和资源。目前有十多种 awk 的实现，其中 gawk 用的比较多。不用 perl 而用 awk 的原因是 awk 很可能已经预装在各种系统里面马上就能用。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;clear perl code is better than unclear awk code; but NOTHING comes close to unclear perl code&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在 awk 中使用环境变量比较简单的办法：&lt;code&gt;awk -v name="$USER" '{print name}'&lt;/code&gt; 或者 &lt;code&gt;awk '{print ENVIRON["USER"]}'&lt;/code&gt;&lt;/p&gt;</content></entry><entry><title>How I organize my knowledge as a Software Engineer</title><link href="https://www.soasme.com/techshack.weekly/verses/f3c7a6dd-8789-4cb3-b8d2-f8aca870087e.html" rel="alternate"></link><published>2018-11-06T00:00:00+00:00</published><updated>2018-11-06T00:00:00+00:00</updated><author><name>Ju Lin</name></author><id>tag:www.soasme.com,2018-11-06:/techshack.weekly/verses/f3c7a6dd-8789-4cb3-b8d2-f8aca870087e.html</id><summary type="html">&lt;p&gt;&lt;a href="https://dev.to/brpaz/how-do-i-organize-my-knowledge-as-a-software-engineer-4387"&gt;查看原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文介绍了一些学习相关的应用。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Notion 可以做笔记整理&lt;/li&gt;
&lt;li&gt;Pocket 用来做阅读清单&lt;/li&gt;
&lt;li&gt;SnippetStore 代码管理&lt;/li&gt;
&lt;li&gt;Devhints 查小抄&lt;/li&gt;
&lt;/ul&gt;</summary><content type="html">&lt;p&gt;&lt;a href="https://dev.to/brpaz/how-do-i-organize-my-knowledge-as-a-software-engineer-4387"&gt;查看原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文介绍了一些学习相关的应用。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Notion 可以做笔记整理&lt;/li&gt;
&lt;li&gt;Pocket 用来做阅读清单&lt;/li&gt;
&lt;li&gt;SnippetStore 代码管理&lt;/li&gt;
&lt;li&gt;Devhints 查小抄&lt;/li&gt;
&lt;/ul&gt;</content></entry><entry><title>Dropbox Traffic Infrastructure Edge Network</title><link href="https://www.soasme.com/techshack.weekly/verses/06cc1edc-9709-4d19-996f-a94c94f09811.html" rel="alternate"></link><published>2018-10-18T00:00:00+00:00</published><updated>2018-10-18T00:00:00+00:00</updated><author><name>Ju Lin</name></author><id>tag:www.soasme.com,2018-10-18:/techshack.weekly/verses/06cc1edc-9709-4d19-996f-a94c94f09811.html</id><summary type="html">&lt;p&gt;&lt;a href="https://blogs.dropbox.com/tech/2018/10/dropbox-traffic-infrastructure-edge-network/"&gt;查看原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文介绍了 Dropbox 的 Edge 网络层的设计，涉及 GSLB，RUM DNS，L4 负载均衡，Nginx 配置，以及一些 gRPC 代理。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Dropbox 的数据量级不小，注册用户数大约五亿: 这意味着网络流量和请求数量也非常大。&lt;/li&gt;
&lt;li&gt;Edge 是 Dropbox 构建的 points of presence （PoP）。如下图，Edge 可以在离用户更近的地方处理连接，然后再连到服务器处理，虽然增加了一个 RTT，但是响应时间减半。
&lt;img alt="" src="https://dropboxtechblog.files.wordpress.com/2018/10/02-03-screenshot2018-10-0422-29-22.png?w=650&amp;amp;h=161"&gt;&lt;/li&gt;
&lt;li&gt;PoP 的地点选取很讲究，有人为选定，也有算法辅助。&lt;/li&gt;
&lt;li&gt;GSLB 是 Edge 负责负载均衡的算法。BGP anycast 是最简单的 BGP 负载均衡方法，但有时候性能不太好 …&lt;/li&gt;&lt;/ul&gt;</summary><content type="html">&lt;p&gt;&lt;a href="https://blogs.dropbox.com/tech/2018/10/dropbox-traffic-infrastructure-edge-network/"&gt;查看原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文介绍了 Dropbox 的 Edge 网络层的设计，涉及 GSLB，RUM DNS，L4 负载均衡，Nginx 配置，以及一些 gRPC 代理。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Dropbox 的数据量级不小，注册用户数大约五亿: 这意味着网络流量和请求数量也非常大。&lt;/li&gt;
&lt;li&gt;Edge 是 Dropbox 构建的 points of presence （PoP）。如下图，Edge 可以在离用户更近的地方处理连接，然后再连到服务器处理，虽然增加了一个 RTT，但是响应时间减半。
&lt;img alt="" src="https://dropboxtechblog.files.wordpress.com/2018/10/02-03-screenshot2018-10-0422-29-22.png?w=650&amp;amp;h=161"&gt;&lt;/li&gt;
&lt;li&gt;PoP 的地点选取很讲究，有人为选定，也有算法辅助。&lt;/li&gt;
&lt;li&gt;GSLB 是 Edge 负责负载均衡的算法。BGP anycast 是最简单的 BGP 负载均衡方法，但有时候性能不太好。&lt;/li&gt;
&lt;li&gt;dropbox.com APEX 域名使用 anycast 作为 fallback 方案。一旦 www 遭到了 DDOS，可以用 anycast 扛。&lt;/li&gt;
&lt;li&gt;PoP 是一些网络设备和 Linux Servers，以及一些 Nginx boxes 当作 L7，L4 的负载均衡，IPVS 作为 dataplane，选用 IP-in-IP encapsulation for DSR。&lt;/li&gt;
&lt;li&gt;Nginx 处理 HTTP，HTTP/2，gRPC 连接。&lt;/li&gt;
&lt;/ul&gt;</content></entry><entry><title>A Bitter Guide To Open Source</title><link href="https://www.soasme.com/techshack.weekly/verses/2e9e1a08-7e46-47f3-9995-4d456af3ac5e.html" rel="alternate"></link><published>2018-10-18T00:00:00+00:00</published><updated>2018-10-18T00:00:00+00:00</updated><author><name>Ju Lin</name></author><id>tag:www.soasme.com,2018-10-18:/techshack.weekly/verses/2e9e1a08-7e46-47f3-9995-4d456af3ac5e.html</id><summary type="html">&lt;p&gt;&lt;a href="https://medium.com/codezillas/a-bitter-guide-to-open-source-a8e3b6a3c1c4"&gt;查看原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文是开源的入门贴。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;为什么开源：学习，成长，回馈社区，找工作可能加分，等等。&lt;/li&gt;
&lt;li&gt;如何开始：遇到了问题，有一个解决办法，把解决办法用漂亮的 API 封装好让别人可以用。Just do it。&lt;/li&gt;
&lt;li&gt;准备发布：写文档，写测试，写类型，准备 README，CONTRIBUTING，LICENSE，metadata&lt;/li&gt;
&lt;li&gt;发布：掐好大家搭车或者饭点发出去。&lt;/li&gt;
&lt;li&gt;维护：不管有没有人用，写了就要维护好，修修修 bug，做改进。不管嘲笑的人，做好自己的事情。小版本迭代改进。&lt;/li&gt;
&lt;/ul&gt;</summary><content type="html">&lt;p&gt;&lt;a href="https://medium.com/codezillas/a-bitter-guide-to-open-source-a8e3b6a3c1c4"&gt;查看原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文是开源的入门贴。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;为什么开源：学习，成长，回馈社区，找工作可能加分，等等。&lt;/li&gt;
&lt;li&gt;如何开始：遇到了问题，有一个解决办法，把解决办法用漂亮的 API 封装好让别人可以用。Just do it。&lt;/li&gt;
&lt;li&gt;准备发布：写文档，写测试，写类型，准备 README，CONTRIBUTING，LICENSE，metadata&lt;/li&gt;
&lt;li&gt;发布：掐好大家搭车或者饭点发出去。&lt;/li&gt;
&lt;li&gt;维护：不管有没有人用，写了就要维护好，修修修 bug，做改进。不管嘲笑的人，做好自己的事情。小版本迭代改进。&lt;/li&gt;
&lt;/ul&gt;</content></entry><entry><title>SQLite Database Authorization and ACL</title><link href="https://www.soasme.com/techshack.weekly/verses/d4e9ccf0-f4f8-40a6-abdf-e40ec224c5a6.html" rel="alternate"></link><published>2018-10-18T00:00:00+00:00</published><updated>2018-10-18T00:00:00+00:00</updated><author><name>Ju Lin</name></author><id>tag:www.soasme.com,2018-10-18:/techshack.weekly/verses/d4e9ccf0-f4f8-40a6-abdf-e40ec224c5a6.html</id><summary type="html">&lt;p&gt;&lt;a href="https://charlesleifer.com/blog/sqlite-database-authorization-and-access-control-with-python/"&gt;查看原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;SQLite 数据库也可以使用简单的 ACL，方法是通过 sqlite 内建的 &lt;code&gt;authorizer&lt;/code&gt;. SQLite 连接对象可以设置 authorizer 控制 sql 的操作是否可以通过: https://www.sqlite.org/c3ref/set_authorizer.html&lt;/p&gt;
&lt;p&gt;简单来说，这个 authorizer 方法可以接受几个设定的参数，你自己需要写哪些操作可以通过，哪些不可以。例如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;sqlite3&lt;/span&gt;

&lt;span class="n"&gt;db&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;sqlite3&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;connect&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;/tmp/auth-demo.db&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;authorizer&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;action&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;arg1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;arg2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;db_name&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;trigger_name&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;action&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;SQLITE_DELETE&lt;/span&gt; &lt;span class="ow"&gt;and&lt;/span&gt; &lt;span class="n"&gt;arg1&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;users&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="k"&gt;return …&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</summary><content type="html">&lt;p&gt;&lt;a href="https://charlesleifer.com/blog/sqlite-database-authorization-and-access-control-with-python/"&gt;查看原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;SQLite 数据库也可以使用简单的 ACL，方法是通过 sqlite 内建的 &lt;code&gt;authorizer&lt;/code&gt;. SQLite 连接对象可以设置 authorizer 控制 sql 的操作是否可以通过: https://www.sqlite.org/c3ref/set_authorizer.html&lt;/p&gt;
&lt;p&gt;简单来说，这个 authorizer 方法可以接受几个设定的参数，你自己需要写哪些操作可以通过，哪些不可以。例如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;sqlite3&lt;/span&gt;

&lt;span class="n"&gt;db&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;sqlite3&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;connect&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;/tmp/auth-demo.db&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;authorizer&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;action&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;arg1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;arg2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;db_name&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;trigger_name&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;action&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;SQLITE_DELETE&lt;/span&gt; &lt;span class="ow"&gt;and&lt;/span&gt; &lt;span class="n"&gt;arg1&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;users&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;SQLITE_DENY&lt;/span&gt;  &lt;span class="c1"&gt;# 1&lt;/span&gt;
    &lt;span class="k"&gt;elif&lt;/span&gt; &lt;span class="n"&gt;action&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;SQLITE_READ&lt;/span&gt; &lt;span class="ow"&gt;and&lt;/span&gt; &lt;span class="n"&gt;arg1&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;users&amp;#39;&lt;/span&gt; &lt;span class="ow"&gt;and&lt;/span&gt; &lt;span class="n"&gt;arg2&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;password&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;SQLITE_IGNORE&lt;/span&gt;  &lt;span class="c1"&gt;# 2&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;SQLITE_OK&lt;/span&gt;  &lt;span class="c1"&gt;# 0&lt;/span&gt;

&lt;span class="n"&gt;db&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;set_authorizer&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;authorizer&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="n"&gt;cursor&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;db&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;execute&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;SELECT * FROM users;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;username&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;password&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;cursor&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;fetchall&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
    &lt;span class="nb"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;username&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;password&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  &lt;span class="c1"&gt;# Password will be None (NULL)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</content></entry><entry><title>Alternative code styles</title><link href="https://www.soasme.com/techshack.weekly/verses/40dba745-f975-49dd-b47a-bf72b7170660.html" rel="alternate"></link><published>2018-10-16T00:00:00+00:00</published><updated>2018-10-16T00:00:00+00:00</updated><author><name>Ju Lin</name></author><id>tag:www.soasme.com,2018-10-16:/techshack.weekly/verses/40dba745-f975-49dd-b47a-bf72b7170660.html</id><summary type="html">&lt;p&gt;&lt;a href="https://swalladge.id.au/archives/2018/10/15/alternative-code-styles/"&gt;查看原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文介绍了一些奇怪的 code styles：C macros(C代码往脚本语言方向走)，代码居中，fib identation(可以避免写太多嵌套）, braces 放到最后把语言往 Python 缩进的样式走。&lt;/p&gt;</summary><content type="html">&lt;p&gt;&lt;a href="https://swalladge.id.au/archives/2018/10/15/alternative-code-styles/"&gt;查看原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文介绍了一些奇怪的 code styles：C macros(C代码往脚本语言方向走)，代码居中，fib identation(可以避免写太多嵌套）, braces 放到最后把语言往 Python 缩进的样式走。&lt;/p&gt;</content></entry><entry><title>How to manage connections efficiently in any database</title><link href="https://www.soasme.com/techshack.weekly/verses/ea1b1bb9-f044-42d5-b372-372bbe7da598.html" rel="alternate"></link><published>2018-10-16T00:00:00+00:00</published><updated>2018-10-16T00:00:00+00:00</updated><author><name>Ju Lin</name></author><id>tag:www.soasme.com,2018-10-16:/techshack.weekly/verses/ea1b1bb9-f044-42d5-b372-372bbe7da598.html</id><summary type="html">&lt;p&gt;&lt;a href="https://brandur.org/postgres-connections"&gt;查看原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文讨论了如何高效管理数据库连接。下图是 Postgres 的 forking 进程模型，瓶颈在共享内存那块。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://brandur.org/assets/postgres-connections/process-model.svg"&gt;&lt;/p&gt;
&lt;p&gt;优化方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;connection pools: 在每个节点都保存一个内存池，workers 从内存池拿连接，而内存池只需要向 master 维持一个连接。缺点是一旦遇上使用 unicorn/puma 这类 forking servers，程序就不是单进程了，内存池就没那么有效。
&lt;img alt="" src="https://brandur.org/assets/postgres-connections/connection-pooling.svg"&gt;&lt;/li&gt;
&lt;li&gt;minimum viable checkouts: workers 只在必要的时候占用连接池，像 decoding，validating， rate limiting 这些事情就别占用连接时间了。
&lt;img alt="" src="https://brandur.org/assets/postgres-connections/minimum-viable-checkout.svg"&gt;&lt;/li&gt;
&lt;li&gt;PgBouncer &amp;amp; inter-node pooling: 如果连接还是太多了，可以考虑在数据库前面再放一层 proxy，让 proxy 处理这些连接，给后端数据库减负担。
&lt;img alt="" src="https://brandur.org/assets/postgres-connections/pgbouncer.svg"&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;结论：连接即是资源（connection as …&lt;/p&gt;</summary><content type="html">&lt;p&gt;&lt;a href="https://brandur.org/postgres-connections"&gt;查看原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文讨论了如何高效管理数据库连接。下图是 Postgres 的 forking 进程模型，瓶颈在共享内存那块。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://brandur.org/assets/postgres-connections/process-model.svg"&gt;&lt;/p&gt;
&lt;p&gt;优化方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;connection pools: 在每个节点都保存一个内存池，workers 从内存池拿连接，而内存池只需要向 master 维持一个连接。缺点是一旦遇上使用 unicorn/puma 这类 forking servers，程序就不是单进程了，内存池就没那么有效。
&lt;img alt="" src="https://brandur.org/assets/postgres-connections/connection-pooling.svg"&gt;&lt;/li&gt;
&lt;li&gt;minimum viable checkouts: workers 只在必要的时候占用连接池，像 decoding，validating， rate limiting 这些事情就别占用连接时间了。
&lt;img alt="" src="https://brandur.org/assets/postgres-connections/minimum-viable-checkout.svg"&gt;&lt;/li&gt;
&lt;li&gt;PgBouncer &amp;amp; inter-node pooling: 如果连接还是太多了，可以考虑在数据库前面再放一层 proxy，让 proxy 处理这些连接，给后端数据库减负担。
&lt;img alt="" src="https://brandur.org/assets/postgres-connections/pgbouncer.svg"&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;结论：连接即是资源（connection as a resource），程序不能无休止地消耗资源。开发者要清楚每个节点用了多少连接 M ，一共有多少个节点 N， 你的数据库 max_connections 能不能承受 MxN 个连接？如果不能，就得去做上面的优化。如果能，考虑下 graceful restart 时的特殊 case，那时候，连接理论上最差情况会翻倍哟！&lt;/p&gt;</content></entry><entry><title>Subversion Delta Editor - Beautiful Code Chapter 2</title><link href="https://www.soasme.com/techshack.weekly/verses/152b7f16-863d-4f8a-9358-da664c75f834.html" rel="alternate"></link><published>2018-10-13T00:00:00+00:00</published><updated>2018-10-13T00:00:00+00:00</updated><author><name>Ju Lin</name></author><id>tag:www.soasme.com,2018-10-13:/techshack.weekly/verses/152b7f16-863d-4f8a-9358-da664c75f834.html</id><summary type="html">&lt;p&gt;&lt;a href="https://www.red-bean.com/kfogel/beautiful-code/bc-chapter-02.html"&gt;查看原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文论述的核心是讨论 svn delta editor 接口的美。&lt;/p&gt;
&lt;p&gt;背景：通过两文件的仓库 /A/fish/tuna/FILE， /B/ 的图表描述版本控制，树的变型。
过渡：tree diff 该如何表达呢？开始讨论挑战在哪里。
正篇：概念介绍，贴出源码，就上面的例子给出源码实际执行的序列，带来的好处。
结论：好处的综述：简化开发，快速适配新功能。&lt;/p&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;svn_delta_editor_t&lt;/code&gt; 这个 struct 中定义了关于表达 tree diff 的核心操作接口，主要在于把树的深度优先遍历和&lt;code&gt;apply_textdelta&lt;/code&gt;分拆出来。&lt;/li&gt;
&lt;li&gt;有趣的是，文中提到了一个废弃的老接口，它视图解决 X 问题，后来的开发者们尝试用它来解决 Y 问题但是并不太顺利，所以就变成了一个废弃的接口。尽管如此，原来的设计依然很漂亮 …&lt;/li&gt;&lt;/ul&gt;</summary><content type="html">&lt;p&gt;&lt;a href="https://www.red-bean.com/kfogel/beautiful-code/bc-chapter-02.html"&gt;查看原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文论述的核心是讨论 svn delta editor 接口的美。&lt;/p&gt;
&lt;p&gt;背景：通过两文件的仓库 /A/fish/tuna/FILE， /B/ 的图表描述版本控制，树的变型。
过渡：tree diff 该如何表达呢？开始讨论挑战在哪里。
正篇：概念介绍，贴出源码，就上面的例子给出源码实际执行的序列，带来的好处。
结论：好处的综述：简化开发，快速适配新功能。&lt;/p&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;svn_delta_editor_t&lt;/code&gt; 这个 struct 中定义了关于表达 tree diff 的核心操作接口，主要在于把树的深度优先遍历和&lt;code&gt;apply_textdelta&lt;/code&gt;分拆出来。&lt;/li&gt;
&lt;li&gt;有趣的是，文中提到了一个废弃的老接口，它视图解决 X 问题，后来的开发者们尝试用它来解决 Y 问题但是并不太顺利，所以就变成了一个废弃的接口。尽管如此，原来的设计依然很漂亮，只是，不太 fit 新出现的问题。&lt;/li&gt;
&lt;/ul&gt;</content></entry><entry><title>How to create an OS from scratch</title><link href="https://www.soasme.com/techshack.weekly/verses/185ea9b2-0d34-4be8-8e63-82a47eb84a84.html" rel="alternate"></link><published>2018-10-10T00:00:00+00:00</published><updated>2018-10-10T00:00:00+00:00</updated><author><name>Ju Lin</name></author><id>tag:www.soasme.com,2018-10-10:/techshack.weekly/verses/185ea9b2-0d34-4be8-8e63-82a47eb84a84.html</id><summary type="html">&lt;p&gt;&lt;a href="https://github.com/cfenollosa/os-tutorial"&gt;查看原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这个小仓库介绍了如何从头写一个 OS，很适合想通过 get hands dirty 的人深入学习 OS。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Mac 用户需要准备 qemu, nasm (brew install)&lt;/li&gt;
&lt;li&gt;可以通过 nasm 编译汇编代码&lt;/li&gt;
&lt;li&gt;可以通过 qemu 启动镜像&lt;/li&gt;
&lt;/ul&gt;</summary><content type="html">&lt;p&gt;&lt;a href="https://github.com/cfenollosa/os-tutorial"&gt;查看原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这个小仓库介绍了如何从头写一个 OS，很适合想通过 get hands dirty 的人深入学习 OS。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Mac 用户需要准备 qemu, nasm (brew install)&lt;/li&gt;
&lt;li&gt;可以通过 nasm 编译汇编代码&lt;/li&gt;
&lt;li&gt;可以通过 qemu 启动镜像&lt;/li&gt;
&lt;/ul&gt;</content></entry><entry><title>Kubernetes for small projects</title><link href="https://www.soasme.com/techshack.weekly/verses/55f3b26a-1554-4b27-b8a7-6afc9a4e7871.html" rel="alternate"></link><published>2018-10-10T00:00:00+00:00</published><updated>2018-10-10T00:00:00+00:00</updated><author><name>Ju Lin</name></author><id>tag:www.soasme.com,2018-10-10:/techshack.weekly/verses/55f3b26a-1554-4b27-b8a7-6afc9a4e7871.html</id><summary type="html">&lt;p&gt;&lt;a href="https://carlosrdrz.es/kubernetes-for-small-projects/"&gt;查看原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文是 &lt;a href="https://www.doxsey.net/blog/kubernetes--the-surprisingly-affordable-platform-for-personal-projects"&gt;这篇文章&lt;/a&gt; 的驳文，前文认为 k8s 适合小项目，本文作者则认为不合适。软件工程很讲究 trade-off 的艺术.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;rsync 到服务器怎么了，不好吗，它能用啊。&lt;/li&gt;
&lt;li&gt;软件依赖很多怎么了，ansible playbook 运行的很好啊&lt;/li&gt;
&lt;li&gt;systemd 怎么了，蛮好用的呀。&lt;/li&gt;
&lt;li&gt;nginx virtual host 设计也不难啊，比起 k8s daemon set。&lt;/li&gt;
&lt;li&gt;zero-downtime 其实是个伪需求吧，至少对于很多项目来说。&lt;/li&gt;
&lt;li&gt;回滚？部署一遍老版本就好了啦。&lt;/li&gt;
&lt;li&gt;那些 redis 七七八八的服务怎么配？就用上游 distro 的安装包外加配置文件，在适当的时间点可以挪进 ansible。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;作者认为一个月付 5 刀的小项目，去考虑 infra 为时尚早了（除非你更想鼓捣那些东西另说 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;&lt;a href="https://carlosrdrz.es/kubernetes-for-small-projects/"&gt;查看原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文是 &lt;a href="https://www.doxsey.net/blog/kubernetes--the-surprisingly-affordable-platform-for-personal-projects"&gt;这篇文章&lt;/a&gt; 的驳文，前文认为 k8s 适合小项目，本文作者则认为不合适。软件工程很讲究 trade-off 的艺术.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;rsync 到服务器怎么了，不好吗，它能用啊。&lt;/li&gt;
&lt;li&gt;软件依赖很多怎么了，ansible playbook 运行的很好啊&lt;/li&gt;
&lt;li&gt;systemd 怎么了，蛮好用的呀。&lt;/li&gt;
&lt;li&gt;nginx virtual host 设计也不难啊，比起 k8s daemon set。&lt;/li&gt;
&lt;li&gt;zero-downtime 其实是个伪需求吧，至少对于很多项目来说。&lt;/li&gt;
&lt;li&gt;回滚？部署一遍老版本就好了啦。&lt;/li&gt;
&lt;li&gt;那些 redis 七七八八的服务怎么配？就用上游 distro 的安装包外加配置文件，在适当的时间点可以挪进 ansible。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;作者认为一个月付 5 刀的小项目，去考虑 infra 为时尚早了（除非你更想鼓捣那些东西另说）。&lt;/p&gt;</content></entry><entry><title>Artifact Introduction</title><link href="https://www.soasme.com/techshack.weekly/verses/cb605c66-05e4-47d2-89e7-20da15052638.html" rel="alternate"></link><published>2018-10-10T00:00:00+00:00</published><updated>2018-10-10T00:00:00+00:00</updated><author><name>Ju Lin</name></author><id>tag:www.soasme.com,2018-10-10:/techshack.weekly/verses/cb605c66-05e4-47d2-89e7-20da15052638.html</id><summary type="html">&lt;p&gt;&lt;a href="https://vitiral.github.io/artifact/docs/Introduction.html"&gt;查看原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Artifact 是一个设计的文档工具，虽然适用于设计，但是也可以窥见很多软件工程的思路。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;设计是结果导向的，一般先设计出样子，再慢慢推进。&lt;/li&gt;
&lt;li&gt;领域模型是一种叫做 &lt;code&gt;artifacts&lt;/code&gt; 的对象，有 name，text，可以连接到其他 artifacts 和源代码。&lt;/li&gt;
&lt;li&gt;有三种 artifacts: REQ(需求），SPC(规约), TST(测试)。例如，下面的示例文档：&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="o"&gt;#&lt;/span&gt; &lt;span class="n"&gt;REQ&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;
&lt;span class="n"&gt;partof&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;REQ&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;other&lt;/span&gt;
&lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;REQ&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;foo&lt;/span&gt;
&lt;span class="n"&gt;done&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;This&lt;/span&gt; &lt;span class="n"&gt;artifact&lt;/span&gt; &lt;span class="k"&gt;is&lt;/span&gt; &lt;span class="ss"&gt;&amp;quot;defined as done&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;
&lt;span class="o"&gt;###&lt;/span&gt;
&lt;span class="n"&gt;The&lt;/span&gt; &lt;span class="n"&gt;description&lt;/span&gt; &lt;span class="k"&gt;of&lt;/span&gt; &lt;span class="n"&gt;the&lt;/span&gt; &lt;span class="n"&gt;artifact&lt;/span&gt; &lt;span class="n"&gt;goes&lt;/span&gt; &lt;span class="n"&gt;here&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;

&lt;span class="n"&gt;You&lt;/span&gt; &lt;span class="n"&gt;can …&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</summary><content type="html">&lt;p&gt;&lt;a href="https://vitiral.github.io/artifact/docs/Introduction.html"&gt;查看原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Artifact 是一个设计的文档工具，虽然适用于设计，但是也可以窥见很多软件工程的思路。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;设计是结果导向的，一般先设计出样子，再慢慢推进。&lt;/li&gt;
&lt;li&gt;领域模型是一种叫做 &lt;code&gt;artifacts&lt;/code&gt; 的对象，有 name，text，可以连接到其他 artifacts 和源代码。&lt;/li&gt;
&lt;li&gt;有三种 artifacts: REQ(需求），SPC(规约), TST(测试)。例如，下面的示例文档：&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="o"&gt;#&lt;/span&gt; &lt;span class="n"&gt;REQ&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;
&lt;span class="n"&gt;partof&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;REQ&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;other&lt;/span&gt;
&lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;REQ&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;foo&lt;/span&gt;
&lt;span class="n"&gt;done&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;This&lt;/span&gt; &lt;span class="n"&gt;artifact&lt;/span&gt; &lt;span class="k"&gt;is&lt;/span&gt; &lt;span class="ss"&gt;&amp;quot;defined as done&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;
&lt;span class="o"&gt;###&lt;/span&gt;
&lt;span class="n"&gt;The&lt;/span&gt; &lt;span class="n"&gt;description&lt;/span&gt; &lt;span class="k"&gt;of&lt;/span&gt; &lt;span class="n"&gt;the&lt;/span&gt; &lt;span class="n"&gt;artifact&lt;/span&gt; &lt;span class="n"&gt;goes&lt;/span&gt; &lt;span class="n"&gt;here&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;

&lt;span class="n"&gt;You&lt;/span&gt; &lt;span class="n"&gt;can&lt;/span&gt; &lt;span class="k"&gt;do&lt;/span&gt; &lt;span class="n"&gt;soft&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;links&lt;/span&gt; &lt;span class="k"&gt;to&lt;/span&gt; &lt;span class="n"&gt;other&lt;/span&gt; &lt;span class="n"&gt;artifacts&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="p"&gt;[[&lt;/span&gt;&lt;span class="n"&gt;REQ&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;something&lt;/span&gt;&lt;span class="p"&gt;]]:&lt;/span&gt; &lt;span class="n"&gt;The&lt;/span&gt; &lt;span class="n"&gt;web&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;ui&lt;/span&gt; &lt;span class="n"&gt;will&lt;/span&gt; &lt;span class="n"&gt;have&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;link&lt;/span&gt; &lt;span class="k"&gt;to&lt;/span&gt; &lt;span class="n"&gt;REQ&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;something&lt;/span&gt; &lt;span class="k"&gt;and&lt;/span&gt; &lt;span class="o"&gt;`&lt;/span&gt;&lt;span class="n"&gt;art&lt;/span&gt;
  &lt;span class="k"&gt;check&lt;/span&gt;&lt;span class="o"&gt;`&lt;/span&gt; &lt;span class="n"&gt;will&lt;/span&gt; &lt;span class="n"&gt;make&lt;/span&gt; &lt;span class="n"&gt;sure&lt;/span&gt; &lt;span class="n"&gt;it&lt;/span&gt; &lt;span class="k"&gt;exists&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</content></entry><entry><title>Goroutines vs Java Threads</title><link href="https://www.soasme.com/techshack.weekly/verses/d0ee9444-b992-43eb-898b-5913ea866879.html" rel="alternate"></link><published>2018-10-10T00:00:00+00:00</published><updated>2018-10-10T00:00:00+00:00</updated><author><name>Ju Lin</name></author><id>tag:www.soasme.com,2018-10-10:/techshack.weekly/verses/d0ee9444-b992-43eb-898b-5913ea866879.html</id><summary type="html">&lt;p&gt;&lt;a href="https://rcoh.me/posts/why-you-can-have-a-million-go-routines-but-only-1000-java-threads/"&gt;查看原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文谈论了为何在一台机器上可以有百万个 Goroutines 而只能有千量级的 Threads.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Threads 的运行需要两个东西：指令 pc 用来表示运行到了代码的哪里，以及 stack 用来维护局部变量和到堆上的指针变量。所有 Threasd 共享一个 Heap。&lt;/li&gt;
&lt;li&gt;几乎所有的 JVM 实现都依赖 OS threads 来实现语言的 Thread。所以操作系统能搞出的上限，Java 只会少不会多。&lt;/li&gt;
&lt;li&gt;假设 JVM per thread 能用 1MB stack，那 1GB 内存只能产生 1k Threads。&lt;/li&gt;
&lt;li&gt;Go 使用 Dynamically Sized Stacks。每个 stack 只消耗 4kb，所以 1GB …&lt;/li&gt;&lt;/ul&gt;</summary><content type="html">&lt;p&gt;&lt;a href="https://rcoh.me/posts/why-you-can-have-a-million-go-routines-but-only-1000-java-threads/"&gt;查看原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文谈论了为何在一台机器上可以有百万个 Goroutines 而只能有千量级的 Threads.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Threads 的运行需要两个东西：指令 pc 用来表示运行到了代码的哪里，以及 stack 用来维护局部变量和到堆上的指针变量。所有 Threasd 共享一个 Heap。&lt;/li&gt;
&lt;li&gt;几乎所有的 JVM 实现都依赖 OS threads 来实现语言的 Thread。所以操作系统能搞出的上限，Java 只会少不会多。&lt;/li&gt;
&lt;li&gt;假设 JVM per thread 能用 1MB stack，那 1GB 内存只能产生 1k Threads。&lt;/li&gt;
&lt;li&gt;Go 使用 Dynamically Sized Stacks。每个 stack 只消耗 4kb，所以 1GB 可以产生 250 万个 goroutines。&lt;/li&gt;
&lt;li&gt;同时，JVM 需要依赖 OS 调度 Threads，大约 1 核 CPU 能运行 100k threads 一秒，这还是理论上限。&lt;/li&gt;
&lt;li&gt;Go 单次切换不像 Java 那样要到 us 级别，只需要 100 nanoseconds 就能切换好。&lt;/li&gt;
&lt;li&gt;^ 同理，Java 系的 Akka 框架使用类似技术，也能做到百万 Actors。&lt;/li&gt;
&lt;/ul&gt;</content></entry><entry><title>k8s 配置最佳实践</title><link href="https://www.soasme.com/techshack.weekly/verses/f13951b8-a0ea-4816-9b05-97c40120615c.html" rel="alternate"></link><published>2018-10-10T00:00:00+00:00</published><updated>2018-10-10T00:00:00+00:00</updated><author><name>Ju Lin</name></author><id>tag:www.soasme.com,2018-10-10:/techshack.weekly/verses/f13951b8-a0ea-4816-9b05-97c40120615c.html</id><summary type="html">&lt;p&gt;&lt;a href="https://kubernetes.io/docs/concepts/configuration/overview/"&gt;查看原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文是 kubernetes Configuration Best Practices。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;总之指定最近的 stable api version&lt;/li&gt;
&lt;li&gt;用 yaml&lt;/li&gt;
&lt;li&gt;把相关的对象放到单一的一个文件。&lt;/li&gt;
&lt;li&gt;没事不需要指定默认值，越多代码越容易引发错误。&lt;/li&gt;
&lt;li&gt;把描述放进 annotations 方便后面追查。&lt;/li&gt;
&lt;li&gt;不用 Naked Pods，尽可能用 ReplicaSet 或者 Deployment。&lt;/li&gt;
&lt;li&gt;创建 service 最早在 deployments/replicaset 之前操作。&lt;/li&gt;
&lt;li&gt;用 dns name of service 替代环境变量。&lt;/li&gt;
&lt;li&gt;debug 的时候用 kubectl port-forward 或者 apiserver proxy&lt;/li&gt;
&lt;li&gt;用好标签，例如 app 是什么，tier 是哪层 …&lt;/li&gt;&lt;/ul&gt;</summary><content type="html">&lt;p&gt;&lt;a href="https://kubernetes.io/docs/concepts/configuration/overview/"&gt;查看原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文是 kubernetes Configuration Best Practices。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;总之指定最近的 stable api version&lt;/li&gt;
&lt;li&gt;用 yaml&lt;/li&gt;
&lt;li&gt;把相关的对象放到单一的一个文件。&lt;/li&gt;
&lt;li&gt;没事不需要指定默认值，越多代码越容易引发错误。&lt;/li&gt;
&lt;li&gt;把描述放进 annotations 方便后面追查。&lt;/li&gt;
&lt;li&gt;不用 Naked Pods，尽可能用 ReplicaSet 或者 Deployment。&lt;/li&gt;
&lt;li&gt;创建 service 最早在 deployments/replicaset 之前操作。&lt;/li&gt;
&lt;li&gt;用 dns name of service 替代环境变量。&lt;/li&gt;
&lt;li&gt;debug 的时候用 kubectl port-forward 或者 apiserver proxy&lt;/li&gt;
&lt;li&gt;用好标签，例如 app 是什么，tier 是哪层，deployment 是哪个版本等等。因为 service 可以根据 labels 转流量过去。&lt;/li&gt;
&lt;/ul&gt;</content></entry><entry><title>使用 audio 数据产生 true entropy</title><link href="https://www.soasme.com/techshack.weekly/verses/0fb977a1-c2bf-400f-8b99-c6865fae8e24.html" rel="alternate"></link><published>2018-10-03T00:00:00+00:00</published><updated>2018-10-03T00:00:00+00:00</updated><author><name>Ju Lin</name></author><id>tag:www.soasme.com,2018-10-03:/techshack.weekly/verses/0fb977a1-c2bf-400f-8b99-c6865fae8e24.html</id><summary type="html">&lt;p&gt;&lt;a href="https://josephbasquin.fr/audiorandomness"&gt;查看原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文介绍了一个脑洞，使用电脑的话筒录声音，可能附近空调或者键盘打字的背景噪音会被录进去，用算法规整化+shuffle后可以得到 true random data（不是伪随机数，是真的随机数）。让我们希望这个软件不要运行在敲木鱼的和尚旁边。&lt;/p&gt;</summary><content type="html">&lt;p&gt;&lt;a href="https://josephbasquin.fr/audiorandomness"&gt;查看原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文介绍了一个脑洞，使用电脑的话筒录声音，可能附近空调或者键盘打字的背景噪音会被录进去，用算法规整化+shuffle后可以得到 true random data（不是伪随机数，是真的随机数）。让我们希望这个软件不要运行在敲木鱼的和尚旁边。&lt;/p&gt;</content></entry><entry><title>GitHub - Natural Language Semantic Code Search</title><link href="https://www.soasme.com/techshack.weekly/verses/228dd23b-bd82-48fe-a705-4adf63fd2c3c.html" rel="alternate"></link><published>2018-10-03T00:00:00+00:00</published><updated>2018-10-03T00:00:00+00:00</updated><author><name>Ju Lin</name></author><id>tag:www.soasme.com,2018-10-03:/techshack.weekly/verses/228dd23b-bd82-48fe-a705-4adf63fd2c3c.html</id><summary type="html">&lt;p&gt;&lt;a href="https://githubengineering.com/towards-natural-language-semantic-code-search/"&gt;查看原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文介绍了 GitHub 工程团队的一个脑洞 - 使用自然语言搜索代码：https://experiments.github.com/semantic-code-search&lt;/p&gt;
&lt;p&gt;目前它还只能搜索一些简单的 Python 相关的函数和方法。底层原理是&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;搜索的词经过 Text Encoder 算出一个向量, 基于 fast.ai 库封装。&lt;/li&gt;
&lt;li&gt;仓库里的代码经过 Code Encoder 也算出一个向量, 使用了 sequence-to-sequence model / tree-based LSTMs / gated-graph networks 等算法。&lt;/li&gt;
&lt;li&gt;比较向量的相关性，给出列表。&lt;/li&gt;
&lt;/ul&gt;</summary><content type="html">&lt;p&gt;&lt;a href="https://githubengineering.com/towards-natural-language-semantic-code-search/"&gt;查看原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文介绍了 GitHub 工程团队的一个脑洞 - 使用自然语言搜索代码：https://experiments.github.com/semantic-code-search&lt;/p&gt;
&lt;p&gt;目前它还只能搜索一些简单的 Python 相关的函数和方法。底层原理是&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;搜索的词经过 Text Encoder 算出一个向量, 基于 fast.ai 库封装。&lt;/li&gt;
&lt;li&gt;仓库里的代码经过 Code Encoder 也算出一个向量, 使用了 sequence-to-sequence model / tree-based LSTMs / gated-graph networks 等算法。&lt;/li&gt;
&lt;li&gt;比较向量的相关性，给出列表。&lt;/li&gt;
&lt;/ul&gt;</content></entry><entry><title>Rocky River Pattern</title><link href="https://www.soasme.com/techshack.weekly/verses/5cbedb53-2769-4b0b-98ca-6ae0c9d0eabd.html" rel="alternate"></link><published>2018-10-03T00:00:00+00:00</published><updated>2018-10-03T00:00:00+00:00</updated><author><name>Ju Lin</name></author><id>tag:www.soasme.com,2018-10-03:/techshack.weekly/verses/5cbedb53-2769-4b0b-98ca-6ae0c9d0eabd.html</id><summary type="html">&lt;p&gt;&lt;a href="http://seddonym.me/2018/09/16/rocky-river-pattern/"&gt;查看原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文提出了一个编程范式：Rocky River。形同小河布满石头，软件也有上游下游，数据流经中间各个模块。&lt;/p&gt;
&lt;p&gt;Rocky River 要求：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;模块要小，容易被整合成一个大程序。&lt;/li&gt;
&lt;li&gt;程序变大后可以搞成二级的，三级的结构。&lt;/li&gt;
&lt;li&gt;使用分层架构，只有上层可以调用下层，不能有循环依赖。&lt;/li&gt;
&lt;/ul&gt;</summary><content type="html">&lt;p&gt;&lt;a href="http://seddonym.me/2018/09/16/rocky-river-pattern/"&gt;查看原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文提出了一个编程范式：Rocky River。形同小河布满石头，软件也有上游下游，数据流经中间各个模块。&lt;/p&gt;
&lt;p&gt;Rocky River 要求：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;模块要小，容易被整合成一个大程序。&lt;/li&gt;
&lt;li&gt;程序变大后可以搞成二级的，三级的结构。&lt;/li&gt;
&lt;li&gt;使用分层架构，只有上层可以调用下层，不能有循环依赖。&lt;/li&gt;
&lt;/ul&gt;</content></entry><entry><title>Celery Task States</title><link href="https://www.soasme.com/techshack.weekly/verses/66872ca5-05d8-4ea6-a3f6-5f88566f69ea.html" rel="alternate"></link><published>2018-10-03T00:00:00+00:00</published><updated>2018-10-03T00:00:00+00:00</updated><author><name>Ju Lin</name></author><id>tag:www.soasme.com,2018-10-03:/techshack.weekly/verses/66872ca5-05d8-4ea6-a3f6-5f88566f69ea.html</id><summary type="html">&lt;p&gt;&lt;a href="https://www.distributedpython.com/2018/09/28/celery-task-states/"&gt;查看原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Celery Task 默认有 PENDING STARTED SUCCESS FAILURE RETRY REVOKED 这六种状态。可以通过 &lt;code&gt;task.update_state(state='YOUR-CUSTOM-STATE', meta={})&lt;/code&gt; 设置成自己想要的状态。这对于设置自定义的任务状态机很有用。&lt;/p&gt;</summary><content type="html">&lt;p&gt;&lt;a href="https://www.distributedpython.com/2018/09/28/celery-task-states/"&gt;查看原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Celery Task 默认有 PENDING STARTED SUCCESS FAILURE RETRY REVOKED 这六种状态。可以通过 &lt;code&gt;task.update_state(state='YOUR-CUSTOM-STATE', meta={})&lt;/code&gt; 设置成自己想要的状态。这对于设置自定义的任务状态机很有用。&lt;/p&gt;</content></entry><entry><title>Dropbox - The architecture of Nautilus</title><link href="https://www.soasme.com/techshack.weekly/verses/f40bef11-b6d1-4db9-99dd-2df1be24b5a8.html" rel="alternate"></link><published>2018-10-03T00:00:00+00:00</published><updated>2018-10-03T00:00:00+00:00</updated><author><name>Ju Lin</name></author><id>tag:www.soasme.com,2018-10-03:/techshack.weekly/verses/f40bef11-b6d1-4db9-99dd-2df1be24b5a8.html</id><summary type="html">&lt;p&gt;&lt;a href="https://blogs.dropbox.com/tech/2018/09/architecture-of-nautilus-the-new-dropbox-search-engine/"&gt;查看原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文介绍了 Dropbox 的搜索引擎：Nautilus。和 Web 搜索引擎不同，文件分享平台的搜索引擎设计需要处理的文档很多时候仅限某个个人用户可以查看，另外还需要追踪和更新文档的多个版本。系统设计的要求没别的，就是快点找到仅某个用户可以看到的文件，还有就是允许工程团队接入更多文件类型的流水线。架构图如下：&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://dropboxtechblog.files.wordpress.com/2018/09/01-screenshot2018-06-06at10-55-32am.png?w=650&amp;amp;h=475"&gt;&lt;/p&gt;</summary><content type="html">&lt;p&gt;&lt;a href="https://blogs.dropbox.com/tech/2018/09/architecture-of-nautilus-the-new-dropbox-search-engine/"&gt;查看原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文介绍了 Dropbox 的搜索引擎：Nautilus。和 Web 搜索引擎不同，文件分享平台的搜索引擎设计需要处理的文档很多时候仅限某个个人用户可以查看，另外还需要追踪和更新文档的多个版本。系统设计的要求没别的，就是快点找到仅某个用户可以看到的文件，还有就是允许工程团队接入更多文件类型的流水线。架构图如下：&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://dropboxtechblog.files.wordpress.com/2018/09/01-screenshot2018-06-06at10-55-32am.png?w=650&amp;amp;h=475"&gt;&lt;/p&gt;</content></entry><entry><title>Regex - Railroad Diagrams</title><link href="https://www.soasme.com/techshack.weekly/verses/4d63250a-4d25-4cc7-bcd5-86d48a913307.html" rel="alternate"></link><published>2018-10-02T00:00:00+00:00</published><updated>2018-10-02T00:00:00+00:00</updated><author><name>Ju Lin</name></author><id>tag:www.soasme.com,2018-10-02:/techshack.weekly/verses/4d63250a-4d25-4cc7-bcd5-86d48a913307.html</id><summary type="html">&lt;p&gt;&lt;a href="https://regexper.com/documentation.html"&gt;查看原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;https://regexper.com 这个网站通过铁轨图将复杂正则表达式的图形化，也非常适合新手学习正则表达式。&lt;/p&gt;</summary><content type="html">&lt;p&gt;&lt;a href="https://regexper.com/documentation.html"&gt;查看原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;https://regexper.com 这个网站通过铁轨图将复杂正则表达式的图形化，也非常适合新手学习正则表达式。&lt;/p&gt;</content></entry><entry><title>Some possible career goals</title><link href="https://www.soasme.com/techshack.weekly/verses/ea48344e-74f2-466f-99c6-33c2e88f2419.html" rel="alternate"></link><published>2018-10-02T00:00:00+00:00</published><updated>2018-10-02T00:00:00+00:00</updated><author><name>Ju Lin</name></author><id>tag:www.soasme.com,2018-10-02:/techshack.weekly/verses/ea48344e-74f2-466f-99c6-33c2e88f2419.html</id><summary type="html">&lt;p&gt;&lt;a href="https://jvns.ca/blog/2018/09/30/some-possible-career-goals/"&gt;查看原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文介绍了作为技术人，在技术，工作，产品，创业，沟通等方面的潜在目标，每个人追求各有不同，但本文覆盖了蛮多的选择。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;技术：成为领域专家 / 学习前沿技术 / 维护大项目 / 贡献开源项目 / 从头开始打造一个关键系统 / 理解复杂系统 / 快速造原型&lt;/li&gt;
&lt;li&gt;工作：大公司 / 小公司 / 走 manager 路线 / 走技术路线（architect，senior，principle。。。） / 参与知名公司的软件编写&lt;/li&gt;
&lt;li&gt;产品：打磨工具 / 写网站 / 内网工具 / 解决领域问题（例如天气）/ 开发者工具&lt;/li&gt;
&lt;li&gt;沟通：写书 / 做演讲 / 做周边 / 写博客&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;反正，每一种都能让技术人停不下来。&lt;/p&gt;</summary><content type="html">&lt;p&gt;&lt;a href="https://jvns.ca/blog/2018/09/30/some-possible-career-goals/"&gt;查看原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文介绍了作为技术人，在技术，工作，产品，创业，沟通等方面的潜在目标，每个人追求各有不同，但本文覆盖了蛮多的选择。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;技术：成为领域专家 / 学习前沿技术 / 维护大项目 / 贡献开源项目 / 从头开始打造一个关键系统 / 理解复杂系统 / 快速造原型&lt;/li&gt;
&lt;li&gt;工作：大公司 / 小公司 / 走 manager 路线 / 走技术路线（architect，senior，principle。。。） / 参与知名公司的软件编写&lt;/li&gt;
&lt;li&gt;产品：打磨工具 / 写网站 / 内网工具 / 解决领域问题（例如天气）/ 开发者工具&lt;/li&gt;
&lt;li&gt;沟通：写书 / 做演讲 / 做周边 / 写博客&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;反正，每一种都能让技术人停不下来。&lt;/p&gt;</content></entry><entry><title>Techshack Weekly 第 0025 期</title><link href="https://www.soasme.com/techshack.weekly/issues/0025.html" rel="alternate"></link><published>2018-10-01T00:00:00+00:00</published><updated>2018-10-01T00:00:00+00:00</updated><author><name>Ju Lin</name></author><id>tag:www.soasme.com,2018-10-01:/techshack.weekly/issues/0025.html</id><summary type="html">&lt;p&gt;这是 Techshack Weekly 第 0025 期。本期好玩的文章有：The Observability Pipeline，Load Balancing for Latency，后 K8S 时代的微服务，Netflix 的架构。&lt;/p&gt;</summary><content type="html">&lt;p&gt;这是 Techshack Weekly 第 0025 期。本期好玩的文章有：The Observability Pipeline，Load Balancing for Latency，后 K8S 时代的微服务，Netflix 的架构。 &lt;a href="https://www.soasme.com/techshack.weekly/issues/0025.html"&gt;前往查看&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;System Design&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="https://www.soasme.com/techshack.weekly/verses/d2fb6e41-2931-4443-8fa5-64c139c6ae58.html"&gt;Load Balancing for Latency&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="https://www.soasme.com/techshack.weekly/verses/39cde0ea-1da0-43b5-bbc3-9fd69e3d6aaa.html"&gt;Netflix 点击按钮的背后&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="https://www.soasme.com/techshack.weekly/verses/6aa4fbd1-9f8d-47a0-830f-6bbef868e1b9.html"&gt;Microservices in a Post-Kubernetes Era&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="https://www.soasme.com/techshack.weekly/verses/5137f517-9d4e-476d-9898-772c1a4ca995.html"&gt;The Observability Pipeline&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="https://www.soasme.com/techshack.weekly/verses/4136d664-cd69-4137-9b57-ad637699bcc1.html"&gt;LogDevice Concepts and architecture&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="https://www.soasme.com/techshack.weekly/verses/792bad18-8b00-4a73-8e45-cdadbddfbff6.html"&gt;Documenting Architecture Decisions&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Tools&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="https://www.soasme.com/techshack.weekly/verses/22f93d99-0472-4f63-80f1-78d7a0cee113.html"&gt;xonsh - python shell&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="https://www.soasme.com/techshack.weekly/verses/933aeb58-10e7-4f2f-a9ec-42ad9c881791.html"&gt;Perkeep - permanently keep your stuff for life&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="https://www.soasme.com/techshack.weekly/verses/70977c9d-0925-4c4e-a29f-b189002abb80.html"&gt;How auth works in EKS with IAM Users&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="https://www.soasme.com/techshack.weekly/verses/1d07dd9c-49be-4ee1-b69a-57dfab9cde91.html"&gt;Termtosvg - Terminal 录制软件&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Python&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="https://www.soasme.com/techshack.weekly/verses/7ef97fec-bcba-44d4-b0dc-270af647cfe9.html"&gt;pypeln - Python data pipeline library&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="https://www.soasme.com/techshack.weekly/verses/fd0f7c62-cae2-418a-ba55-d3df3dda80fe.html"&gt;How does Dropbox rollout Python 3 for desktop applications&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Programming&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="https://www.soasme.com/techshack.weekly/verses/6da74bc4-0bf3-466a-8fcb-b6c8043b99de.html"&gt;Inside cpyext - Why emulating CPython C API is so Hard&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="https://www.soasme.com/techshack.weekly/verses/bbf54426-3f62-4798-b45c-bddfa1881417.html"&gt;Learning Go by Comparing to Python&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</content></entry><entry><title>pypeln - Python data pipeline library</title><link href="https://www.soasme.com/techshack.weekly/verses/7ef97fec-bcba-44d4-b0dc-270af647cfe9.html" rel="alternate"></link><published>2018-09-27T00:00:00+00:00</published><updated>2018-09-27T00:00:00+00:00</updated><author><name>Ju Lin</name></author><id>tag:www.soasme.com,2018-09-27:/techshack.weekly/verses/7ef97fec-bcba-44d4-b0dc-270af647cfe9.html</id><summary type="html">&lt;p&gt;&lt;a href="https://github.com/cgarciae/pypeln"&gt;查看原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Pypeln 是一款基于 Processes, Threads and asyncio.Tasks 进行并发任务操作的库，旨在提供优雅的 API，而需求又不至于到要去用 Spark or Dask 的程度。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;pypeln&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;process&lt;/span&gt; &lt;span class="k"&gt;as&lt;/span&gt; &lt;span class="n"&gt;pr&lt;/span&gt;
&lt;span class="n"&gt;stage&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;pr&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;map&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;task1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;workers&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;maxsize&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;stage&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;pr&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;filter&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;task2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;stage&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;workers&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;data&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;list&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;stage&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;或者 &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;pypeln&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;thread&lt;/span&gt; &lt;span class="k"&gt;as&lt;/span&gt; &lt;span class="n"&gt;th&lt;/span&gt;
&lt;span class="n"&gt;stage&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;th …&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</summary><content type="html">&lt;p&gt;&lt;a href="https://github.com/cgarciae/pypeln"&gt;查看原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Pypeln 是一款基于 Processes, Threads and asyncio.Tasks 进行并发任务操作的库，旨在提供优雅的 API，而需求又不至于到要去用 Spark or Dask 的程度。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;pypeln&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;process&lt;/span&gt; &lt;span class="k"&gt;as&lt;/span&gt; &lt;span class="n"&gt;pr&lt;/span&gt;
&lt;span class="n"&gt;stage&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;pr&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;map&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;task1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;workers&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;maxsize&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;stage&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;pr&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;filter&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;task2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;stage&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;workers&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;data&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;list&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;stage&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;或者 &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;pypeln&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;thread&lt;/span&gt; &lt;span class="k"&gt;as&lt;/span&gt; &lt;span class="n"&gt;th&lt;/span&gt;
&lt;span class="n"&gt;stage&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;th&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;map&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;task1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;workers&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;maxsize&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;stage&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;th&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;filter&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;task2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;stage&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;workers&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;data&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;list&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;stage&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;或者&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;pypeln&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;asyncio_task&lt;/span&gt; &lt;span class="k"&gt;as&lt;/span&gt; &lt;span class="n"&gt;aio&lt;/span&gt;
&lt;span class="n"&gt;stage&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;aio&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;map&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;async_task1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;workers&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;maxsize&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;stage&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;aio&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;filter&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;async_task2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;stage&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;workers&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;data&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;list&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;stage&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;以上各种 worker 可以串起来用：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="n"&gt;data&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;aio&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;map&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;f1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;workers&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;100&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;data&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;th&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;flat_map&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;f2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;workers&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;data&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;filter&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;f3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;data&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;pr&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;map&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;f4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;workers&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;maxsize&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;200&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;```&lt;/p&gt;</content></entry><entry><title>How does Dropbox rollout Python 3 for desktop applications</title><link href="https://www.soasme.com/techshack.weekly/verses/fd0f7c62-cae2-418a-ba55-d3df3dda80fe.html" rel="alternate"></link><published>2018-09-27T00:00:00+00:00</published><updated>2018-09-27T00:00:00+00:00</updated><author><name>Ju Lin</name></author><id>tag:www.soasme.com,2018-09-27:/techshack.weekly/verses/fd0f7c62-cae2-418a-ba55-d3df3dda80fe.html</id><summary type="html">&lt;p&gt;&lt;a href="https://blogs.dropbox.com/tech/2018/09/how-we-rolled-out-one-of-the-largest-python-3-migrations-ever/"&gt;查看原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文描述了 Dropbox 如何将 macOS，Windows，和 Linux 客户端应用程序迁移到 Python 3.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Python 带来的好处：类型注解，Coroutine。&lt;/li&gt;
&lt;li&gt;挑战：发布客户端的 Freezers 脚本要应对 TypeScript/HTML, Rust, and Python, as well as Objective-C and C++ 的混合代码库。&lt;ul&gt;
&lt;li&gt;特别是近些年操作系统开始要求代码部署需要做签名，或者更新的 API（macOS FinderSync）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;解决方案：在各种打包工具不太好使的情况下，转投嵌入式 Python （Embedding Python）。这样可以基于特定操作系统的接口搭底层，然后往上套一层 Python，再往上运行业务逻辑。&lt;/li&gt;
&lt;li&gt;发布分成3步&lt;ul&gt;
&lt;li&gt;客户端停用现有的 freezer scripts …&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;</summary><content type="html">&lt;p&gt;&lt;a href="https://blogs.dropbox.com/tech/2018/09/how-we-rolled-out-one-of-the-largest-python-3-migrations-ever/"&gt;查看原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文描述了 Dropbox 如何将 macOS，Windows，和 Linux 客户端应用程序迁移到 Python 3.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Python 带来的好处：类型注解，Coroutine。&lt;/li&gt;
&lt;li&gt;挑战：发布客户端的 Freezers 脚本要应对 TypeScript/HTML, Rust, and Python, as well as Objective-C and C++ 的混合代码库。&lt;ul&gt;
&lt;li&gt;特别是近些年操作系统开始要求代码部署需要做签名，或者更新的 API（macOS FinderSync）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;解决方案：在各种打包工具不太好使的情况下，转投嵌入式 Python （Embedding Python）。这样可以基于特定操作系统的接口搭底层，然后往上套一层 Python，再往上运行业务逻辑。&lt;/li&gt;
&lt;li&gt;发布分成3步&lt;ul&gt;
&lt;li&gt;客户端停用现有的 freezer scripts&lt;/li&gt;
&lt;li&gt;客户端同时运行 Python 2/3 兼容的代码&lt;/li&gt;
&lt;li&gt;大约花了七个月，慢慢替换掉老代码。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;</content></entry><entry><title>The Observability Pipeline</title><link href="https://www.soasme.com/techshack.weekly/verses/5137f517-9d4e-476d-9898-772c1a4ca995.html" rel="alternate"></link><published>2018-09-25T00:00:00+00:00</published><updated>2018-09-25T00:00:00+00:00</updated><author><name>Ju Lin</name></author><id>tag:www.soasme.com,2018-09-25:/techshack.weekly/verses/5137f517-9d4e-476d-9898-772c1a4ca995.html</id><summary type="html">&lt;p&gt;&lt;a href="https://bravenewgeek.com/the-observability-pipeline/"&gt;查看原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文的话题是使用 The Observability Pipeline 帮助更好地理解系统。问题产生的背景是现代软件不再局限于裸机+Nagios 这种组合，而是趋向于 cloud-native and container-based systems。可能你 Debug 着，容器就被干没了。所以，要想解决这个问题，就得让应用自己传出结构化的日志记录用于分析 - 这产生了新问题：如何处理这些日志呢？结论是建一条 Observability Pipeline。&lt;/p&gt;
&lt;p&gt;监控是关于known-unknowns and actionable alerts， observability 是关于 unknown-unknowns，并帮助开发更容易理解系统行为。以下是开发 The Observability Pipeline 的一些要点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;确保日志是 Structured 的。你要写 spec，spec 要能区分 logs, metrics, traces, events …&lt;/li&gt;&lt;/ul&gt;</summary><content type="html">&lt;p&gt;&lt;a href="https://bravenewgeek.com/the-observability-pipeline/"&gt;查看原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文的话题是使用 The Observability Pipeline 帮助更好地理解系统。问题产生的背景是现代软件不再局限于裸机+Nagios 这种组合，而是趋向于 cloud-native and container-based systems。可能你 Debug 着，容器就被干没了。所以，要想解决这个问题，就得让应用自己传出结构化的日志记录用于分析 - 这产生了新问题：如何处理这些日志呢？结论是建一条 Observability Pipeline。&lt;/p&gt;
&lt;p&gt;监控是关于known-unknowns and actionable alerts， observability 是关于 unknown-unknowns，并帮助开发更容易理解系统行为。以下是开发 The Observability Pipeline 的一些要点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;确保日志是 Structured 的。你要写 spec，spec 要能区分 logs, metrics, traces, events 各种数据，spec 要能演化支持版本升级，最好带上 id 帮忙定位，可以带上一些 tag 帮助过滤。&lt;/li&gt;
&lt;li&gt;需要的话可以在服务里面安装上 Specification Libraries，帮助更好地生成日志，类似 tracing libraries。&lt;/li&gt;
&lt;li&gt;Data Collector 可以作为 sidecar 安装在容器里或者 host 上，写到 stdout/stderr 或者 Unix domain socket，然后推到 pipeline 里面。很多日志工具都可以用，例如 fluentd。&lt;/li&gt;
&lt;li&gt;Data Pipeline 的核心就是保证高可用，很多工具也可以用，例如：kafka, kinesis, 等等&lt;/li&gt;
&lt;li&gt;Data Router 用于过滤数据，接在 Pipeline 后面，把数据发送到合适的后端去，这种地方用 serverless 什么的就很方便。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;整个架构大概长这样：&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://bravenewgeek.com/wp-content/uploads/2018/09/observability_pipeline.png"&gt;&lt;/p&gt;
&lt;p&gt;当然，这个架构不是一天造出来的，你可以当作 CI/CD 流水线一样一直去打磨它。&lt;/p&gt;</content></entry><entry><title>Inside cpyext - Why emulating CPython C API is so Hard</title><link href="https://www.soasme.com/techshack.weekly/verses/6da74bc4-0bf3-466a-8fcb-b6c8043b99de.html" rel="alternate"></link><published>2018-09-25T00:00:00+00:00</published><updated>2018-09-25T00:00:00+00:00</updated><author><name>Ju Lin</name></author><id>tag:www.soasme.com,2018-09-25:/techshack.weekly/verses/6da74bc4-0bf3-466a-8fcb-b6c8043b99de.html</id><summary type="html">&lt;p&gt;&lt;a href="https://morepypy.blogspot.com/2018/09/inside-cpyext-why-emulating-cpython-c.html"&gt;查看原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文是 Pypy 更新的博文，探讨的是如何通过 cpyext 提升 Pypy 的 benchmark。&lt;/p&gt;
&lt;p&gt;cpyext 是 Pypy 的组件，用于为 CPython C 插件运行在 Pypy 上提供兼容层。换句话说，在 C 插件中只要用到了 &lt;code&gt;Python.h&lt;/code&gt; 这个依赖，那么在 Pypy 中其实就是在用 cpyext。现状是：cpyext 刚处于能用的状况，这些 C 插件运行在 Pypy 上其实比 CPython 还慢一些。&lt;/p&gt;
&lt;p&gt;在 CPython 中，解释器使用的是引用计数，PyObject&lt;em&gt; 对象分配在堆上。当引用降到 0 时可以被安全 …&lt;/em&gt;&lt;/p&gt;</summary><content type="html">&lt;p&gt;&lt;a href="https://morepypy.blogspot.com/2018/09/inside-cpyext-why-emulating-cpython-c.html"&gt;查看原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文是 Pypy 更新的博文，探讨的是如何通过 cpyext 提升 Pypy 的 benchmark。&lt;/p&gt;
&lt;p&gt;cpyext 是 Pypy 的组件，用于为 CPython C 插件运行在 Pypy 上提供兼容层。换句话说，在 C 插件中只要用到了 &lt;code&gt;Python.h&lt;/code&gt; 这个依赖，那么在 Pypy 中其实就是在用 cpyext。现状是：cpyext 刚处于能用的状况，这些 C 插件运行在 Pypy 上其实比 CPython 还慢一些。&lt;/p&gt;
&lt;p&gt;在 CPython 中，解释器使用的是引用计数，PyObject&lt;em&gt; 对象分配在堆上。当引用降到 0 时可以被安全 free 掉。在 Pypy 中类似，所有对象都是 &lt;code&gt;W_Root&lt;/code&gt; 的子类，但是在 Pypy 中其实使用的是 Generational GC。这意味着在做 C 插件编译的时候，Pypy 要去维护 PyObject&lt;/em&gt; 和 W_Root 的关系，这个是导致拖慢性能的地方 - C 跟 RPython 互转的地方是最慢的。Pypy 所做的努力是简化 cpyext , 减少 C - RPython 做类型转换的 round-trip time。 麻烦的地方在于简化 cpyext 需要对 C API 一个一个去做适配。&lt;/p&gt;</content></entry><entry><title>Learning Go by Comparing to Python</title><link href="https://www.soasme.com/techshack.weekly/verses/bbf54426-3f62-4798-b45c-bddfa1881417.html" rel="alternate"></link><published>2018-09-25T00:00:00+00:00</published><updated>2018-09-25T00:00:00+00:00</updated><author><name>Ju Lin</name></author><id>tag:www.soasme.com,2018-09-25:/techshack.weekly/verses/bbf54426-3f62-4798-b45c-bddfa1881417.html</id><summary type="html">&lt;p&gt;&lt;a href="http://govspy.peterbe.com/"&gt;查看原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文为 Python 使用者提供了一份与 Go 对比的 Cheat sheet。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;fmt.Println&lt;/code&gt; v/s &lt;code&gt;print&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;fmt.Print&lt;/code&gt; v/s &lt;code&gt;print(string, end='')&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;//&lt;/code&gt;, &lt;code&gt;/* ... */&lt;/code&gt; v/s &lt;code&gt;#&lt;/code&gt;, &lt;code&gt;""" ... """&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="s"&gt;`This is &lt;/span&gt;
&lt;span class="s"&gt;a multi-line string.`&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;v/s&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;This is&lt;/span&gt;
&lt;span class="sd"&gt;a multi-line string.&lt;/span&gt;
&lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;ul&gt;
&lt;li&gt;vector/list initialize: &lt;code&gt;var numbers [5]int&lt;/code&gt; v/s &lt;code&gt;[0] * 5&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;slice: &lt;code&gt;some_numbers := numbers[1:3 …&lt;/code&gt;&lt;/li&gt;&lt;/ul&gt;</summary><content type="html">&lt;p&gt;&lt;a href="http://govspy.peterbe.com/"&gt;查看原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文为 Python 使用者提供了一份与 Go 对比的 Cheat sheet。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;fmt.Println&lt;/code&gt; v/s &lt;code&gt;print&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;fmt.Print&lt;/code&gt; v/s &lt;code&gt;print(string, end='')&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;//&lt;/code&gt;, &lt;code&gt;/* ... */&lt;/code&gt; v/s &lt;code&gt;#&lt;/code&gt;, &lt;code&gt;""" ... """&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="s"&gt;`This is &lt;/span&gt;
&lt;span class="s"&gt;a multi-line string.`&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;v/s&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;This is&lt;/span&gt;
&lt;span class="sd"&gt;a multi-line string.&lt;/span&gt;
&lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;ul&gt;
&lt;li&gt;vector/list initialize: &lt;code&gt;var numbers [5]int&lt;/code&gt; v/s &lt;code&gt;[0] * 5&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;slice: &lt;code&gt;some_numbers := numbers[1:3]&lt;/code&gt; v/s &lt;code&gt;some_numbers = numbers[1:3]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;append: &lt;code&gt;append(scores, 1.1)&lt;/code&gt; v/s &lt;code&gt;scores.append(1.1)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;map initialize: &lt;code&gt;elements := make(map[string]int)&lt;/code&gt; v/s &lt;code&gt;elements = {}&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;map setter: &lt;code&gt;elements["H"] = 1&lt;/code&gt; v/s &lt;code&gt;elements["H"] = 1&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;map deletion: &lt;code&gt;delete(elements, "O")&lt;/code&gt; v/s &lt;code&gt;elements.pop("O")&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;map hasattr: &lt;code&gt;if number, ok := elements["O"]; ok {&lt;/code&gt; v/s &lt;code&gt;if "O" in elements:&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;boolean: &lt;code&gt;if x != 0 {&lt;/code&gt; v/s &lt;code&gt;if not x:&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;, &lt;code&gt;||&lt;/code&gt;, &lt;code&gt;!&lt;/code&gt; v/s &lt;code&gt;and&lt;/code&gt;, &lt;code&gt;or&lt;/code&gt;, &lt;code&gt;not&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;function: &lt;code&gt;func average(numbers ...float64) float64 {&lt;/code&gt; v/s &lt;code&gt;def average(*numbers):&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;defer: &lt;code&gt;defer f.Close()&lt;/code&gt; v/s &lt;code&gt;try: ... finally: f.close()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;struct v/s class&lt;/li&gt;
&lt;li&gt;...&lt;/li&gt;
&lt;/ul&gt;</content></entry><entry><title>Load Balancing for Latency</title><link href="https://www.soasme.com/techshack.weekly/verses/d2fb6e41-2931-4443-8fa5-64c139c6ae58.html" rel="alternate"></link><published>2018-09-25T00:00:00+00:00</published><updated>2018-09-25T00:00:00+00:00</updated><author><name>Ju Lin</name></author><id>tag:www.soasme.com,2018-09-25:/techshack.weekly/verses/d2fb6e41-2931-4443-8fa5-64c139c6ae58.html</id><summary type="html">&lt;p&gt;&lt;a href="https://blog.buoyant.io/2016/03/16/beyond-round-robin-load-balancing-for-latency/"&gt;查看原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文介绍了在某些特定情况下比 Round Robin 更适用的负载均衡算法。负载均衡要完成的两个大目标是：Scale(支持更多数量的 backend)，和 Resilience(坏掉的一些 backends 不影响服务总体)。本文探讨了如果引入 Latency 用于负载均衡也会有很不错的效果。一般健康检查校验服务是否挂了，而 Latency 能校验服务现在合不合适承接流量。本文的立论是：一个好的负载均衡也应该同等检查 failure 和 latency。&lt;/p&gt;
&lt;p&gt;本文介绍的两种算法分别是： &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;least loaded, 负载均衡维护每台机器的流量，路由新流量去负载最低的机器。&lt;/li&gt;
&lt;li&gt;peak exponentially-weighted moving average (“peak EWMA”): 负载均衡维护每台机器的 round-trip time，需要的话乘上权重，路由新流量去平均响应时间最短的那台机器。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;一般最常见的还是 round robin；这两种算法见于 Twitter Finagle 的 RPC …&lt;/p&gt;</summary><content type="html">&lt;p&gt;&lt;a href="https://blog.buoyant.io/2016/03/16/beyond-round-robin-load-balancing-for-latency/"&gt;查看原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文介绍了在某些特定情况下比 Round Robin 更适用的负载均衡算法。负载均衡要完成的两个大目标是：Scale(支持更多数量的 backend)，和 Resilience(坏掉的一些 backends 不影响服务总体)。本文探讨了如果引入 Latency 用于负载均衡也会有很不错的效果。一般健康检查校验服务是否挂了，而 Latency 能校验服务现在合不合适承接流量。本文的立论是：一个好的负载均衡也应该同等检查 failure 和 latency。&lt;/p&gt;
&lt;p&gt;本文介绍的两种算法分别是： &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;least loaded, 负载均衡维护每台机器的流量，路由新流量去负载最低的机器。&lt;/li&gt;
&lt;li&gt;peak exponentially-weighted moving average (“peak EWMA”): 负载均衡维护每台机器的 round-trip time，需要的话乘上权重，路由新流量去平均响应时间最短的那台机器。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;一般最常见的还是 round robin；这两种算法见于 Twitter Finagle 的 RPC 客户端中。 这两种算法需要使用 OSI Layer 5 Session 层的一些信息，例如queue depth / RPC latencies。&lt;/p&gt;</content></entry><entry><title>Termtosvg - Terminal 录制软件</title><link href="https://www.soasme.com/techshack.weekly/verses/1d07dd9c-49be-4ee1-b69a-57dfab9cde91.html" rel="alternate"></link><published>2018-09-24T00:00:00+00:00</published><updated>2018-09-24T00:00:00+00:00</updated><author><name>Ju Lin</name></author><id>tag:www.soasme.com,2018-09-24:/techshack.weekly/verses/1d07dd9c-49be-4ee1-b69a-57dfab9cde91.html</id><summary type="html">&lt;p&gt;&lt;a href="https://github.com/nbedos/termtosvg"&gt;查看原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Termtosvg 可以将 term 敲下来的命令录成 svg 格式。比起录成 GIF，svg 的好处是，特别小，挺长的一段操作可能录出来的 svg 文件才几百 KB 大小。因为 svg 是矢量文件，比起 GIF 按照 frame 录制 文件大小就是会小很多。&lt;/p&gt;
&lt;p&gt;如果查看它的实现，可以看到底层使用了 pyte 捕获 tty 的标准输入和输出。程序本身作为父进程，敲的命令作为子进程。使用 select 等待可用的子进程的输入和输出并存下来。&lt;/p&gt;</summary><content type="html">&lt;p&gt;&lt;a href="https://github.com/nbedos/termtosvg"&gt;查看原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Termtosvg 可以将 term 敲下来的命令录成 svg 格式。比起录成 GIF，svg 的好处是，特别小，挺长的一段操作可能录出来的 svg 文件才几百 KB 大小。因为 svg 是矢量文件，比起 GIF 按照 frame 录制 文件大小就是会小很多。&lt;/p&gt;
&lt;p&gt;如果查看它的实现，可以看到底层使用了 pyte 捕获 tty 的标准输入和输出。程序本身作为父进程，敲的命令作为子进程。使用 select 等待可用的子进程的输入和输出并存下来。&lt;/p&gt;</content></entry><entry><title>LogDevice Concepts and architecture</title><link href="https://www.soasme.com/techshack.weekly/verses/4136d664-cd69-4137-9b57-ad637699bcc1.html" rel="alternate"></link><published>2018-09-21T00:00:00+00:00</published><updated>2018-09-21T00:00:00+00:00</updated><author><name>Ju Lin</name></author><id>tag:www.soasme.com,2018-09-21:/techshack.weekly/verses/4136d664-cd69-4137-9b57-ad637699bcc1.html</id><summary type="html">&lt;p&gt;&lt;a href="https://logdevice.io/docs/Concepts.html"&gt;查看原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;LogDevice 是 Facebook 最近开源的一个分布式服务，用来为日志提供持久存储。它应用的新技术叫做 non-deterministic decentralized record placement, 目标是提供高可用+一致+低 write-latencies 的集群。与普通日志服务不同，LogDevice 的源自单位是 records，也就是一条日志记录。LogDevice 原生支持 SSD 和 HDD。&lt;/p&gt;
&lt;p&gt;每条日志都有递增的 LSN（序列号），用于排序。在脑裂的特殊情况下，LogDevice 选择可用性高于一致性。多 writers 可以并发地写日志到同一个地方。这些记录会被复制存储到多台机器去以保证数据不会丢失。就算单节点出故障或者磁盘不够了，整个集群还是可以提供写功能。这个流程 LogDevice 通过集群中运行 sequencer 用于给记录标上 LSN，然后存储到节点上。一批存储同一个记录的节点被称为复制集（copyset）。readers 可以根据随机或者权重挑选 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;&lt;a href="https://logdevice.io/docs/Concepts.html"&gt;查看原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;LogDevice 是 Facebook 最近开源的一个分布式服务，用来为日志提供持久存储。它应用的新技术叫做 non-deterministic decentralized record placement, 目标是提供高可用+一致+低 write-latencies 的集群。与普通日志服务不同，LogDevice 的源自单位是 records，也就是一条日志记录。LogDevice 原生支持 SSD 和 HDD。&lt;/p&gt;
&lt;p&gt;每条日志都有递增的 LSN（序列号），用于排序。在脑裂的特殊情况下，LogDevice 选择可用性高于一致性。多 writers 可以并发地写日志到同一个地方。这些记录会被复制存储到多台机器去以保证数据不会丢失。就算单节点出故障或者磁盘不够了，整个集群还是可以提供写功能。这个流程 LogDevice 通过集群中运行 sequencer 用于给记录标上 LSN，然后存储到节点上。一批存储同一个记录的节点被称为复制集（copyset）。readers 可以根据随机或者权重挑选 copyset 中的节点把数据取出来重新排序。 节点上存储 records 的数据库叫做 LogsDB，是一个基于 RocksDB （基于 LSM 树的 kv 数据库）的数据库。&lt;/p&gt;</content></entry><entry><title>Microservices in a Post-Kubernetes Era</title><link href="https://www.soasme.com/techshack.weekly/verses/6aa4fbd1-9f8d-47a0-830f-6bbef868e1b9.html" rel="alternate"></link><published>2018-09-21T00:00:00+00:00</published><updated>2018-09-21T00:00:00+00:00</updated><author><name>Ju Lin</name></author><id>tag:www.soasme.com,2018-09-21:/techshack.weekly/verses/6aa4fbd1-9f8d-47a0-830f-6bbef868e1b9.html</id><summary type="html">&lt;p&gt;&lt;a href="https://www.infoq.com/articles/microservices-post-kubernetes"&gt;查看原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文探讨了在 Kubernetes 在变得成熟后微服务这个实践相应产生的变化。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;服务的 Observability 还不够，服务还得去实现健康检查，对 Signals 作出回馈，能主动声明资源消耗多少。因为服务观测其实有点变成伪命题了，哪有人那么费心去查问题，有问题杀掉重新起个新的 Pod 出来多省事。这就要求应用能够跟自动化一些地提供自己的健康情况，让平台自己检测出这些不正常的地方然后重新搞个健康的出来。&lt;/li&gt;
&lt;li&gt;应用成的断路器等逻辑慢慢式微，取而代之更流行的做法是用 Service Mesh。每个微服务都给起一个 sidecar container 用于 proxy，这种设计可以简化应用层。&lt;/li&gt;
&lt;li&gt;微服务得能被设计地面向 recovery：能很容易地杀掉，重启，然后一切恢复正常。&lt;/li&gt;
&lt;/ul&gt;</summary><content type="html">&lt;p&gt;&lt;a href="https://www.infoq.com/articles/microservices-post-kubernetes"&gt;查看原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文探讨了在 Kubernetes 在变得成熟后微服务这个实践相应产生的变化。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;服务的 Observability 还不够，服务还得去实现健康检查，对 Signals 作出回馈，能主动声明资源消耗多少。因为服务观测其实有点变成伪命题了，哪有人那么费心去查问题，有问题杀掉重新起个新的 Pod 出来多省事。这就要求应用能够跟自动化一些地提供自己的健康情况，让平台自己检测出这些不正常的地方然后重新搞个健康的出来。&lt;/li&gt;
&lt;li&gt;应用成的断路器等逻辑慢慢式微，取而代之更流行的做法是用 Service Mesh。每个微服务都给起一个 sidecar container 用于 proxy，这种设计可以简化应用层。&lt;/li&gt;
&lt;li&gt;微服务得能被设计地面向 recovery：能很容易地杀掉，重启，然后一切恢复正常。&lt;/li&gt;
&lt;/ul&gt;</content></entry><entry><title>How auth works in EKS with IAM Users</title><link href="https://www.soasme.com/techshack.weekly/verses/70977c9d-0925-4c4e-a29f-b189002abb80.html" rel="alternate"></link><published>2018-09-19T00:00:00+00:00</published><updated>2018-09-19T00:00:00+00:00</updated><author><name>Ju Lin</name></author><id>tag:www.soasme.com,2018-09-19:/techshack.weekly/verses/70977c9d-0925-4c4e-a29f-b189002abb80.html</id><summary type="html">&lt;p&gt;&lt;a href="http://marcinkaszynski.com/2018/07/12/eks-auth.html"&gt;查看原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文介绍了 AWS EKS 是怎么做初始化的授权验证。AWS 提供了 IAM 用于权限验证，Kubernetes 初始化时需要 admin service account 才能进行管理。事实上，EKS 初始化时就使用了你本地的 &lt;code&gt;~/.aws&lt;/code&gt; 配置，并会使用创建 EKS 的 IAM User 或者 IAM Role 作为 admin service account。这个 user 是不会出现在 aws cli / kubectl 的数据中的。如果有需要添加额外的 user，那你需要使用这个用户继续添加 ConfigMap，通过 &lt;code&gt;mapRole&lt;/code&gt;, &lt;code&gt;mapUser&lt;/code&gt; 添加管理用户。&lt;/p&gt;
&lt;p&gt;整套授权是通过一个叫做 &lt;code&gt;aws-iam-authenticator&lt;/code&gt; 的 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;&lt;a href="http://marcinkaszynski.com/2018/07/12/eks-auth.html"&gt;查看原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文介绍了 AWS EKS 是怎么做初始化的授权验证。AWS 提供了 IAM 用于权限验证，Kubernetes 初始化时需要 admin service account 才能进行管理。事实上，EKS 初始化时就使用了你本地的 &lt;code&gt;~/.aws&lt;/code&gt; 配置，并会使用创建 EKS 的 IAM User 或者 IAM Role 作为 admin service account。这个 user 是不会出现在 aws cli / kubectl 的数据中的。如果有需要添加额外的 user，那你需要使用这个用户继续添加 ConfigMap，通过 &lt;code&gt;mapRole&lt;/code&gt;, &lt;code&gt;mapUser&lt;/code&gt; 添加管理用户。&lt;/p&gt;
&lt;p&gt;整套授权是通过一个叫做 &lt;code&gt;aws-iam-authenticator&lt;/code&gt; 的 client-server 程序完成。server 程序预先装入 EKS master，client 程序就是一个 token 生成器。这套授权可以让你的 kubeconfig 不暴露出敏感信息，而只依靠 aws iam 完成授权。&lt;/p&gt;</content></entry><entry><title>Netflix 点击按钮的背后</title><link href="https://www.soasme.com/techshack.weekly/verses/39cde0ea-1da0-43b5-bbc3-9fd69e3d6aaa.html" rel="alternate"></link><published>2018-09-18T00:00:00+00:00</published><updated>2018-09-18T00:00:00+00:00</updated><author><name>Ju Lin</name></author><id>tag:www.soasme.com,2018-09-18:/techshack.weekly/verses/39cde0ea-1da0-43b5-bbc3-9fd69e3d6aaa.html</id><summary type="html">&lt;p&gt;&lt;a href="http://highscalability.com/blog/2017/12/11/netflix-what-happens-when-you-press-play.html"&gt;查看原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文介绍了 Netflix 作为视频网站背后所涉及的客户端，服务端，网络等等相关的技术。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一个看起来很简单的网站，在用户量级上去后就会变的非常有挑战。&lt;/li&gt;
&lt;li&gt;Netflix 工程博客记录了很多他们的技术架构文章。&lt;/li&gt;
&lt;li&gt;Netflix 使用混合云：AWS + Open Connect&lt;/li&gt;
&lt;li&gt;Netflix 的三大核心组件：客户端，服务端，CDN&lt;/li&gt;
&lt;li&gt;Netflix 跟 EC2 发布在同一年，所以那时候还得自搭数据中心。自建 DC 的问题主要就是效率特低。&lt;/li&gt;
&lt;li&gt;2008 年出过一次大事故，比起维护一个数据中心，工程师们觉得还是维护产品更重要更简单，所以全线切去 AWS。历经八九年经营，现在使用着上千台 EC2 实例。&lt;/li&gt;
&lt;li&gt;Netflix 需要比 AWS 更稳定，通过在 North Virginia，Oregon，Dublin 三地搭服务，可以做到某地出问题了就切流量去别的。作为客户端 …&lt;/li&gt;&lt;/ul&gt;</summary><content type="html">&lt;p&gt;&lt;a href="http://highscalability.com/blog/2017/12/11/netflix-what-happens-when-you-press-play.html"&gt;查看原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文介绍了 Netflix 作为视频网站背后所涉及的客户端，服务端，网络等等相关的技术。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一个看起来很简单的网站，在用户量级上去后就会变的非常有挑战。&lt;/li&gt;
&lt;li&gt;Netflix 工程博客记录了很多他们的技术架构文章。&lt;/li&gt;
&lt;li&gt;Netflix 使用混合云：AWS + Open Connect&lt;/li&gt;
&lt;li&gt;Netflix 的三大核心组件：客户端，服务端，CDN&lt;/li&gt;
&lt;li&gt;Netflix 跟 EC2 发布在同一年，所以那时候还得自搭数据中心。自建 DC 的问题主要就是效率特低。&lt;/li&gt;
&lt;li&gt;2008 年出过一次大事故，比起维护一个数据中心，工程师们觉得还是维护产品更重要更简单，所以全线切去 AWS。历经八九年经营，现在使用着上千台 EC2 实例。&lt;/li&gt;
&lt;li&gt;Netflix 需要比 AWS 更稳定，通过在 North Virginia，Oregon，Dublin 三地搭服务，可以做到某地出问题了就切流量去别的。作为客户端，甚至可能都不会意识到后端某地发生了故障。Netflix 每个月也都会出一次演练 aws 挂了，整个集群可以在六分钟内切走。关于这方面，Netflix 可以说在业内做的比较领先。&lt;/li&gt;
&lt;li&gt;S3 存储着视频数据，EC2 则是获取视频元数据的入口点。&lt;/li&gt;
&lt;li&gt;Netflix 使用 DynamoDB &amp;amp; Cassandra 作为分布式数据库，另有一系列配套的数据分析流水线计算诸如推荐等数据。&lt;/li&gt;
&lt;li&gt;作为视频播放领域的特定问题，服务端转码是指服务器会为客户端预先转码好最适合特定设备的编码视频。这些转码需要耗费很多 CPU 资源。Netflix 从上游内容供应方（video source media）那里获得数据，然后校验颜色，掉帧等情况，然后切成 chunk 分批处理，最后重新合并所有 chunk，再次校验成功才推送到 CDN，全程大约需要 30 分钟。&lt;/li&gt;
&lt;li&gt;目前 Netflix 支持大约 2200 种不同的设备，例如 iPhone，XBox，Wii，Kindle，AppleTV，等等。这些优化的视频会针对网速，播放质量等做适配。&lt;/li&gt;
&lt;li&gt;Netflix 自建 CDN 以满足自己变态的需求。每个存储视频资源的地方都叫 PoP（Point of present）。大 CDN 提供方诸如 Akamai 什么的不能满足他们的需求，例如切换到另外一个 PoP 以换取别的资源。基于 AWS 的技术经过很多工程师的运营已经足够了本钱，所以自己造更好。他们使用 Open Connect 建 CDN。&lt;/li&gt;
&lt;li&gt;建 CDN 不需要数据中心，只要找遍布全世界的 IXPs。（IXP 就是网络互联的节点）&lt;/li&gt;
&lt;/ul&gt;</content></entry><entry><title>Documenting Architecture Decisions</title><link href="https://www.soasme.com/techshack.weekly/verses/792bad18-8b00-4a73-8e45-cdadbddfbff6.html" rel="alternate"></link><published>2018-09-18T00:00:00+00:00</published><updated>2018-09-18T00:00:00+00:00</updated><author><name>Ju Lin</name></author><id>tag:www.soasme.com,2018-09-18:/techshack.weekly/verses/792bad18-8b00-4a73-8e45-cdadbddfbff6.html</id><summary type="html">&lt;p&gt;&lt;a href="http://thinkrelevance.com/blog/2011/11/15/documenting-architecture-decisions"&gt;查看原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;ADR 有点像 RFC，但是更多用于 Agile 项目。敏捷项目变动快，需要一种手段能够记录做过的项目技术决策，ADR 就是一种记录决策的小短文的模板。它的段落构成可以是：标题，上下文，决定，状态，以及后果。上下文记录当时的状态，决定记录要做的事情，状态标记这个决定做审定中还是已经执行完了，后果记录它做了以后会发生什么。其实不仅可以用于 Agile 项目，个人项目也都可以用 ADR 来记录。&lt;/p&gt;</summary><content type="html">&lt;p&gt;&lt;a href="http://thinkrelevance.com/blog/2011/11/15/documenting-architecture-decisions"&gt;查看原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;ADR 有点像 RFC，但是更多用于 Agile 项目。敏捷项目变动快，需要一种手段能够记录做过的项目技术决策，ADR 就是一种记录决策的小短文的模板。它的段落构成可以是：标题，上下文，决定，状态，以及后果。上下文记录当时的状态，决定记录要做的事情，状态标记这个决定做审定中还是已经执行完了，后果记录它做了以后会发生什么。其实不仅可以用于 Agile 项目，个人项目也都可以用 ADR 来记录。&lt;/p&gt;</content></entry><entry><title>Perkeep - permanently keep your stuff for life</title><link href="https://www.soasme.com/techshack.weekly/verses/933aeb58-10e7-4f2f-a9ec-42ad9c881791.html" rel="alternate"></link><published>2018-09-18T00:00:00+00:00</published><updated>2018-09-18T00:00:00+00:00</updated><author><name>Ju Lin</name></author><id>tag:www.soasme.com,2018-09-18:/techshack.weekly/verses/933aeb58-10e7-4f2f-a9ec-42ad9c881791.html</id><summary type="html">&lt;p&gt;&lt;a href="https://perkeep.org/"&gt;查看原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Perkeep 是一款用于存储个人数据的程序，CS 架构，客户端可以是手机，浏览器，或者 FUSE 文件系统。它的目标是尝试打造终生存储。它的本质是个基于多云存储的 blobserver，在客户端提供了不限于 dir/file/filename 这种基于文件的存储格式。&lt;/p&gt;</summary><content type="html">&lt;p&gt;&lt;a href="https://perkeep.org/"&gt;查看原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Perkeep 是一款用于存储个人数据的程序，CS 架构，客户端可以是手机，浏览器，或者 FUSE 文件系统。它的目标是尝试打造终生存储。它的本质是个基于多云存储的 blobserver，在客户端提供了不限于 dir/file/filename 这种基于文件的存储格式。&lt;/p&gt;</content></entry><entry><title>xonsh - python shell</title><link href="https://www.soasme.com/techshack.weekly/verses/22f93d99-0472-4f63-80f1-78d7a0cee113.html" rel="alternate"></link><published>2018-09-17T00:00:00+00:00</published><updated>2018-09-17T00:00:00+00:00</updated><author><name>Ju Lin</name></author><id>tag:www.soasme.com,2018-09-17:/techshack.weekly/verses/22f93d99-0472-4f63-80f1-78d7a0cee113.html</id><summary type="html">&lt;p&gt;&lt;a href="https://xon.sh/tutorial.html"&gt;查看原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Xonsh 是一款 shell 工具，基于 Python 提供类似 bash + ipython 结合体验。一些基于 python 的语法改进&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;支持环境变量，例如 &lt;code&gt;$HOME&lt;/code&gt;, &lt;code&gt;${...}&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;像 sh 一样运行命令：&lt;code&gt;cd xyz&lt;/code&gt;, &lt;code&gt;git status&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$(ls -l)&lt;/code&gt; 把输出流转为 Python 字符串&lt;/li&gt;
&lt;li&gt;&lt;code&gt;!(ls nonexistent_directory)&lt;/code&gt; 把输出和错误转为一个 &lt;code&gt;CommandPipeline(stdin, stdout, stderr, ...)&lt;/code&gt; 的对象&lt;/li&gt;
&lt;/ul&gt;</summary><content type="html">&lt;p&gt;&lt;a href="https://xon.sh/tutorial.html"&gt;查看原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Xonsh 是一款 shell 工具，基于 Python 提供类似 bash + ipython 结合体验。一些基于 python 的语法改进&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;支持环境变量，例如 &lt;code&gt;$HOME&lt;/code&gt;, &lt;code&gt;${...}&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;像 sh 一样运行命令：&lt;code&gt;cd xyz&lt;/code&gt;, &lt;code&gt;git status&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$(ls -l)&lt;/code&gt; 把输出流转为 Python 字符串&lt;/li&gt;
&lt;li&gt;&lt;code&gt;!(ls nonexistent_directory)&lt;/code&gt; 把输出和错误转为一个 &lt;code&gt;CommandPipeline(stdin, stdout, stderr, ...)&lt;/code&gt; 的对象&lt;/li&gt;
&lt;/ul&gt;</content></entry><entry><title>Techshack Weekly 第 0024 期</title><link href="https://www.soasme.com/techshack.weekly/issues/0024.html" rel="alternate"></link><published>2018-09-16T00:00:00+00:00</published><updated>2018-09-16T00:00:00+00:00</updated><author><name>Ju Lin</name></author><id>tag:www.soasme.com,2018-09-16:/techshack.weekly/issues/0024.html</id><summary type="html">&lt;p&gt;这是 Techshack Weekly 第 0024 期。&lt;/p&gt;</summary><content type="html">&lt;p&gt;这是 Techshack Weekly 第 0024 期。 &lt;a href="https://www.soasme.com/techshack.weekly/issues/0024.html"&gt;前往查看&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Engineering&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://www.soasme.com/techshack.weekly/verses/73ffe7a8-dfe9-4a1c-95a3-04c59dae55e2.html"&gt;The Servers Are Burning&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Performance&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://www.soasme.com/techshack.weekly/verses/46d928b1-29bf-41d5-9fc7-ca84588703bb.html"&gt;Cost of CORS Request on SPA&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Tools&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="https://www.soasme.com/techshack.weekly/verses/0a223fa3-10d2-40e7-8889-42b1c8800cdd.html"&gt;Makefile Basics&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="https://www.soasme.com/techshack.weekly/verses/870580f0-4b1f-48d0-96ac-7f90929ac2cc.html"&gt;CLI 工具推荐 2018.37&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="https://www.soasme.com/techshack.weekly/verses/3f1c333f-dd2a-4032-bfd8-262ab84e9f6f.html"&gt;使用 Terraform 快速启动 EKS 服务&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="https://www.soasme.com/techshack.weekly/verses/1c351c59-7377-45a1-8d59-8e6d649d44f1.html"&gt;Tink - NPM Replacement&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Python&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="https://www.soasme.com/techshack.weekly/verses/d7a837da-f547-4f42-a2dd-ef929dcedf8f.html"&gt;Nox - 多 Python 环境的自动化测试工具&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="https://www.soasme.com/techshack.weekly/verses/4334edb6-ac35-4d24-b414-5a70209ce2b9.html"&gt;Python 代码上线检查清单&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="https://www.soasme.com/techshack.weekly/verses/40388395-5410-4e42-8986-436627fd0803.html"&gt;Python 3 Type hints cheat sheet&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Programming&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="https://www.soasme.com/techshack.weekly/verses/9d216127-3342-4a25-9c94-cc5528618ab0.html"&gt;系统编程是什么&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="https://www.soasme.com/techshack.weekly/verses/3a2012e0-475d-4bab-977d-df23ae8a85f2.html"&gt;gPRC with JSON&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</content></entry><entry><title>Makefile Basics</title><link href="https://www.soasme.com/techshack.weekly/verses/0a223fa3-10d2-40e7-8889-42b1c8800cdd.html" rel="alternate"></link><published>2018-09-15T00:00:00+00:00</published><updated>2018-09-15T00:00:00+00:00</updated><author><name>Ju Lin</name></author><id>tag:www.soasme.com,2018-09-15:/techshack.weekly/verses/0a223fa3-10d2-40e7-8889-42b1c8800cdd.html</id><summary type="html">&lt;p&gt;&lt;a href="https://gist.github.com/isaacs/62a2d1825d04437c6f08"&gt;查看原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这段代码是 isaacs 的一段 gist，可以学到 make 的最基本知识，而关于更多的知识，可查看 gnu make man：http://www.gnu.org/software/make/manual/make.html&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;make -f &amp;lt;filename&amp;gt;&lt;/code&gt; 可以指定运行哪个 Makefile，默认使用 &lt;code&gt;./Makefile&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;语法如下，target 是必须的，依赖和命令是可选的&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="err"&gt;&amp;lt;target&amp;gt;: &amp;lt;prerequiresites&amp;gt;...&lt;/span&gt;
&lt;span class="err"&gt;    &amp;lt;commands&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;ul&gt;
&lt;li&gt;&lt;code&gt;@&lt;/code&gt; 加在命令前面不输出命令&lt;/li&gt;
&lt;li&gt;多条 &lt;code&gt;&amp;lt;commands&lt;/code&gt; 之间不会互相共享环境变量&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c"&gt;var-lost:&lt;/span&gt;
&lt;span class="c"&gt;    export foo=bar&lt;/span&gt;
&lt;span class="c"&gt;    echo &amp;quot;foo=[$$foo]&amp;quot; # 这里 $foo 不会被赋值上 …&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</summary><content type="html">&lt;p&gt;&lt;a href="https://gist.github.com/isaacs/62a2d1825d04437c6f08"&gt;查看原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这段代码是 isaacs 的一段 gist，可以学到 make 的最基本知识，而关于更多的知识，可查看 gnu make man：http://www.gnu.org/software/make/manual/make.html&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;make -f &amp;lt;filename&amp;gt;&lt;/code&gt; 可以指定运行哪个 Makefile，默认使用 &lt;code&gt;./Makefile&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;语法如下，target 是必须的，依赖和命令是可选的&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="err"&gt;&amp;lt;target&amp;gt;: &amp;lt;prerequiresites&amp;gt;...&lt;/span&gt;
&lt;span class="err"&gt;    &amp;lt;commands&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;ul&gt;
&lt;li&gt;&lt;code&gt;@&lt;/code&gt; 加在命令前面不输出命令&lt;/li&gt;
&lt;li&gt;多条 &lt;code&gt;&amp;lt;commands&lt;/code&gt; 之间不会互相共享环境变量&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c"&gt;var-lost:&lt;/span&gt;
&lt;span class="c"&gt;    export foo=bar&lt;/span&gt;
&lt;span class="c"&gt;    echo &amp;quot;foo=[$$foo]&amp;quot; # 这里 $foo 不会被赋值上 bar，因为上下是隔离的环境&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;ul&gt;
&lt;li&gt;共享的方法是写到一行去&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c"&gt;var-kept:&lt;/span&gt;
&lt;span class="c"&gt;    export foo=bar; \&lt;/span&gt;
&lt;span class="c"&gt;    echo &amp;quot;foo=[$$foo]&amp;quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;ul&gt;
&lt;li&gt;依赖可以是文件名，target 只会在所有依赖有变动的时候才会运行。例如 &lt;code&gt;source.txt&lt;/code&gt; 是依赖，如果文件时间戳没变，依赖它的 target 就不会被运行&lt;/li&gt;
&lt;li&gt;每个文件都写依赖不现实，可以在 commands 中用 &lt;code&gt;$@&lt;/code&gt; 表示当前 target, &lt;code&gt;$&amp;lt;&lt;/code&gt; 表示第一个依赖 target, &lt;code&gt;$^&lt;/code&gt; 表示所有依赖 targets，&lt;code&gt;$?&lt;/code&gt; 表示更新的依赖列表，&lt;code&gt;$$&lt;/code&gt; 是 $ 的转义，&lt;code&gt;$*&lt;/code&gt; 是 % 的引用。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.PHONY&lt;/code&gt; 依赖所有文件&lt;/li&gt;
&lt;/ul&gt;</content></entry><entry><title>Tink - NPM Replacement</title><link href="https://www.soasme.com/techshack.weekly/verses/1c351c59-7377-45a1-8d59-8e6d649d44f1.html" rel="alternate"></link><published>2018-09-15T00:00:00+00:00</published><updated>2018-09-15T00:00:00+00:00</updated><author><name>Ju Lin</name></author><id>tag:www.soasme.com,2018-09-15:/techshack.weekly/verses/1c351c59-7377-45a1-8d59-8e6d649d44f1.html</id><summary type="html">&lt;p&gt;&lt;a href="https://blog.npmjs.org/post/178027064160/next-generation-package-management"&gt;查看原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文介绍了 Tink - 下一代 npm 的一种可能的替代品。运行 tink 不会像 npm install 一样把依赖安装到 &lt;code&gt;node_modules&lt;/code&gt;, 而是缓存依赖的 hash，当不满足时才会下载并加载。&lt;/p&gt;
&lt;p&gt;它仍然可以跟 &lt;code&gt;node_modules&lt;/code&gt; 并存，并优先使用 &lt;code&gt;node_modules&lt;/code&gt; 而非缓存的依赖（为了更方便调试）&lt;/p&gt;</summary><content type="html">&lt;p&gt;&lt;a href="https://blog.npmjs.org/post/178027064160/next-generation-package-management"&gt;查看原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文介绍了 Tink - 下一代 npm 的一种可能的替代品。运行 tink 不会像 npm install 一样把依赖安装到 &lt;code&gt;node_modules&lt;/code&gt;, 而是缓存依赖的 hash，当不满足时才会下载并加载。&lt;/p&gt;
&lt;p&gt;它仍然可以跟 &lt;code&gt;node_modules&lt;/code&gt; 并存，并优先使用 &lt;code&gt;node_modules&lt;/code&gt; 而非缓存的依赖（为了更方便调试）&lt;/p&gt;</content></entry><entry><title>Python 代码上线检查清单</title><link href="https://www.soasme.com/techshack.weekly/verses/4334edb6-ac35-4d24-b414-5a70209ce2b9.html" rel="alternate"></link><published>2018-09-13T00:00:00+00:00</published><updated>2018-09-13T00:00:00+00:00</updated><author><name>Ju Lin</name></author><id>tag:www.soasme.com,2018-09-13:/techshack.weekly/verses/4334edb6-ac35-4d24-b414-5a70209ce2b9.html</id><summary type="html">&lt;p&gt;&lt;a href="https://twitter.com/raymondh/status/1039940537124413440"&gt;查看原文&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;简化代码&lt;/li&gt;
&lt;li&gt;类型检查&lt;/li&gt;
&lt;li&gt;加上 repr, copy, pickle 支持（应该是为了更好的排查故障，排除潜在 bug&lt;/li&gt;
&lt;li&gt;检查循环引用（会造成死循环&lt;/li&gt;
&lt;li&gt;认真思考并发&lt;/li&gt;
&lt;li&gt;处理一些奇怪的用例&lt;/li&gt;
&lt;li&gt;吸取教训&lt;/li&gt;
&lt;li&gt;回到第一条&lt;/li&gt;
&lt;/ul&gt;</summary><content type="html">&lt;p&gt;&lt;a href="https://twitter.com/raymondh/status/1039940537124413440"&gt;查看原文&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;简化代码&lt;/li&gt;
&lt;li&gt;类型检查&lt;/li&gt;
&lt;li&gt;加上 repr, copy, pickle 支持（应该是为了更好的排查故障，排除潜在 bug&lt;/li&gt;
&lt;li&gt;检查循环引用（会造成死循环&lt;/li&gt;
&lt;li&gt;认真思考并发&lt;/li&gt;
&lt;li&gt;处理一些奇怪的用例&lt;/li&gt;
&lt;li&gt;吸取教训&lt;/li&gt;
&lt;li&gt;回到第一条&lt;/li&gt;
&lt;/ul&gt;</content></entry><entry><title>系统编程是什么</title><link href="https://www.soasme.com/techshack.weekly/verses/9d216127-3342-4a25-9c94-cc5528618ab0.html" rel="alternate"></link><published>2018-09-13T00:00:00+00:00</published><updated>2018-09-13T00:00:00+00:00</updated><author><name>Ju Lin</name></author><id>tag:www.soasme.com,2018-09-13:/techshack.weekly/verses/9d216127-3342-4a25-9c94-cc5528618ab0.html</id><summary type="html">&lt;p&gt;&lt;a href="http://willcrichton.net/notes/systems-programming/"&gt;查看原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文探讨了大家常说的“系统编程”，或者“底层”。早期的系统编程主要是指把一系列程序集成起来。在现代，这个词汇的语义已经有了不少变化，会更接近于 low-level programming。&lt;/p&gt;</summary><content type="html">&lt;p&gt;&lt;a href="http://willcrichton.net/notes/systems-programming/"&gt;查看原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文探讨了大家常说的“系统编程”，或者“底层”。早期的系统编程主要是指把一系列程序集成起来。在现代，这个词汇的语义已经有了不少变化，会更接近于 low-level programming。&lt;/p&gt;</content></entry><entry><title>使用 Terraform 快速启动 EKS 服务</title><link href="https://www.soasme.com/techshack.weekly/verses/3f1c333f-dd2a-4032-bfd8-262ab84e9f6f.html" rel="alternate"></link><published>2018-09-12T00:00:00+00:00</published><updated>2018-09-12T00:00:00+00:00</updated><author><name>Ju Lin</name></author><id>tag:www.soasme.com,2018-09-12:/techshack.weekly/verses/3f1c333f-dd2a-4032-bfd8-262ab84e9f6f.html</id><summary type="html">&lt;p&gt;&lt;a href="https://www.terraform.io/docs/providers/aws/guides/eks-getting-started.html"&gt;查看原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文介绍了如何使用 Terraform 启动 AWS EKS 服务。目前 AWS 提供了 Kubernetes 1.10 的服务，运行在 us-west-2, us-east-1, eu-west-1 这三个地区。在使用 Terraform 之前，你需要一个 AWS 账号，以及已经在本地配置好了 &lt;code&gt;aws configure&lt;/code&gt; 之类的信息。&lt;/p&gt;
&lt;p&gt;第一步：创建 VPC，配置 vpc, 子网，路由表，互联网网关。其中子网存放在某个可用区中，可通过 &lt;code&gt;${data.aws_availability_zones.available.names[count.index]}&lt;/code&gt; 获得当前 AZ。如果有私有/公开两种子网，可以自己稍微改造下 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;&lt;a href="https://www.terraform.io/docs/providers/aws/guides/eks-getting-started.html"&gt;查看原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文介绍了如何使用 Terraform 启动 AWS EKS 服务。目前 AWS 提供了 Kubernetes 1.10 的服务，运行在 us-west-2, us-east-1, eu-west-1 这三个地区。在使用 Terraform 之前，你需要一个 AWS 账号，以及已经在本地配置好了 &lt;code&gt;aws configure&lt;/code&gt; 之类的信息。&lt;/p&gt;
&lt;p&gt;第一步：创建 VPC，配置 vpc, 子网，路由表，互联网网关。其中子网存放在某个可用区中，可通过 &lt;code&gt;${data.aws_availability_zones.available.names[count.index]}&lt;/code&gt; 获得当前 AZ。如果有私有/公开两种子网，可以自己稍微改造下，适当添加进 eip, nat_gateway 等配置信息（这里面没有写，可以自己探索一下）。&lt;/p&gt;
&lt;p&gt;第二步，创建 iam role，以及 在上一步 vpc 里面建一个安全组，允许稍后 vpc 中的 ec2 实例可以访问到 k8s master api。这个安全组默认就允许所有流量就可以了。前面的 iam role 可以用 aws 默认提供的 &lt;code&gt;arn:aws:iam::aws:policy/AmazonEKSClusterPolicy&lt;/code&gt; / &lt;code&gt;arn:aws:iam::aws:policy/AmazonEKSServicePolicy&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;第三步，导出 kubectl 配置，新建 iam role, 这次是给 k8s workloads 建 ec2 的 iam。继续创建 安全组，和 AutoScaling Group。&lt;/p&gt;
&lt;p&gt;接下里，初始化 ec2 实例的配置，加入 eks。&lt;/p&gt;
&lt;p&gt;总体来说，Terraform 的使用体验比一步一步在 UI Console 里面点来点去好太多了，推荐使用。&lt;/p&gt;</content></entry><entry><title>CLI 工具推荐 2018.37</title><link href="https://www.soasme.com/techshack.weekly/verses/870580f0-4b1f-48d0-96ac-7f90929ac2cc.html" rel="alternate"></link><published>2018-09-12T00:00:00+00:00</published><updated>2018-09-12T00:00:00+00:00</updated><author><name>Ju Lin</name></author><id>tag:www.soasme.com,2018-09-12:/techshack.weekly/verses/870580f0-4b1f-48d0-96ac-7f90929ac2cc.html</id><summary type="html">&lt;p&gt;&lt;a href="https://remysharp.com/2018/08/23/cli-improved"&gt;查看原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文列出了一些作者认为会改进工作流的命令行工具：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;bat &amp;gt; cat: 更好的对代码文件的输出&lt;/li&gt;
&lt;li&gt;prettyping &amp;gt; ping: 更直观的 ping 结果&lt;/li&gt;
&lt;li&gt;fzf &amp;gt; ctrl+r: 模糊匹配&lt;/li&gt;
&lt;li&gt;htop &amp;gt; top: 更全的系统当前性能&lt;/li&gt;
&lt;li&gt;diff-so-fancy &amp;gt; diff: 除了颜色，还有变更部分的高亮&lt;/li&gt;
&lt;li&gt;fd &amp;gt; find: 更简单的操作&lt;/li&gt;
&lt;li&gt;ncdu &amp;gt; du: 更简单的操作&lt;/li&gt;
&lt;li&gt;tldr &amp;gt; man: 懒人更想用 cheat sheet 替代查 man&lt;/li&gt;
&lt;li&gt;ack/ag &amp;gt; grep: 更快更好用的 api&lt;/li&gt;
&lt;li&gt;jq &amp;gt; grep: 处理 JSON 的利器&lt;/li&gt;
&lt;/ul&gt;</summary><content type="html">&lt;p&gt;&lt;a href="https://remysharp.com/2018/08/23/cli-improved"&gt;查看原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文列出了一些作者认为会改进工作流的命令行工具：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;bat &amp;gt; cat: 更好的对代码文件的输出&lt;/li&gt;
&lt;li&gt;prettyping &amp;gt; ping: 更直观的 ping 结果&lt;/li&gt;
&lt;li&gt;fzf &amp;gt; ctrl+r: 模糊匹配&lt;/li&gt;
&lt;li&gt;htop &amp;gt; top: 更全的系统当前性能&lt;/li&gt;
&lt;li&gt;diff-so-fancy &amp;gt; diff: 除了颜色，还有变更部分的高亮&lt;/li&gt;
&lt;li&gt;fd &amp;gt; find: 更简单的操作&lt;/li&gt;
&lt;li&gt;ncdu &amp;gt; du: 更简单的操作&lt;/li&gt;
&lt;li&gt;tldr &amp;gt; man: 懒人更想用 cheat sheet 替代查 man&lt;/li&gt;
&lt;li&gt;ack/ag &amp;gt; grep: 更快更好用的 api&lt;/li&gt;
&lt;li&gt;jq &amp;gt; grep: 处理 JSON 的利器&lt;/li&gt;
&lt;/ul&gt;</content></entry><entry><title>Nox - 多 Python 环境的自动化测试工具</title><link href="https://www.soasme.com/techshack.weekly/verses/d7a837da-f547-4f42-a2dd-ef929dcedf8f.html" rel="alternate"></link><published>2018-09-12T00:00:00+00:00</published><updated>2018-09-12T00:00:00+00:00</updated><author><name>Ju Lin</name></author><id>tag:www.soasme.com,2018-09-12:/techshack.weekly/verses/d7a837da-f547-4f42-a2dd-ef929dcedf8f.html</id><summary type="html">&lt;p&gt;&lt;a href="https://nox.thea.codes/en/latest/"&gt;查看原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Nox 是一个 Tox 的替代品，它提供了 Tox 差不多的功能，但是可以用普通 Python 代码来做配置。&lt;/p&gt;
&lt;p&gt;核心概念是 session，每个 session 都会新建 virtualenv，选择合适的 python 解释器，安装依赖，执行命令。&lt;/p&gt;</summary><content type="html">&lt;p&gt;&lt;a href="https://nox.thea.codes/en/latest/"&gt;查看原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Nox 是一个 Tox 的替代品，它提供了 Tox 差不多的功能，但是可以用普通 Python 代码来做配置。&lt;/p&gt;
&lt;p&gt;核心概念是 session，每个 session 都会新建 virtualenv，选择合适的 python 解释器，安装依赖，执行命令。&lt;/p&gt;</content></entry><entry><title>gPRC with JSON</title><link href="https://www.soasme.com/techshack.weekly/verses/3a2012e0-475d-4bab-977d-df23ae8a85f2.html" rel="alternate"></link><published>2018-09-10T00:00:00+00:00</published><updated>2018-09-10T00:00:00+00:00</updated><author><name>Ju Lin</name></author><id>tag:www.soasme.com,2018-09-10:/techshack.weekly/verses/3a2012e0-475d-4bab-977d-df23ae8a85f2.html</id><summary type="html">&lt;p&gt;&lt;a href="https://grpc.io/blog/grpc-with-json"&gt;查看原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文介绍了如何混用 gRPC 和 JSON。尽管你可以用 Protobuf，gRPC 其实是编码无关的 RPC 工具，例如本文，你可以用 JSON 作为序列和反序列化层。为什么要这么做呢？因为有时候你不需要所有 gRPC 的特性，可能想跟自己的项目更多结合一些，但又想拥有某些 gRPC 的好处。&lt;/p&gt;
&lt;p&gt;本文使用了 Gson: 允许你可以提供类，将实例和JSON数据互转。&lt;/p&gt;
&lt;p&gt;Service: 服务就是方法的集合(a Service is a collection of Methods.)。一个方法要提供名字，Marshaller（如何解码请求，如何编码响应）。&lt;/p&gt;
&lt;p&gt;你要做的事情是&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;提供一个 Marshaller 实现，内部编码解码 JSON 数据到类实例。&lt;/li&gt;
&lt;li&gt;注册方法的时候，也登记上自定义的 Marshaller …&lt;/li&gt;&lt;/ul&gt;</summary><content type="html">&lt;p&gt;&lt;a href="https://grpc.io/blog/grpc-with-json"&gt;查看原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文介绍了如何混用 gRPC 和 JSON。尽管你可以用 Protobuf，gRPC 其实是编码无关的 RPC 工具，例如本文，你可以用 JSON 作为序列和反序列化层。为什么要这么做呢？因为有时候你不需要所有 gRPC 的特性，可能想跟自己的项目更多结合一些，但又想拥有某些 gRPC 的好处。&lt;/p&gt;
&lt;p&gt;本文使用了 Gson: 允许你可以提供类，将实例和JSON数据互转。&lt;/p&gt;
&lt;p&gt;Service: 服务就是方法的集合(a Service is a collection of Methods.)。一个方法要提供名字，Marshaller（如何解码请求，如何编码响应）。&lt;/p&gt;
&lt;p&gt;你要做的事情是&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;提供一个 Marshaller 实现，内部编码解码 JSON 数据到类实例。&lt;/li&gt;
&lt;li&gt;注册方法的时候，也登记上自定义的 Marshaller。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;其他使用上和别的  gRPC 没有区别。&lt;/p&gt;
&lt;p&gt;总之，如果你想用 gRPC 做 RPC 框架，又不想用 Protobuf，那你可以尝试一下用这种方法接上别的序列化协议。&lt;/p&gt;</content></entry><entry><title>Python 3 Type hints cheat sheet</title><link href="https://www.soasme.com/techshack.weekly/verses/40388395-5410-4e42-8986-436627fd0803.html" rel="alternate"></link><published>2018-09-10T00:00:00+00:00</published><updated>2018-09-10T00:00:00+00:00</updated><author><name>Ju Lin</name></author><id>tag:www.soasme.com,2018-09-10:/techshack.weekly/verses/40388395-5410-4e42-8986-436627fd0803.html</id><summary type="html">&lt;p&gt;&lt;a href="https://mypy.readthedocs.io/en/latest/cheat_sheet_py3.html"&gt;查看原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文是关于如何给 Python 3 代码写类型注解的 cheat sheet。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;赋值：&lt;code&gt;a: int = 1&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;声明：&lt;code&gt;a: int&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;内建类型：&lt;code&gt;x: int&lt;/code&gt;, &lt;code&gt;x: float&lt;/code&gt;, &lt;code&gt;x: bool&lt;/code&gt;, &lt;code&gt;x: str&lt;/code&gt;, &lt;code&gt;x: bytes&lt;/code&gt;, &lt;code&gt;x: List[int]&lt;/code&gt;, &lt;code&gt;x: Set[int]&lt;/code&gt;, &lt;code&gt;x: Dict[str, float]&lt;/code&gt;, &lt;code&gt;x: Tuple[int, str, float]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;可能为空：&lt;code&gt;x: Optional[str]&lt;/code&gt; &lt;/li&gt;
&lt;li&gt;函数：&lt;code&gt;def a(n: int) -&amp;gt; str …&lt;/code&gt;&lt;/li&gt;&lt;/ul&gt;</summary><content type="html">&lt;p&gt;&lt;a href="https://mypy.readthedocs.io/en/latest/cheat_sheet_py3.html"&gt;查看原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文是关于如何给 Python 3 代码写类型注解的 cheat sheet。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;赋值：&lt;code&gt;a: int = 1&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;声明：&lt;code&gt;a: int&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;内建类型：&lt;code&gt;x: int&lt;/code&gt;, &lt;code&gt;x: float&lt;/code&gt;, &lt;code&gt;x: bool&lt;/code&gt;, &lt;code&gt;x: str&lt;/code&gt;, &lt;code&gt;x: bytes&lt;/code&gt;, &lt;code&gt;x: List[int]&lt;/code&gt;, &lt;code&gt;x: Set[int]&lt;/code&gt;, &lt;code&gt;x: Dict[str, float]&lt;/code&gt;, &lt;code&gt;x: Tuple[int, str, float]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;可能为空：&lt;code&gt;x: Optional[str]&lt;/code&gt; &lt;/li&gt;
&lt;li&gt;函数：&lt;code&gt;def a(n: int) -&amp;gt; str:&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;可能为两种类型：&lt;code&gt;x: Union[str, int]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;函数调用只能用位置，不能用名字传入参数：&lt;code&gt;def x(__y: int)&lt;/code&gt;: x(1) 可以，x(__y=1) 会调用失败&lt;/li&gt;
&lt;li&gt;类型 Any 表示什么都可以&lt;/li&gt;
&lt;li&gt;值初始化为 [], 或 None 的时候，最好给出类型注解&lt;/li&gt;
&lt;li&gt;忽略错误或警告：&lt;code&gt;# type: ignore&lt;/code&gt;, 通过写 comment&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cast(List[int], a)&lt;/code&gt; 可以给 mypy 做类型转换，但它不是运行时的检查。&lt;/li&gt;
&lt;li&gt;鸭子类型：&lt;code&gt;Iterable[int]&lt;/code&gt;, &lt;code&gt;Mapping[int, str]&lt;/code&gt;, &lt;code&gt;MutableMapping[int, str]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;类变量：&lt;code&gt;ClassVar[int]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;正则：&lt;code&gt;Match[str]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;文件类似的对象：&lt;code&gt;IO[str]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;使用类的名字声明：&lt;code&gt;def f(foo: 'MyClass') -&amp;gt; int&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;</content></entry><entry><title>Cost of CORS Request on SPA</title><link href="https://www.soasme.com/techshack.weekly/verses/46d928b1-29bf-41d5-9fc7-ca84588703bb.html" rel="alternate"></link><published>2018-09-10T00:00:00+00:00</published><updated>2018-09-10T00:00:00+00:00</updated><author><name>Ju Lin</name></author><id>tag:www.soasme.com,2018-09-10:/techshack.weekly/verses/46d928b1-29bf-41d5-9fc7-ca84588703bb.html</id><summary type="html">&lt;p&gt;&lt;a href="https://medium.com/@ankur_anand/the-terrible-performance-cost-of-cors-api-on-the-single-page-application-spa-6fcf71e50147"&gt;查看原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文介绍了CORS 请求可能会严重降低单页应用（SPA）的性能。每个 CORS 请求默认会发出两个请求：&lt;code&gt;OPTIONS&lt;/code&gt; / 以及真正的请求，前者查看是否被允许发起跨域请求。尽管你可以用 &lt;code&gt;Access-Control-Max-Age&lt;/code&gt; 把前面的 preflight request 缓存住，但是这个缓存是针对单个 URL 的，而不是跟着域名走。假设你有这样的 URL: &lt;code&gt;/users/report/:id&lt;/code&gt;, 那这类请求其实没有被缓存多少，每次你要查看一个新的用户的数据，你都要发出至少两个请求。&lt;/p&gt;</summary><content type="html">&lt;p&gt;&lt;a href="https://medium.com/@ankur_anand/the-terrible-performance-cost-of-cors-api-on-the-single-page-application-spa-6fcf71e50147"&gt;查看原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文介绍了CORS 请求可能会严重降低单页应用（SPA）的性能。每个 CORS 请求默认会发出两个请求：&lt;code&gt;OPTIONS&lt;/code&gt; / 以及真正的请求，前者查看是否被允许发起跨域请求。尽管你可以用 &lt;code&gt;Access-Control-Max-Age&lt;/code&gt; 把前面的 preflight request 缓存住，但是这个缓存是针对单个 URL 的，而不是跟着域名走。假设你有这样的 URL: &lt;code&gt;/users/report/:id&lt;/code&gt;, 那这类请求其实没有被缓存多少，每次你要查看一个新的用户的数据，你都要发出至少两个请求。&lt;/p&gt;</content></entry><entry><title>The Servers Are Burning</title><link href="https://www.soasme.com/techshack.weekly/verses/73ffe7a8-dfe9-4a1c-95a3-04c59dae55e2.html" rel="alternate"></link><published>2018-09-10T00:00:00+00:00</published><updated>2018-09-10T00:00:00+00:00</updated><author><name>Ju Lin</name></author><id>tag:www.soasme.com,2018-09-10:/techshack.weekly/verses/73ffe7a8-dfe9-4a1c-95a3-04c59dae55e2.html</id><summary type="html">&lt;p&gt;&lt;a href="https://logicmag.io/05-the-servers-are-burning/"&gt;查看原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文作者认为软件 Bug 无法避免，成熟稳重的工程师比起擅长写代码，应该跟擅长在程序挂了的时候快速找出问题在哪里。尽早将软件部署到真实的网站流量面前，如果有错就快速响应打 Patch 或者回滚。&lt;/p&gt;</summary><content type="html">&lt;p&gt;&lt;a href="https://logicmag.io/05-the-servers-are-burning/"&gt;查看原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文作者认为软件 Bug 无法避免，成熟稳重的工程师比起擅长写代码，应该跟擅长在程序挂了的时候快速找出问题在哪里。尽早将软件部署到真实的网站流量面前，如果有错就快速响应打 Patch 或者回滚。&lt;/p&gt;</content></entry><entry><title>Techshack Weekly 第 0023 期</title><link href="https://www.soasme.com/techshack.weekly/issues/0023.html" rel="alternate"></link><published>2018-09-09T00:00:00+00:00</published><updated>2018-09-09T00:00:00+00:00</updated><author><name>Ju Lin</name></author><id>tag:www.soasme.com,2018-09-09:/techshack.weekly/issues/0023.html</id><summary type="html">&lt;p&gt;这是 Techshack Weekly 第 0023 期。本期有趣的文章：Airbnb 架构，Google 使用 Typescript，GitHub 废弃使用 jQuery，Latency Heat Map，有趣的工具：Py-spy。&lt;/p&gt;</summary><content type="html">&lt;p&gt;这是 Techshack Weekly 第 0023 期。本期有趣的文章：Airbnb 架构，Google 使用 Typescript，GitHub 废弃使用 jQuery，Latency Heat Map，有趣的工具：Py-spy。 &lt;a href="https://www.soasme.com/techshack.weekly/issues/0023.html"&gt;前往查看&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;System Design&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://www.soasme.com/techshack.weekly/verses/9edb78fc-a1fe-4812-a55d-5ba3c6632fa2.html"&gt;Airbnb 架构概览&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Engineering&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="https://www.soasme.com/techshack.weekly/verses/f80b32b8-e451-43b4-ac35-dfe822ddb1af.html"&gt;Stop future proofing software&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="https://www.soasme.com/techshack.weekly/verses/c62b3211-d5a3-4240-9147-6e5528373161.html"&gt;Typescript at Google&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="https://www.soasme.com/techshack.weekly/verses/c89868b5-c367-4acf-b4c3-5b2c911f3347.html"&gt;Removing jQuery from GitHub.com frontend&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Performance&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://www.soasme.com/techshack.weekly/verses/477cfe9c-c9ec-4c6d-a9fe-9b1453cef798.html"&gt;Latency Heat Maps&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Tools&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://www.soasme.com/techshack.weekly/verses/479a10d0-70ea-4a88-948f-7c2e30ea1067.html"&gt;Kitty - GPU based terminal emulator&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Python&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://www.soasme.com/techshack.weekly/verses/b98bdb44-cc8c-4147-ae26-eb9f53d6f5a6.html"&gt;Py-Spy - A sampling profiler for Python programs&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Data Science&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="https://www.soasme.com/techshack.weekly/verses/1aff11c8-2707-4a44-b81b-b9ba61d78682.html"&gt;Pandas Overview&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="https://www.soasme.com/techshack.weekly/verses/a700e303-4297-4042-9941-2545232b41cd.html"&gt;Pandas 10 分钟入门&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Language&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://www.soasme.com/techshack.weekly/verses/fb93912a-7715-4d82-95b4-e56e61f3b83a.html"&gt;How the Go runtime implements maps efficiently&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content></entry><entry><title>Kitty - GPU based terminal emulator</title><link href="https://www.soasme.com/techshack.weekly/verses/479a10d0-70ea-4a88-948f-7c2e30ea1067.html" rel="alternate"></link><published>2018-09-08T00:00:00+00:00</published><updated>2018-09-08T00:00:00+00:00</updated><author><name>Ju Lin</name></author><id>tag:www.soasme.com,2018-09-08:/techshack.weekly/verses/479a10d0-70ea-4a88-948f-7c2e30ea1067.html</id><summary type="html">&lt;p&gt;&lt;a href="https://sw.kovidgoyal.net/kitty/"&gt;查看原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Kitty 是一个终端模拟器，使用 GPU / OpenGL 加速渲染，非常适合键盘流用户。它核心用 C 写，扩展可以用 Python 写。&lt;/p&gt;</summary><content type="html">&lt;p&gt;&lt;a href="https://sw.kovidgoyal.net/kitty/"&gt;查看原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Kitty 是一个终端模拟器，使用 GPU / OpenGL 加速渲染，非常适合键盘流用户。它核心用 C 写，扩展可以用 Python 写。&lt;/p&gt;</content></entry><entry><title>Removing jQuery from GitHub.com frontend</title><link href="https://www.soasme.com/techshack.weekly/verses/c89868b5-c367-4acf-b4c3-5b2c911f3347.html" rel="alternate"></link><published>2018-09-08T00:00:00+00:00</published><updated>2018-09-08T00:00:00+00:00</updated><author><name>Ju Lin</name></author><id>tag:www.soasme.com,2018-09-08:/techshack.weekly/verses/c89868b5-c367-4acf-b4c3-5b2c911f3347.html</id><summary type="html">&lt;p&gt;&lt;a href="https://githubengineering.com/removing-jquery-from-github-frontend/"&gt;查看原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文介绍了 GitHub 如何将 jQuery 的依赖一点一点去掉。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;以前：jQuery 在 2007 年的时候几乎是标配，就算不主动用，很多库也依赖它。&lt;/li&gt;
&lt;li&gt;近些年: jQuery 的特性很多都融进了现代 JS 语言和浏览器中。&lt;/li&gt;
&lt;li&gt;取代的原因是 jQuery 的写法不太能传达出代码的原始意图，也很容易默默吞掉错误。&lt;/li&gt;
&lt;li&gt;取代品：直接用 JS：https://developer.mozilla.org/en-US/docs/Web/JavaScript&lt;/li&gt;
&lt;li&gt;如何取代：&lt;ul&gt;
&lt;li&gt;仓库埋 metric 进去，可以查看 jQuery usage&lt;/li&gt;
&lt;li&gt;lint 把有诸如 &lt;code&gt;$.ajax&lt;/code&gt; 之类的新代码直接标为构建失败&lt;/li&gt;
&lt;li&gt;有依赖库的，保持接口稳定的同时，替换掉实现，使用 JS 原生的特性 …&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;</summary><content type="html">&lt;p&gt;&lt;a href="https://githubengineering.com/removing-jquery-from-github-frontend/"&gt;查看原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文介绍了 GitHub 如何将 jQuery 的依赖一点一点去掉。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;以前：jQuery 在 2007 年的时候几乎是标配，就算不主动用，很多库也依赖它。&lt;/li&gt;
&lt;li&gt;近些年: jQuery 的特性很多都融进了现代 JS 语言和浏览器中。&lt;/li&gt;
&lt;li&gt;取代的原因是 jQuery 的写法不太能传达出代码的原始意图，也很容易默默吞掉错误。&lt;/li&gt;
&lt;li&gt;取代品：直接用 JS：https://developer.mozilla.org/en-US/docs/Web/JavaScript&lt;/li&gt;
&lt;li&gt;如何取代：&lt;ul&gt;
&lt;li&gt;仓库埋 metric 进去，可以查看 jQuery usage&lt;/li&gt;
&lt;li&gt;lint 把有诸如 &lt;code&gt;$.ajax&lt;/code&gt; 之类的新代码直接标为构建失败&lt;/li&gt;
&lt;li&gt;有依赖库的，保持接口稳定的同时，替换掉实现，使用 JS 原生的特性。&lt;/li&gt;
&lt;li&gt;取消老浏览器的支持。&lt;/li&gt;
&lt;li&gt;用上 polyfills&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;</content></entry><entry><title>Py-Spy - A sampling profiler for Python programs</title><link href="https://www.soasme.com/techshack.weekly/verses/b98bdb44-cc8c-4147-ae26-eb9f53d6f5a6.html" rel="alternate"></link><published>2018-09-07T00:00:00+00:00</published><updated>2018-09-07T00:00:00+00:00</updated><author><name>Ju Lin</name></author><id>tag:www.soasme.com,2018-09-07:/techshack.weekly/verses/b98bdb44-cc8c-4147-ae26-eb9f53d6f5a6.html</id><summary type="html">&lt;p&gt;&lt;a href="https://github.com/benfred/py-spy"&gt;查看原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Py-Spy 这个工具是个 Python Profiler，它可以在不重启 Python 程序的前提下得到耗时函数及其调用时间，并将其以 top-like 的形式展示出来。&lt;/p&gt;
&lt;p&gt;它的特色是：低 overhead，用 Rust 写的核心部分，不需要侵入 Python 进程。无侵入这个特性也是它有别于标准库甚至其他 profiler 的好特性。你不需要修改任何一行项目代码就能用它。pyflame 倒是可以，不过尚不支持 Python 3.7 及非 Linux 的 OS。&lt;/p&gt;
&lt;p&gt;工作原理：通过读取进程内存：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;linux: &lt;a href="http://man7.org/linux/man-pages/man2/process_vm_readv.2.html"&gt;process_vm_readv&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;osx: &lt;a href="https://developer.apple.com/documentation/kernel/1585350-vm_read?language=objc"&gt;vm_read&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;windows: &lt;a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ms680553.aspx"&gt;ReadProcessMemory&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在内存中，全局变量 PyInterpreterState 可以拿到解释器运行着的所有线程，再遍历每个线程拿到 PyFrameObject 中的调用栈。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://github.com/benfred/py-spy/blob/master/images/console_viewer.gif"&gt;&lt;/p&gt;</summary><content type="html">&lt;p&gt;&lt;a href="https://github.com/benfred/py-spy"&gt;查看原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Py-Spy 这个工具是个 Python Profiler，它可以在不重启 Python 程序的前提下得到耗时函数及其调用时间，并将其以 top-like 的形式展示出来。&lt;/p&gt;
&lt;p&gt;它的特色是：低 overhead，用 Rust 写的核心部分，不需要侵入 Python 进程。无侵入这个特性也是它有别于标准库甚至其他 profiler 的好特性。你不需要修改任何一行项目代码就能用它。pyflame 倒是可以，不过尚不支持 Python 3.7 及非 Linux 的 OS。&lt;/p&gt;
&lt;p&gt;工作原理：通过读取进程内存：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;linux: &lt;a href="http://man7.org/linux/man-pages/man2/process_vm_readv.2.html"&gt;process_vm_readv&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;osx: &lt;a href="https://developer.apple.com/documentation/kernel/1585350-vm_read?language=objc"&gt;vm_read&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;windows: &lt;a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ms680553.aspx"&gt;ReadProcessMemory&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在内存中，全局变量 PyInterpreterState 可以拿到解释器运行着的所有线程，再遍历每个线程拿到 PyFrameObject 中的调用栈。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://github.com/benfred/py-spy/blob/master/images/console_viewer.gif"&gt;&lt;/p&gt;</content></entry><entry><title>Typescript at Google</title><link href="https://www.soasme.com/techshack.weekly/verses/c62b3211-d5a3-4240-9147-6e5528373161.html" rel="alternate"></link><published>2018-09-07T00:00:00+00:00</published><updated>2018-09-07T00:00:00+00:00</updated><author><name>Ju Lin</name></author><id>tag:www.soasme.com,2018-09-07:/techshack.weekly/verses/c62b3211-d5a3-4240-9147-6e5528373161.html</id><summary type="html">&lt;p&gt;&lt;a href="http://neugierig.org/software/blog/2018/09/typescript-at-google.html"&gt;查看原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文介绍了 Typescript 逐渐在 Google 产品线被使用的现状。Google 在 JS 很早期的时候就在探索如何编写大型前端程序，并归纳出 Closure 这个框架。时过境迁，这套框架可能目前也就 Google 在用，或者某些用了的公司还需要找 ex-googler 来维护。Closure 本质是一个静态类型的 JS 方言，问题主要在于常年使用估计埋了不少臭虫进去。现代 JS 产出了 UMD, AMD, CommonJS，ES6 甚至也有自己的模块系统，npm，webpack 也逐渐推广开。作者所在的组就在尝试将这些东西引入现有代码仓库。迁移也是慢慢地迁移，而不是从头写一遍。现在好些个 Google Products 都已经有慢慢用上了 TypeScript 了。&lt;/p&gt;</summary><content type="html">&lt;p&gt;&lt;a href="http://neugierig.org/software/blog/2018/09/typescript-at-google.html"&gt;查看原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文介绍了 Typescript 逐渐在 Google 产品线被使用的现状。Google 在 JS 很早期的时候就在探索如何编写大型前端程序，并归纳出 Closure 这个框架。时过境迁，这套框架可能目前也就 Google 在用，或者某些用了的公司还需要找 ex-googler 来维护。Closure 本质是一个静态类型的 JS 方言，问题主要在于常年使用估计埋了不少臭虫进去。现代 JS 产出了 UMD, AMD, CommonJS，ES6 甚至也有自己的模块系统，npm，webpack 也逐渐推广开。作者所在的组就在尝试将这些东西引入现有代码仓库。迁移也是慢慢地迁移，而不是从头写一遍。现在好些个 Google Products 都已经有慢慢用上了 TypeScript 了。&lt;/p&gt;</content></entry><entry><title>Pandas Overview</title><link href="https://www.soasme.com/techshack.weekly/verses/1aff11c8-2707-4a44-b81b-b9ba61d78682.html" rel="alternate"></link><published>2018-09-05T00:00:00+00:00</published><updated>2018-09-05T00:00:00+00:00</updated><author><name>Ju Lin</name></author><id>tag:www.soasme.com,2018-09-05:/techshack.weekly/verses/1aff11c8-2707-4a44-b81b-b9ba61d78682.html</id><summary type="html">&lt;p&gt;&lt;a href="http://pandas.pydata.org/pandas-docs/stable/overview.html"&gt;查看原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Pandas 是一个数据结构的操作库，核心数据结构是 DataFrame，DataFrame 是 Series 的容器，Series 是 scalar 的容器。你可以用 dictionary-like 的语法来操作数据。这类数据主要用来处理多维数据，例如时间序列数据什么的。&lt;/p&gt;
&lt;p&gt;处理数据的时候，比较推荐 immutable，即保留原始数据不变生成新数据，尽管 Pandas  的所有数据结构都是 value-mutable 的。&lt;/p&gt;</summary><content type="html">&lt;p&gt;&lt;a href="http://pandas.pydata.org/pandas-docs/stable/overview.html"&gt;查看原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Pandas 是一个数据结构的操作库，核心数据结构是 DataFrame，DataFrame 是 Series 的容器，Series 是 scalar 的容器。你可以用 dictionary-like 的语法来操作数据。这类数据主要用来处理多维数据，例如时间序列数据什么的。&lt;/p&gt;
&lt;p&gt;处理数据的时候，比较推荐 immutable，即保留原始数据不变生成新数据，尽管 Pandas  的所有数据结构都是 value-mutable 的。&lt;/p&gt;</content></entry><entry><title>Airbnb 架构概览</title><link href="https://www.soasme.com/techshack.weekly/verses/9edb78fc-a1fe-4812-a55d-5ba3c6632fa2.html" rel="alternate"></link><published>2018-09-05T00:00:00+00:00</published><updated>2018-09-05T00:00:00+00:00</updated><author><name>Ju Lin</name></author><id>tag:www.soasme.com,2018-09-05:/techshack.weekly/verses/9edb78fc-a1fe-4812-a55d-5ba3c6632fa2.html</id><summary type="html">&lt;p&gt;&lt;a href="https://enqueuezero.com/airbnb-architecture.html"&gt;查看原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文介绍了 Airbnb 的架构，我们可以看到 Airbnb 是 AWS 的重度用户，使用了 EC2, RDS, S3, CloudWatch, EMR(已废弃，目前用的是 Hive+Airflow 的解决方案)。负载均衡使用 Charon。服务发现用 SmarkStack - 可以监听 ZooKeeper 的数据，自动更新到 HAProxy。后端的前台用 Rails，后台服务用 Java 系的框架 Dropwizard。服务治理将用户请求上下文塞入 RPC 请求中，监控服务的 p95_latency, p99_latency。&lt;/p&gt;
&lt;p&gt;可以看到 Airbnb 的架构是从最简单的 Rails MVC 一点一点添砖加瓦搞出来的。&lt;/p&gt;</summary><content type="html">&lt;p&gt;&lt;a href="https://enqueuezero.com/airbnb-architecture.html"&gt;查看原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文介绍了 Airbnb 的架构，我们可以看到 Airbnb 是 AWS 的重度用户，使用了 EC2, RDS, S3, CloudWatch, EMR(已废弃，目前用的是 Hive+Airflow 的解决方案)。负载均衡使用 Charon。服务发现用 SmarkStack - 可以监听 ZooKeeper 的数据，自动更新到 HAProxy。后端的前台用 Rails，后台服务用 Java 系的框架 Dropwizard。服务治理将用户请求上下文塞入 RPC 请求中，监控服务的 p95_latency, p99_latency。&lt;/p&gt;
&lt;p&gt;可以看到 Airbnb 的架构是从最简单的 Rails MVC 一点一点添砖加瓦搞出来的。&lt;/p&gt;</content></entry><entry><title>Pandas 10 分钟入门</title><link href="https://www.soasme.com/techshack.weekly/verses/a700e303-4297-4042-9941-2545232b41cd.html" rel="alternate"></link><published>2018-09-05T00:00:00+00:00</published><updated>2018-09-05T00:00:00+00:00</updated><author><name>Ju Lin</name></author><id>tag:www.soasme.com,2018-09-05:/techshack.weekly/verses/a700e303-4297-4042-9941-2545232b41cd.html</id><summary type="html">&lt;p&gt;&lt;a href="http://pandas.pydata.org/pandas-docs/stable/10min.html"&gt;查看原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文是 pandas 的 10min 入门帖子。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;新建 Series 对象：&lt;code&gt;pd.Series(given_list)&lt;/code&gt;, 如果值为空，用 &lt;code&gt;np.nan&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;新建 DataFrame 对象：&lt;code&gt;pd.DataFrame(given_numpy_array, index=index, columns=given_list)&lt;/code&gt;。稍微复杂一些，第一个参数是 numpy 矩阵，index 是 pandas Index 实例，columns 是列的名字。&lt;/li&gt;
&lt;li&gt;dict 新建 DataFrame 对象：&lt;code&gt;pd.DataFrame({"a": 1., "B": pd_series, ...})&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;查看每一列的类型：&lt;code&gt;df.dtypes …&lt;/code&gt;&lt;/li&gt;&lt;/ul&gt;</summary><content type="html">&lt;p&gt;&lt;a href="http://pandas.pydata.org/pandas-docs/stable/10min.html"&gt;查看原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文是 pandas 的 10min 入门帖子。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;新建 Series 对象：&lt;code&gt;pd.Series(given_list)&lt;/code&gt;, 如果值为空，用 &lt;code&gt;np.nan&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;新建 DataFrame 对象：&lt;code&gt;pd.DataFrame(given_numpy_array, index=index, columns=given_list)&lt;/code&gt;。稍微复杂一些，第一个参数是 numpy 矩阵，index 是 pandas Index 实例，columns 是列的名字。&lt;/li&gt;
&lt;li&gt;dict 新建 DataFrame 对象：&lt;code&gt;pd.DataFrame({"a": 1., "B": pd_series, ...})&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;查看每一列的类型：&lt;code&gt;df.dtypes&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;查看头几列和最后几列：&lt;code&gt;df.head()&lt;/code&gt;, &lt;code&gt;df.tail(3)&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;查看 index: &lt;code&gt;df.index&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;查看 columns：&lt;code&gt;df.columns&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;查看值：&lt;code&gt;df.values&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;快速查看一些基本统计项：&lt;code&gt;df.describe()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;转置矩阵：&lt;code&gt;df.T&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;根据轴排序：&lt;code&gt;df.sort_index(axis=1, ascending=False)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;根据值排序：&lt;code&gt;df.sort_values(by='B')&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;选择一列：&lt;code&gt;df['A']&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Index 切片：&lt;code&gt;df[0:3]&lt;/code&gt;, &lt;code&gt;df['20130102':'20130104']&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;根据 Label 选择一行：&lt;code&gt;df.loc[label]&lt;/code&gt;。Label &lt;/li&gt;
&lt;li&gt;根据多个 Labels 选择多行：&lt;code&gt;df.loc[:, ['a', 'b']]&lt;/code&gt;, 特别的，&lt;code&gt;:&lt;/code&gt; 可以选出所有 Labels，&lt;code&gt;'a':'b'&lt;/code&gt; 可以选出一个连续区间。&lt;/li&gt;
&lt;li&gt;获得 scalar value: &lt;code&gt;df.loc[date, 'A']&lt;/code&gt;, 就相当于提供了行号和列号。另一个语法是：&lt;code&gt;df.at[date, 'A']&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;根据位置获得一行：&lt;code&gt;df.iloc[3]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;根据位置切片或者多值获得多行：&lt;code&gt;df.iloc[3:5,0:2]&lt;/code&gt;, &lt;code&gt;df.iloc[[1,2,3],[0,2]]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;获得 scalar value: &lt;code&gt;df.iloc[1,1]&lt;/code&gt;, 或者 &lt;code&gt;df.iat[1,1]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;根据条件索引检索多行：&lt;code&gt;df[df.A &amp;gt; 0]&lt;/code&gt;, &lt;code&gt;df[df.A.isin(['a', 'b', 'c'])]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;添加新的列：&lt;code&gt;df['F'] = pd.Series([1,2,3,4,5,6], index=df.index)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;设置值：&lt;code&gt;df.at[X, Y] = Z&lt;/code&gt; 或者 &lt;code&gt;df.iat[x, y] = z&lt;/code&gt;, 前者按照 label，后者按照 position&lt;/li&gt;
&lt;li&gt;&lt;code&gt;np.nan&lt;/code&gt; 表示缺失的数据，不会参与计算。可以通过 reindex 获得新的拷贝：&lt;code&gt;df.index(index=index, columns=columns)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;丢弃 nan: &lt;code&gt;df.dropna(how='any')&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;填补 nan: &lt;code&gt;df.fillna(value=5)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;求平均数：&lt;code&gt;df.mean()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;求某一列的平均数：&lt;code&gt;df.mean(1)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;map: &lt;code&gt;df.apply(f)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;求各个值的数量：&lt;code&gt;series.value_counts()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;合并 dataframes: &lt;code&gt;pd.concat([df1, df2, ...])&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Join dataframes: &lt;code&gt;pd.merge(df1, df2, on='key')&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;新加新行：&lt;code&gt;df.append(df.iloc[3], ignore_index=True)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;groupby 一般有三个步骤：分组，处理，合并。例如 &lt;code&gt;df.groupby('A').sum()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;处理 Time Series 数据：df.index 可以是 DateTimeIndex&lt;/li&gt;
&lt;li&gt;分类：`df['grade'] = df['raw_grade'].astype('category')&lt;/li&gt;
&lt;/ul&gt;</content></entry><entry><title>How the Go runtime implements maps efficiently</title><link href="https://www.soasme.com/techshack.weekly/verses/fb93912a-7715-4d82-95b4-e56e61f3b83a.html" rel="alternate"></link><published>2018-09-05T00:00:00+00:00</published><updated>2018-09-05T00:00:00+00:00</updated><author><name>Ju Lin</name></author><id>tag:www.soasme.com,2018-09-05:/techshack.weekly/verses/fb93912a-7715-4d82-95b4-e56e61f3b83a.html</id><summary type="html">&lt;p&gt;&lt;a href="https://dave.cheney.net/2018/05/29/how-the-go-runtime-implements-maps-efficiently-without-generics"&gt;查看原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文介绍了 Go 语言如何实现 Map 的泛型，并对比了 C++ STL 和 Java 的实现。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;HashMap: 一种查询时间复杂度近乎 O(1), 最差为 O(N) 的数据结构，需提供 hash function。O(N) 估计也真是运气背到家了，所有 Key 都哈希碰撞。&lt;ul&gt;
&lt;li&gt;hash function 一定是一个产出固定长度数据的函数&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;C++ STL &lt;code&gt;std::unordered_map&lt;/code&gt; 在编译时就把类型模板编好了，所以编译时就知道每个 map 的 key 类型。&lt;/li&gt;
&lt;li&gt;Java &lt;code&gt;java.util.Hashmap&lt;/code&gt; 要对原子类型做 boxing。由于所有 java …&lt;/li&gt;&lt;/ul&gt;</summary><content type="html">&lt;p&gt;&lt;a href="https://dave.cheney.net/2018/05/29/how-the-go-runtime-implements-maps-efficiently-without-generics"&gt;查看原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文介绍了 Go 语言如何实现 Map 的泛型，并对比了 C++ STL 和 Java 的实现。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;HashMap: 一种查询时间复杂度近乎 O(1), 最差为 O(N) 的数据结构，需提供 hash function。O(N) 估计也真是运气背到家了，所有 Key 都哈希碰撞。&lt;ul&gt;
&lt;li&gt;hash function 一定是一个产出固定长度数据的函数&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;C++ STL &lt;code&gt;std::unordered_map&lt;/code&gt; 在编译时就把类型模板编好了，所以编译时就知道每个 map 的 key 类型。&lt;/li&gt;
&lt;li&gt;Java &lt;code&gt;java.util.Hashmap&lt;/code&gt; 要对原子类型做 boxing。由于所有 java.lang.Object 的子类都有 hashCode 所以它们都可以被塞入 Entry。HashMap 是 Entry 的链表.&lt;/li&gt;
&lt;li&gt;Go 运行时不用 &lt;code&gt;interface{}&lt;/code&gt; 的信息，编译时也不做code generation。它的方案是：将诸如 &lt;code&gt;v := m["key"]&lt;/code&gt; 这样的代码写成 &lt;code&gt;runtime.mapaccess1(m, "key", &amp;amp;v)&lt;/code&gt;, 而 mapaccess1 有如下签名&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="err"&gt;func mapaccess1(t *maptype, h *hmap, key unsafe.Pointer) unsafe.Pointer&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Trick在于 *maptype 这种数据结构，它存储了 key, value 的类型。不像 C++ 完整地生成了多型 map 的实现，Go 只生成了多型的 maptype，这样我们就只需要一份 map 的实现，在运行时读取 maptype 的大小完成 hash 运算。&lt;/p&gt;</content></entry><entry><title>Latency Heat Maps</title><link href="https://www.soasme.com/techshack.weekly/verses/477cfe9c-c9ec-4c6d-a9fe-9b1453cef798.html" rel="alternate"></link><published>2018-09-03T00:00:00+00:00</published><updated>2018-09-03T00:00:00+00:00</updated><author><name>Ju Lin</name></author><id>tag:www.soasme.com,2018-09-03:/techshack.weekly/verses/477cfe9c-c9ec-4c6d-a9fe-9b1453cef798.html</id><summary type="html">&lt;p&gt;&lt;a href="http://www.brendangregg.com/HeatMaps/latency.html"&gt;查看原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;响应时间（response time），也叫延迟（latency），这个指标有很多模式隐藏其中。这篇文章通过 disk I/O latency 介绍了 latency heat map 这种查看性能问题的图表。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;iostat -xz 1&lt;/code&gt; 可以查看 Linux 的平均 latency，我们可以定时采样，画出柱状图（histogram），x 轴是时间，y 轴是 N ms 的 latency。
柱状图可能会由于采样频率不同导致给出不一致的结论，解决办法是使用多种采样频率。如果不改进，那你要看好几张柱状图才能得到结论，有了 heatmap 你就可以把使用不同频率采样得到的结果压在一幅图里面。&lt;/p&gt;
&lt;p&gt;heatmap 本质上是一张三维图表，x y 轴表示两个维度（一般其中一个是时间，另外一个是采样频率），颜色深浅表示第三个维度 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;&lt;a href="http://www.brendangregg.com/HeatMaps/latency.html"&gt;查看原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;响应时间（response time），也叫延迟（latency），这个指标有很多模式隐藏其中。这篇文章通过 disk I/O latency 介绍了 latency heat map 这种查看性能问题的图表。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;iostat -xz 1&lt;/code&gt; 可以查看 Linux 的平均 latency，我们可以定时采样，画出柱状图（histogram），x 轴是时间，y 轴是 N ms 的 latency。
柱状图可能会由于采样频率不同导致给出不一致的结论，解决办法是使用多种采样频率。如果不改进，那你要看好几张柱状图才能得到结论，有了 heatmap 你就可以把使用不同频率采样得到的结果压在一幅图里面。&lt;/p&gt;
&lt;p&gt;heatmap 本质上是一张三维图表，x y 轴表示两个维度（一般其中一个是时间，另外一个是采样频率），颜色深浅表示第三个维度（一般是采样得到的值, 可以是 latency, offset, utilization）。整张图显示了随时间分布的性能指标。&lt;/p&gt;</content></entry><entry><title>Stop future proofing software</title><link href="https://www.soasme.com/techshack.weekly/verses/f80b32b8-e451-43b4-ac35-dfe822ddb1af.html" rel="alternate"></link><published>2018-09-03T00:00:00+00:00</published><updated>2018-09-03T00:00:00+00:00</updated><author><name>Ju Lin</name></author><id>tag:www.soasme.com,2018-09-03:/techshack.weekly/verses/f80b32b8-e451-43b4-ac35-dfe822ddb1af.html</id><summary type="html">&lt;p&gt;&lt;a href="https://medium.com/@george3d6/stop-future-proofing-software-c984cbd65e78"&gt;查看原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文的论点是：诸如 &lt;code&gt;我们需要X，尽管Y目前更好，但一旦未来有Z这个需求，X 会让开发更简单&lt;/code&gt; 这样的观点是不一定是对的。&lt;/p&gt;
&lt;p&gt;那么我们怎么做技术选型呢？作者认为：Less is more。少想未来会怎样，把当下做到易于扩展即可。当下不一定要完美，但能帮你很快适应未来的架构。&lt;/p&gt;</summary><content type="html">&lt;p&gt;&lt;a href="https://medium.com/@george3d6/stop-future-proofing-software-c984cbd65e78"&gt;查看原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文的论点是：诸如 &lt;code&gt;我们需要X，尽管Y目前更好，但一旦未来有Z这个需求，X 会让开发更简单&lt;/code&gt; 这样的观点是不一定是对的。&lt;/p&gt;
&lt;p&gt;那么我们怎么做技术选型呢？作者认为：Less is more。少想未来会怎样，把当下做到易于扩展即可。当下不一定要完美，但能帮你很快适应未来的架构。&lt;/p&gt;</content></entry><entry><title>Techshack Weekly 第 0022 期</title><link href="https://www.soasme.com/techshack.weekly/issues/0022.html" rel="alternate"></link><published>2018-09-02T00:00:00+00:00</published><updated>2018-09-02T00:00:00+00:00</updated><author><name>Ju Lin</name></author><id>tag:www.soasme.com,2018-09-02:/techshack.weekly/issues/0022.html</id><summary type="html">&lt;p&gt;这是 Techshack Weekly 第 0022 期。本期推荐的话题：Papermill, Genie, ActivityPub, Self-hosted Live Streaming 等等。&lt;/p&gt;</summary><content type="html">&lt;p&gt;这是 Techshack Weekly 第 0022 期。本期推荐的话题：Papermill, Genie, ActivityPub, Self-hosted Live Streaming 等等。 &lt;a href="https://www.soasme.com/techshack.weekly/issues/0022.html"&gt;前往查看&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Security&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://www.soasme.com/techshack.weekly/verses/6a5dd0e3-65a9-478b-ac41-5abd421dd42c.html"&gt;SMS 2FA 不安全&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;System Design&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="https://www.soasme.com/techshack.weekly/verses/783c3a7d-226c-4ed0-8835-c817decd74e5.html"&gt;Using Workers To Make Static Sites Dynamic&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="https://www.soasme.com/techshack.weekly/verses/efcff137-1590-4b0a-a8d1-125ed4ff4620.html"&gt;Netflix 使用 Papermill 的实践&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="https://www.soasme.com/techshack.weekly/verses/f11ba211-954c-4c68-8e5c-c162f9dcbdfa.html"&gt;Netflix Data Platform - Genie 3&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Engineering&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="https://www.soasme.com/techshack.weekly/verses/d973549d-65a5-4d2d-a64b-66359cd93b62.html"&gt;Solve Less General Problems&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="https://www.soasme.com/techshack.weekly/verses/309f8cf0-c0e4-440c-a886-a87d43caebd4.html"&gt;Redis is not open core&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="https://www.soasme.com/techshack.weekly/verses/6eecdf2d-bb8c-4295-b11a-293f39fbc736.html"&gt;Methodologies for measuring project health&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Tools&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://www.soasme.com/techshack.weekly/verses/4bb68b40-ce23-49e7-9e15-d319daa3e630.html"&gt;Self-hosted Live Streaming&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Language&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://www.soasme.com/techshack.weekly/verses/ba6957c1-99b5-4f51-98e2-dd6d2ea0464d.html"&gt;Go 1.11 发布&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Programming&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="https://www.soasme.com/techshack.weekly/verses/dbca267e-99bb-4420-b114-9d7efaeb4fc3.html"&gt;Elm Architecture&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="https://www.soasme.com/techshack.weekly/verses/22750739-bd24-4f06-84fe-3aa3c57fadf4.html"&gt;Run Length Encoded&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="https://www.soasme.com/techshack.weekly/verses/f551ade8-ef89-48ee-a0e3-32562e62c015.html"&gt;Cooperative Principle Software&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Protocols&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://www.soasme.com/techshack.weekly/verses/d12681cb-27c6-4c21-ad19-8f125c4e9dfd.html"&gt;ActivityPub Overview&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content></entry><entry><title>Netflix 使用 Papermill 的实践</title><link href="https://www.soasme.com/techshack.weekly/verses/efcff137-1590-4b0a-a8d1-125ed4ff4620.html" rel="alternate"></link><published>2018-09-02T00:00:00+00:00</published><updated>2018-09-02T00:00:00+00:00</updated><author><name>Ju Lin</name></author><id>tag:www.soasme.com,2018-09-02:/techshack.weekly/verses/efcff137-1590-4b0a-a8d1-125ed4ff4620.html</id><summary type="html">&lt;p&gt;&lt;a href="https://medium.com/netflix-techblog/scheduling-notebooks-348e6c14cfd6"&gt;查看原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文介绍了 Netflix 如何使用 Papermill 管理 .ipynb.&lt;/p&gt;
&lt;p&gt;Jupyter Notebook 本质上就是一个 JSON 文档，并自带了简易的接口可以运行它自己。它真正运行的地方是 jupyter-kernels。ipynb 的缺点是常常变化，cell output 跟代码不完全一一对应，不好测试，没有可以配置运行上下文的设施，以及你需要运行一个 Notebook server。&lt;/p&gt;
&lt;p&gt;Papermill 的出现改进了很多这些问题。Papermill 做的事情是: 接受一个 ipynb path 和一些参数，然后运行出来一个 output ipynb，所有东西都在这个 output ipynb 里面。伪代码如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;papermill&lt;/span&gt; &lt;span class="kn"&gt;as&lt;/span&gt; &lt;span class="nn"&gt;pm&lt;/span&gt;

&lt;span class="n"&gt;pm&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;execute_notebook&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
   &lt;span class="s1"&gt;&amp;#39;path/to/input …&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</summary><content type="html">&lt;p&gt;&lt;a href="https://medium.com/netflix-techblog/scheduling-notebooks-348e6c14cfd6"&gt;查看原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文介绍了 Netflix 如何使用 Papermill 管理 .ipynb.&lt;/p&gt;
&lt;p&gt;Jupyter Notebook 本质上就是一个 JSON 文档，并自带了简易的接口可以运行它自己。它真正运行的地方是 jupyter-kernels。ipynb 的缺点是常常变化，cell output 跟代码不完全一一对应，不好测试，没有可以配置运行上下文的设施，以及你需要运行一个 Notebook server。&lt;/p&gt;
&lt;p&gt;Papermill 的出现改进了很多这些问题。Papermill 做的事情是: 接受一个 ipynb path 和一些参数，然后运行出来一个 output ipynb，所有东西都在这个 output ipynb 里面。伪代码如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;papermill&lt;/span&gt; &lt;span class="kn"&gt;as&lt;/span&gt; &lt;span class="nn"&gt;pm&lt;/span&gt;

&lt;span class="n"&gt;pm&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;execute_notebook&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
   &lt;span class="s1"&gt;&amp;#39;path/to/input.ipynb&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
   &lt;span class="s1"&gt;&amp;#39;path/to/output.ipynb&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
   &lt;span class="n"&gt;parameters&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;dict&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;alpha&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mf"&gt;0.6&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;ratio&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mf"&gt;0.1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;除了可以通过 python 调用，也可以通过 CLI 或者自建 Pipeline。Papermill 的好处是：源 ipynb 不会因为运行而被改变，不管是源还是目标 ipynb 都是不可变的。目标 ipynb 里面有代码，输出，日志，就是一个快照。&lt;/p&gt;
&lt;p&gt;基于 &lt;a href="https://github.com/nteract/nteract/tree/master/applications/commuter"&gt;Commuter&lt;/a&gt;, 还可以将 ipynb 存储到 S3 里面去。&lt;/p&gt;
&lt;p&gt;由于 Papermill 负责了所有的运行，你也不需要再去运行一个 Notebook server 了。如果某个 ipynb 太复杂了，可以继续做优化，把它放到本地仓库去维护，打成一个包部署。这意味着 ipynb 也可以被版本管理了。&lt;/p&gt;
&lt;p&gt;Netflix 使用 airflow 定时调度所有 papermill 任务，但是 papermill 并不局限谁来调度，看 papermill 的文档，要跟 celery, apscheduler 什么的集成也很简单。&lt;/p&gt;
&lt;p&gt;一些写 ipynb 的简易：少写分支，尽可能线性，复杂的东西写到库里去，尽可能简短和简单。&lt;/p&gt;</content></entry><entry><title>Netflix Data Platform - Genie 3</title><link href="https://www.soasme.com/techshack.weekly/verses/f11ba211-954c-4c68-8e5c-c162f9dcbdfa.html" rel="alternate"></link><published>2018-09-02T00:00:00+00:00</published><updated>2018-09-02T00:00:00+00:00</updated><author><name>Ju Lin</name></author><id>tag:www.soasme.com,2018-09-02:/techshack.weekly/verses/f11ba211-954c-4c68-8e5c-c162f9dcbdfa.html</id><summary type="html">&lt;p&gt;&lt;a href="https://medium.com/netflix-techblog/evolving-the-netflix-data-platform-with-genie-3-598021604dda"&gt;查看原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文介绍了 Netflix 的数据平台 Genie 3 的改进思路。这个平台目前日均运行任务数量大约是 150k，运行在 40 台 EC2 实例上。用例主要有两个：1）对开发隐藏 data warehouse 的细节，只暴露出提交任务和查看任务的接口；2）提供 repl 式的沙盒体验，开发可以自己新建出沙盒然后把数据用 stdout 导出。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://cdn-images-1.medium.com/max/1600/0*D6TjU22i2ehz5MHy."&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Execution Engine: 业务方提交的任务并不是真正运行的脚本，任务会被根据具体的环境，集群，命令，应用等配置编译成脚本去运行。&lt;/li&gt;
&lt;li&gt;Leader Election：用 ZooKeeper 或者手动设定一个节点是 leader。有些任务只在 leader 上运行。&lt;/li&gt;
&lt;li&gt;Security: 通过 Spring Security 加上登录验证，默认 …&lt;/li&gt;&lt;/ul&gt;</summary><content type="html">&lt;p&gt;&lt;a href="https://medium.com/netflix-techblog/evolving-the-netflix-data-platform-with-genie-3-598021604dda"&gt;查看原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文介绍了 Netflix 的数据平台 Genie 3 的改进思路。这个平台目前日均运行任务数量大约是 150k，运行在 40 台 EC2 实例上。用例主要有两个：1）对开发隐藏 data warehouse 的细节，只暴露出提交任务和查看任务的接口；2）提供 repl 式的沙盒体验，开发可以自己新建出沙盒然后把数据用 stdout 导出。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://cdn-images-1.medium.com/max/1600/0*D6TjU22i2ehz5MHy."&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Execution Engine: 业务方提交的任务并不是真正运行的脚本，任务会被根据具体的环境，集群，命令，应用等配置编译成脚本去运行。&lt;/li&gt;
&lt;li&gt;Leader Election：用 ZooKeeper 或者手动设定一个节点是 leader。有些任务只在 leader 上运行。&lt;/li&gt;
&lt;li&gt;Security: 通过 Spring Security 加上登录验证，默认 UI 支持 SAML, API 支持 JWT。&lt;/li&gt;
&lt;li&gt;Dependency Cache: 缓存任务的第三方依赖。&lt;/li&gt;
&lt;/ul&gt;</content></entry><entry><title>ActivityPub Overview</title><link href="https://www.soasme.com/techshack.weekly/verses/d12681cb-27c6-4c21-ad19-8f125c4e9dfd.html" rel="alternate"></link><published>2018-08-28T00:00:00+00:00</published><updated>2018-08-28T00:00:00+00:00</updated><author><name>Ju Lin</name></author><id>tag:www.soasme.com,2018-08-28:/techshack.weekly/verses/d12681cb-27c6-4c21-ad19-8f125c4e9dfd.html</id><summary type="html">&lt;p&gt;&lt;a href="https://www.w3.org/TR/activitypub/"&gt;查看原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文是 ActivityPub 的标准协议。ActivityPub 是分布式的社交网络协议。它的服务模型是：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="err"&gt;User =(POST)=&amp;gt; Outbox =(GET)=&amp;gt; Rest of the World&lt;/span&gt;
&lt;span class="err"&gt;User &amp;lt;=(GET)= Inbox &amp;lt;=(POST)= Rest of the World&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;需要有人自行搭建 ActivityPub 服务为 用户 提供 Inbox &amp;amp; Outbox。这些服务可以互相连接形成一个联邦。
服务之间使用 HTTP + JSON-LD 通信。&lt;/p&gt;</summary><content type="html">&lt;p&gt;&lt;a href="https://www.w3.org/TR/activitypub/"&gt;查看原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文是 ActivityPub 的标准协议。ActivityPub 是分布式的社交网络协议。它的服务模型是：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="err"&gt;User =(POST)=&amp;gt; Outbox =(GET)=&amp;gt; Rest of the World&lt;/span&gt;
&lt;span class="err"&gt;User &amp;lt;=(GET)= Inbox &amp;lt;=(POST)= Rest of the World&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;需要有人自行搭建 ActivityPub 服务为 用户 提供 Inbox &amp;amp; Outbox。这些服务可以互相连接形成一个联邦。
服务之间使用 HTTP + JSON-LD 通信。&lt;/p&gt;</content></entry><entry><title>Solve Less General Problems</title><link href="https://www.soasme.com/techshack.weekly/verses/d973549d-65a5-4d2d-a64b-66359cd93b62.html" rel="alternate"></link><published>2018-08-28T00:00:00+00:00</published><updated>2018-08-28T00:00:00+00:00</updated><author><name>Ju Lin</name></author><id>tag:www.soasme.com,2018-08-28:/techshack.weekly/verses/d973549d-65a5-4d2d-a64b-66359cd93b62.html</id><summary type="html">&lt;p&gt;&lt;a href="https://hacksoflife.blogspot.com/2018/08/solve-less-general-problems.html"&gt;查看原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文传达的观点是：没有必要写一个能解决所有问题的方案，任何方案都有优缺点和更适用的场合，你的方案完全可以跟具体问题更切合，不需要特别的泛化。&lt;/p&gt;</summary><content type="html">&lt;p&gt;&lt;a href="https://hacksoflife.blogspot.com/2018/08/solve-less-general-problems.html"&gt;查看原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文传达的观点是：没有必要写一个能解决所有问题的方案，任何方案都有优缺点和更适用的场合，你的方案完全可以跟具体问题更切合，不需要特别的泛化。&lt;/p&gt;</content></entry><entry><title>Run Length Encoded</title><link href="https://www.soasme.com/techshack.weekly/verses/22750739-bd24-4f06-84fe-3aa3c57fadf4.html" rel="alternate"></link><published>2018-08-27T00:00:00+00:00</published><updated>2018-08-27T00:00:00+00:00</updated><author><name>Ju Lin</name></author><id>tag:www.soasme.com,2018-08-27:/techshack.weekly/verses/22750739-bd24-4f06-84fe-3aa3c57fadf4.html</id><summary type="html">&lt;p&gt;&lt;a href="http://www.conwaylife.com/w/index.php?title=Run_Length_Encoded"&gt;查看原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;RLE (Run Length Encoded) 是一种用于存储有大量 pattern 的数据文件格式。如下格式表示的是 Conway Life Game 中的滑翔伞：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="err"&gt;#C This is a glider.&lt;/span&gt;
&lt;span class="err"&gt;x = 3, y = 3&lt;/span&gt;
&lt;span class="err"&gt;bo$2bo$3o!&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;其中 &lt;code&gt;#C&lt;/code&gt; 一行表示 Comment，&lt;code&gt;x = 3, y = 3&lt;/code&gt; 标注了 width, height. 下面的数据格式是 &lt;code&gt;&amp;lt;run_count&amp;gt;&amp;lt;tag&amp;gt;$&lt;/code&gt;; 如果 run_count 是 1 可以省略，例如 &lt;code&gt;bo&lt;/code&gt;, &lt;code&gt;2bo&lt;/code&gt;, $ 表示一行结束。&lt;/p&gt;
&lt;p&gt;衍生思考：这种格式介于机器和人可阅读的格式中间 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;&lt;a href="http://www.conwaylife.com/w/index.php?title=Run_Length_Encoded"&gt;查看原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;RLE (Run Length Encoded) 是一种用于存储有大量 pattern 的数据文件格式。如下格式表示的是 Conway Life Game 中的滑翔伞：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="err"&gt;#C This is a glider.&lt;/span&gt;
&lt;span class="err"&gt;x = 3, y = 3&lt;/span&gt;
&lt;span class="err"&gt;bo$2bo$3o!&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;其中 &lt;code&gt;#C&lt;/code&gt; 一行表示 Comment，&lt;code&gt;x = 3, y = 3&lt;/code&gt; 标注了 width, height. 下面的数据格式是 &lt;code&gt;&amp;lt;run_count&amp;gt;&amp;lt;tag&amp;gt;$&lt;/code&gt;; 如果 run_count 是 1 可以省略，例如 &lt;code&gt;bo&lt;/code&gt;, &lt;code&gt;2bo&lt;/code&gt;, $ 表示一行结束。&lt;/p&gt;
&lt;p&gt;衍生思考：这种格式介于机器和人可阅读的格式中间，可以基于这类方法设计自己的存储格式。&lt;/p&gt;</content></entry><entry><title>Redis is not open core</title><link href="https://www.soasme.com/techshack.weekly/verses/309f8cf0-c0e4-440c-a886-a87d43caebd4.html" rel="alternate"></link><published>2018-08-27T00:00:00+00:00</published><updated>2018-08-27T00:00:00+00:00</updated><author><name>Ju Lin</name></author><id>tag:www.soasme.com,2018-08-27:/techshack.weekly/verses/309f8cf0-c0e4-440c-a886-a87d43caebd4.html</id><summary type="html">&lt;p&gt;&lt;a href="http://antirez.com/news/121"&gt;查看原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文是 @antirez 的新博文，尝试论证的话题是：redis 不是 open core 软件。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;open core 是指软件核心是开源的，但是把一些有用的部分抽走闭源走商业版权。&lt;ul&gt;
&lt;li&gt;（比如 influxdb 单节点开源，要用 cluster？你要么付费，要么自己鼓捣个 influxdb-relay&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;redis 不是 open core, 因为它所有的功能都是开源的，没有单拿什么东西去卖钱。&lt;/li&gt;
&lt;li&gt;redis lab 基于 redis 做了一些功能开发卖钱，这跟上面的 open core 有本质区别。&lt;/li&gt;
&lt;li&gt;redis 将会专注于自己特性的开发，专注自己领域的问题。&lt;/li&gt;
&lt;/ul&gt;</summary><content type="html">&lt;p&gt;&lt;a href="http://antirez.com/news/121"&gt;查看原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文是 @antirez 的新博文，尝试论证的话题是：redis 不是 open core 软件。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;open core 是指软件核心是开源的，但是把一些有用的部分抽走闭源走商业版权。&lt;ul&gt;
&lt;li&gt;（比如 influxdb 单节点开源，要用 cluster？你要么付费，要么自己鼓捣个 influxdb-relay&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;redis 不是 open core, 因为它所有的功能都是开源的，没有单拿什么东西去卖钱。&lt;/li&gt;
&lt;li&gt;redis lab 基于 redis 做了一些功能开发卖钱，这跟上面的 open core 有本质区别。&lt;/li&gt;
&lt;li&gt;redis 将会专注于自己特性的开发，专注自己领域的问题。&lt;/li&gt;
&lt;/ul&gt;</content></entry><entry><title>Self-hosted Live Streaming</title><link href="https://www.soasme.com/techshack.weekly/verses/4bb68b40-ce23-49e7-9e15-d319daa3e630.html" rel="alternate"></link><published>2018-08-27T00:00:00+00:00</published><updated>2018-08-27T00:00:00+00:00</updated><author><name>Ju Lin</name></author><id>tag:www.soasme.com,2018-08-27:/techshack.weekly/verses/4bb68b40-ce23-49e7-9e15-d319daa3e630.html</id><summary type="html">&lt;p&gt;&lt;a href="https://drewdevault.com//2018/08/26/Self-hosted-livestreaming.html"&gt;查看原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文介绍了直播技术的一些基本知识，并给出了 101 教程 - 使用 ffmpeg, x11grab, nginx 搭建直播 laptop 屏幕的流服务。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ffmpeg 有内建的 DASH 格式，这个格式目前是业界给 web 浏览器做 live streaming video 的标准格式。这个格式讲视频分成离散的文件，然后用 xml 文件告诉播放器去哪里找这些文件。如果浏览器没有支持 dash，可以加上 dash.js 做个垫片。&lt;/li&gt;
&lt;li&gt;做直播服务要做两件事：实时录视频 + 用 web 服务器支持访问录出来的流视频。前者可以用 &lt;code&gt;ffmpeg -f dash ... /tmp/live.mpd&lt;/code&gt; 生成，后者可以通过 nginx 设置支持 &lt;code&gt;application …&lt;/code&gt;&lt;/li&gt;&lt;/ul&gt;</summary><content type="html">&lt;p&gt;&lt;a href="https://drewdevault.com//2018/08/26/Self-hosted-livestreaming.html"&gt;查看原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文介绍了直播技术的一些基本知识，并给出了 101 教程 - 使用 ffmpeg, x11grab, nginx 搭建直播 laptop 屏幕的流服务。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ffmpeg 有内建的 DASH 格式，这个格式目前是业界给 web 浏览器做 live streaming video 的标准格式。这个格式讲视频分成离散的文件，然后用 xml 文件告诉播放器去哪里找这些文件。如果浏览器没有支持 dash，可以加上 dash.js 做个垫片。&lt;/li&gt;
&lt;li&gt;做直播服务要做两件事：实时录视频 + 用 web 服务器支持访问录出来的流视频。前者可以用 &lt;code&gt;ffmpeg -f dash ... /tmp/live.mpd&lt;/code&gt; 生成，后者可以通过 nginx 设置支持 &lt;code&gt;application/dash+xml mpd; video/mp4 m4v; audio/mp4 m4a;&lt;/code&gt; 格式，指定 &lt;code&gt;root /tmp&lt;/code&gt; 找到视频。&lt;/li&gt;
&lt;/ul&gt;</content></entry></feed>
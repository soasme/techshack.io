<!DOCTYPE html>
<html lang="en">
<head>
    <title>Techshack Weekly </title>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0-beta.3/css/bootstrap.min.css" />
        <link rel="stylesheet" href="https://www.soasme.com/techshack.weekly/theme/css/main.css" type="text/css" />
        <link href="https://www.soasme.com/techshack.weekly/" type="application/atom+xml" rel="alternate" title="Techshack Weekly ATOM Feed" />

        <!--[if IE]>
                <script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->

        <!--[if lte IE 7]>
                <link rel="stylesheet" type="text/css" media="all" href="https://www.soasme.com/techshack.weekly/css/ie.css"/>
                <script src="https://www.soasme.com/techshack.weekly/js/IE8.js" type="text/javascript"></script><![endif]-->

        <!--[if lt IE 7]>
                <link rel="stylesheet" type="text/css" media="all" href="https://www.soasme.com/techshack.weekly/css/ie6.css"/><![endif]-->

</head>

<body>
    <div class="container">
        <div class="row">
            <div class="col-lg-2"></div>
            <div id="content" class="col-lg-6">
                <div class="entry">
        
        

 
                <section id="content" class="body">
            <div>
                <article class="hentry">
                    <header>
                        <h3>
                            <a href="https://www.soasme.com/techshack.weekly/verses/a4335a0c-7b1f-4b0e-9f79-15201ed79998.html" rel="bookmark"
                                title="Permalink to Hyperloglog 算法简介"
                                >Hyperloglog 算法简介</a>
                        </h3>
                    </header>
                    <div class="entry-content">
                        <p><a href="https://djhworld.github.io/hyperloglog/">查看原文</a></p>
<p>这个网站简单地介绍了 Hyperloglog 这个算法。该算法适用于非精确估计 <code>count(distinct)</code> 这种场景，它的优点是只用几KB内存就能处理上G的数据，而不像常规的 <code>len(set(e for e in data))</code> 这样耗内存或者上 map-reduce 那样架构复杂。</p>
<ul>
<li>算法<ul>
<li>添加一条记录：获得 <code>hash(row)</code>, 将 hash 剩余的0计数，归纳进 hash 头几位标记的 bucket 中。</li>
<li>计数：找出 bucket 中最大的数，应用上纠正算法（例如 LinearCount，即可得到估计的数值，在示例的数据集上做实验，偏离率在 2% 左右。</li>
</ul>
</li>
<li>Redis 实现了 pfcount 算法，即是 …</li></ul>
                        <a class="readmore" href="https://www.soasme.com/techshack.weekly/verses/a4335a0c-7b1f-4b0e-9f79-15201ed79998.html"
                            >read more</a>
                    </div><!-- /.entry-content -->
                </article>
            </div>


        

 
            <div>
                <article class="hentry">
                    <header>
                        <h3>
                            <a href="https://www.soasme.com/techshack.weekly/verses/27601668-15d6-431c-a4e2-1b0bab7f4212.html" rel="bookmark"
                                title="Permalink to Cloud Services are not MAGICAL"
                                >Cloud Services are not MAGICAL</a>
                        </h3>
                    </header>
                    <div class="entry-content">
                        <p><a href="http://antirez.com/news/22">查看原文</a></p>
<p>本文是 antirez 的一篇老文章，讲的是如果你用了云服务，也还是建议你能够做一个异地容灾。</p>
<ul>
<li>比起 AWS 省下来的钱来说, Bare Metal 并不贵。完全可以做到整个 stack 运行在两台 bare metal 上。100 euros/month 就可以搞到两台 64G RAM + RAID disk 的服务器了。</li>
<li>AWS EC2 出故障了，你固然可以跟老板说全美国的网站都崩溃了，不止咱家；但是在这种情况下，uptime percentage 毕竟是受到影响了。</li>
</ul>
<p>衍生思考：有 Terraform 这种技术，还是蛮容易将整套服务迁移到 gke, digitalocean 等云服务去。</p>
                        <a class="readmore" href="https://www.soasme.com/techshack.weekly/verses/27601668-15d6-431c-a4e2-1b0bab7f4212.html"
                            >read more</a>
                    </div><!-- /.entry-content -->
                </article>
            </div>


        

 
            <div>
                <article class="hentry">
                    <header>
                        <h3>
                            <a href="https://www.soasme.com/techshack.weekly/verses/a91a32ca-0ab3-4cc7-b89c-920117ccba98.html" rel="bookmark"
                                title="Permalink to 为什么等号被用作赋值操作符"
                                >为什么等号被用作赋值操作符</a>
                        </h3>
                    </header>
                    <div class="entry-content">
                        <p><a href="https://www.hillelwayne.com/post/equals-as-assignment/">查看原文</a></p>
<p>在数学中 <code>a=a+1</code> 是不成立的，但在编程中这个表达式表示a赋值为a+1。这篇文章探讨了为什么现代大部分编程语言使用了 = 作为赋值操作符。tldr，历史原因。。。</p>
<ul>
<li>c 语言这么用的</li>
<li>以前有语言用 <code>a := a + 1</code> 表示赋值（ALGOL-60）</li>
<li>在 ALGOL-60 到 CPL 到 APL 到 S 到 R 这条链的末端，R 语言选用了 <code>&lt;-</code> 作为推荐的赋值操作符。</li>
<li>BCPL 这门语言运行与 PDP-7, 引入了 ++, --，使用 = 作为初始，:= 作为赋值。</li>
<li>在 ALGOL-60 到 CPL 到 BCPL 到 B 再到 …</li></ul>
                        <a class="readmore" href="https://www.soasme.com/techshack.weekly/verses/a91a32ca-0ab3-4cc7-b89c-920117ccba98.html"
                            >read more</a>
                    </div><!-- /.entry-content -->
                </article>
            </div>


        

 
            <div>
                <article class="hentry">
                    <header>
                        <h3>
                            <a href="https://www.soasme.com/techshack.weekly/verses/2f47ce0c-cbd7-4832-8ae7-39c56e6120d8.html" rel="bookmark"
                                title="Permalink to Kubernetes 时代怎么做监控"
                                >Kubernetes 时代怎么做监控</a>
                        </h3>
                    </header>
                    <div class="entry-content">
                        <p><a href="https://github.com/DataDog/the-monitor/blob/master/kubernetes/monitoring-in-the-kubernetes-era.md">查看原文</a></p>
<p>本文是 Datadog 工程博客的一篇监控的介绍，若对 Kubernetes 比较熟可跳过前半篇看后半部分的真正的内容。</p>
<ul>
<li>在 Kubernetes 前的时代，监控按照 VM / Host 来做，现在呢，监控的玩法都要变了，如下：<ul>
<li>tags &amp; labels 是必选项了。这些使监控可以更接近 app 层面，而不是在 host 层面。</li>
<li>有更多的组件要监控，以前只有 host+app，现在要 host+containers+containerized_app+kubernetes。</li>
<li>应用用完就扔了(delete pod), 监控总不能像以前一样死盯着一个应用。</li>
<li>应用甚至可能部署在多个 cloud providers 上。</li>
</ul>
</li>
</ul>
<p>衍生思考：这篇文章讲述挑战更多，解决方案更少。可以关注后续的文章。</p>
                        <a class="readmore" href="https://www.soasme.com/techshack.weekly/verses/2f47ce0c-cbd7-4832-8ae7-39c56e6120d8.html"
                            >read more</a>
                    </div><!-- /.entry-content -->
                </article>
            </div>


        

 
            <div>
                <article class="hentry">
                    <header>
                        <h3>
                            <a href="https://www.soasme.com/techshack.weekly/verses/3a4f6df1-fa65-43d7-b78d-0e47b4632ab2.html" rel="bookmark"
                                title="Permalink to Timeout Retry Circuit Breaker 我该用哪个"
                                >Timeout Retry Circuit Breaker 我该用哪个</a>
                        </h3>
                    </header>
                    <div class="entry-content">
                        <p><a href="https://andrewbrookins.com/technology/demonstrating-stability-patterns-with-an-outage-simulator/">查看原文</a></p>
<p>本文是 @abrookins 做的一个实验，在他的实验中，他测试了诸如超时，重试，断路器等技巧对系统健壮性的影响。tldr, 结论：高并发带依赖的服务，不要重试，用尽可能短的 timeout，发请求时包在 circuit beaker 里面。</p>
<ul>
<li>上游服务宕机<ul>
<li>API Gateway Only: 如果下游服务只是简单地在 Connection Error 的时候捕获错误做一些默认值的处理，那么，对系统处理能力影响几乎微乎其微。主要是因为 socket error 报错是实时的，这时断路器和超时用上了也没用。</li>
<li>Circuit Breakers, 不设置超时，遇到了上游服务宕机，跟上面没差。</li>
</ul>
</li>
<li>上游服务器宕机<ul>
<li>No Timeouts, No Circuit Breakers, Boom，系统处理能力直接降到十几个请求。这个很容易理解：当前服务所有的处理能力都卡在那少数的几个上游服务的请求，而这些请求就 Hang …</li></ul></li></ul>
                        <a class="readmore" href="https://www.soasme.com/techshack.weekly/verses/3a4f6df1-fa65-43d7-b78d-0e47b4632ab2.html"
                            >read more</a>
                    </div><!-- /.entry-content -->
                </article>
            </div>


        

 
            <div>
                <article class="hentry">
                    <header>
                        <h3>
                            <a href="https://www.soasme.com/techshack.weekly/verses/2959cd37-f122-4db5-8b9d-a82870025479.html" rel="bookmark"
                                title="Permalink to Kayenta 的优点"
                                >Kayenta 的优点</a>
                        </h3>
                    </header>
                    <div class="entry-content">
                        <p><a href="https://cloudplatform.googleblog.com/2018/04/introducing-Kayenta-an-open-automated-canary-analysis-tool-from-Google-and-Netflix.html">查看原文</a></p>
<p>本文是</p>
                        <a class="readmore" href="https://www.soasme.com/techshack.weekly/verses/2959cd37-f122-4db5-8b9d-a82870025479.html"
                            >read more</a>
                    </div><!-- /.entry-content -->
                </article>
            </div>


        

 
            <div>
                <article class="hentry">
                    <header>
                        <h3>
                            <a href="https://www.soasme.com/techshack.weekly/verses/712d89d3-33c2-4b62-a2b7-b5eaed38a999.html" rel="bookmark"
                                title="Permalink to Netflix 如何使用 Kayenta 做 Canary 部署"
                                >Netflix 如何使用 Kayenta 做 Canary 部署</a>
                        </h3>
                    </header>
                    <div class="entry-content">
                        <p><a href="https://medium.com/netflix-techblog/automated-canary-analysis-at-netflix-with-kayenta-3260bc7acc69">查看原文</a></p>
<p>本文是 Netflix 工程博客的一篇文章，简述了他们如何使用 Kayenta 做 Canary 部署。</p>
<ul>
<li>基本概念介绍：上线切 1% 流量到 Canary 环境，出错就停止部署，一切正常就应用到所有生产环境的 instance 去。</li>
<li>一些额外的工作：<ul>
<li>为了防止 long-running process 的影响，在 production cluster 外起 baseline cluster + canary cluster 用于对比。</li>
<li>系统自动分析 canary 的结果，基于httpcode, load avg, 错误，响应等指标。如果指标评估通过就自动应用，否则 abort 掉部署。</li>
</ul>
</li>
<li>解决的痛点：Canary 部署后以前要人工观察日志，监控数据做出决定，一周只能做一两次 …</li></ul>
                        <a class="readmore" href="https://www.soasme.com/techshack.weekly/verses/712d89d3-33c2-4b62-a2b7-b5eaed38a999.html"
                            >read more</a>
                    </div><!-- /.entry-content -->
                </article>
            </div>


        

 
            <div>
                <article class="hentry">
                    <header>
                        <h3>
                            <a href="https://www.soasme.com/techshack.weekly/verses/3b11078e-7e9c-4c34-a4e9-10c5d4d5c036.html" rel="bookmark"
                                title="Permalink to 如何部署满是BUG的应用"
                                >如何部署满是BUG的应用</a>
                        </h3>
                    </header>
                    <div class="entry-content">
                        <p><a href="http://tech.trello.com/how-to-release-a-buggy-app-and-live-to-tell-the-story/">查看原文</a></p>
<p>本文是 Trello 的一篇工程博客，讲述了如果你发布了一个带有 bug 的程序去了生产环境那该怎么办？</p>
<ul>
<li>最基本的，要做监控。知道什么时候上线的代码。你不能只是部署了代码就丢到一边去了。</li>
<li>发布的时候经历 alpha，beta，staged。特别是 staged，你可以上线时只导流 1% 的流量。真正出问题了，也只是那一点点，回滚去修复。</li>
<li>特性开关。真要碰上下几个月才能发布的代码，那就得上特性开关，不停地合代码但就是不起用。</li>
<li>不要在人不在的假期前部署，简直是在给整个团队诚心不好好过节。</li>
<li>应用有能力在最后关头按照 User-Agent 掐掉请求，这样真有紧急 bug 出现导致应用被 ddos 了，可以扛一会儿。</li>
<li>与其赶着投胎修 bug，不如慢一些，把问题确切地修好，修对了。</li>
</ul>
                        <a class="readmore" href="https://www.soasme.com/techshack.weekly/verses/3b11078e-7e9c-4c34-a4e9-10c5d4d5c036.html"
                            >read more</a>
                    </div><!-- /.entry-content -->
                </article>
            </div>


        

 
            <div>
                <article class="hentry">
                    <header>
                        <h3>
                            <a href="https://www.soasme.com/techshack.weekly/verses/adc14616-345b-4424-adda-5ab7031e37b5.html" rel="bookmark"
                                title="Permalink to 为什么 SQLite 选用 C 语言实现"
                                >为什么 SQLite 选用 C 语言实现</a>
                        </h3>
                    </header>
                    <div class="entry-content">
                        <p><a href="https://sqlite.org/whyc.html">查看原文</a></p>
<p>本文介绍了 SQLite 为啥用 C 语言而不用像 Rust / Go 这些更现代的语言，原因：性能，兼容，依赖，稳定。</p>
<ul>
<li>C 就是快。任何宣称跟 C 一样快的语言都是在耍流氓，没一个够格。</li>
<li>几乎任何系统都能调用 C 的库，不管是在安卓上，电脑上，还是在 gameboy 上。</li>
<li>SQLite 的依赖压榨到了极致，在最小配置中，它只需要 memcmp memcpy memmove memset strcmp strlen strncmp 这几个东东。在全构建中也只多引入了 malloc/free 加文件读写。</li>
<li>C 敲级稳定！</li>
<li>很多人误解了面向对象以为什么东西都要面向对象，事实上面向对象只是一个理解问题的好方法但不是解决问题的好方法。有时候过程式的代码就是更简单更容易维护，以及 …</li></ul>
                        <a class="readmore" href="https://www.soasme.com/techshack.weekly/verses/adc14616-345b-4424-adda-5ab7031e37b5.html"
                            >read more</a>
                    </div><!-- /.entry-content -->
                </article>
            </div>


        

 
            <div>
                <article class="hentry">
                    <header>
                        <h3>
                            <a href="https://www.soasme.com/techshack.weekly/verses/b6cd4307-eb9e-4f42-94a8-b2d3f0fe25c4.html" rel="bookmark"
                                title="Permalink to 是否真的需要 WebSockets"
                                >是否真的需要 WebSockets</a>
                        </h3>
                    </header>
                    <div class="entry-content">
                        <p><a href="https://blog.stanko.io/do-you-really-need-websockets-343aed40aa9b">查看原文</a></p>
<p>本文介绍了 WebSockets 及它的一些备选技术选型，例如 SSE，Long Pooling，通过比较这些技术的特性我们可以针对场景给出更合理的选择。</p>
<ul>
<li>WebSockets 允许服务端和客户端随时互相通信。它使用 HTTP 握手，但随后转用 TCP 建立全双工的信道通信。几乎所有现代的浏览器都支持这项特性。由于连接是 sticky 的，所以它对负载均衡并不是很友好。作者对 WebSockets 的评价是适合用于聊天应用或者推送提醒，但对于很多其它场景杀鸡用了牛刀了：看你是否需要做全双工的通信，因为很多场景只是单纯的服务端推送啊！</li>
<li>Server-sent events 可以在 HTTP octet stream 的基础上做服务端像客户端的单方面推送。好处就是负载均衡能发挥作用了，不太好的地方是它没法检测客户端是否掉线了（当然如果能容忍这种场景的话就无所谓了！</li>
<li>Long polling: 每次客户端发送请求带上授权信息，服务端有数据则返回，无数据则hang住，直到客户端 timeout。好处是随便什么浏览器都能用，不太好的地方是负载均衡的压力也会变大。</li>
</ul>
<p>简而言之：不需要实时发数据回服务端用SSE，否则用 …</p>
                        <a class="readmore" href="https://www.soasme.com/techshack.weekly/verses/b6cd4307-eb9e-4f42-94a8-b2d3f0fe25c4.html"
                            >read more</a>
                    </div><!-- /.entry-content -->
                </article>
            </div>

<p class="paginator">
        <a href="https://www.soasme.com/techshack.weekly/category/verses25.html">&laquo;</a>
    Page 26 / 54
        <a href="https://www.soasme.com/techshack.weekly/category/verses27.html">&raquo;</a>
</p>
            </section><!-- /#content -->

                </div>

                <hr>
                <div id="footer" class="col-lg-12">
                    <nav>
                        <ul>
                        </ul>
                    </nav>
                </div>
            </div>
            <div id="sidebar" class="col-lg-4">
                <h1>
                    <a href="https://www.soasme.com/techshack.weekly " title="Techshack Weekly">
                        <img src="https://www.soasme.com/techshack.weekly/images/logo-200x50.png" />
                    </a>
                </h1>
                <span class="description"> </span>
                <div><div class="entry-subscription">
    <h5>Techshack Weekly</h5>
    <br>
    专注于后端技术阅读
    <br>
    目前有上百位订阅者。
    <br>
    订阅 <a href="https://www.soasme.com/techshack.weekly/feeds/issues.atom.xml">RSS</a>
    <br>
    欢迎加入 <a href="https://t.me/techshack">Telegram Channel</a> ，
    <br>
    <iframe src="https://tgwidget.com/widget/count/?id=5a66b26483ba88e7118b4568" frameborder="0" scrolling="no" horizontalscrolling="no" verticalscrolling="no" width="160px" height="50px" async></iframe>
    <br>
    关注推特 <a href="https://twitter.com/techshackweekly">@techshackweekly</a>。
    <br>
    <a href="https://twitter.com/TechshackWeekly?ref_src=twsrc%5Etfw" class="twitter-follow-button" data-show-count="false">Follow @TechshackWeekly</a><script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>
    <hr>
</div></div>
                <div><!-- Begin MailChimp Signup Form -->
<link href="//cdn-images.mailchimp.com/embedcode/slim-10_7.css" rel="stylesheet" type="text/css">
<style type="text/css">
    #mc_embed_signup{background:#fff; clear:left; font:14px Helvetica,Arial,sans-serif;  width:250px;}
    /* Add your own MailChimp form style overrides in your site stylesheet or in this style block.
       We recommend moving this block and the preceding CSS link to the HEAD of your HTML file. */
</style>
<div id="mc_embed_signup">
<form action="https://soasme.us17.list-manage.com/subscribe/post?u=617c1cb80ba1b0cbf828df387&amp;id=10442a8ee6" method="post" id="mc-embedded-subscribe-form" name="mc-embedded-subscribe-form" class="validate" target="_blank" novalidate>
    <div id="mc_embed_signup_scroll">
    <label for="mce-EMAIL">Subscribe to our mailing list</label>
    <input type="email" value="" name="EMAIL" class="email" id="mce-EMAIL" placeholder="email address" required>
    <!-- real people should not fill this in and expect good things - do not remove this or risk form bot signups-->
    <div style="position: absolute; left: -5000px;" aria-hidden="true"><input type="text" name="b_617c1cb80ba1b0cbf828df387_10442a8ee6" tabindex="-1" value=""></div>
    <div class="clear"><input type="submit" value="Subscribe" name="subscribe" id="mc-embedded-subscribe" class="button"></div>
    </div>
</form>
</div>

<!--End mc_embed_signup--></div>
                    <div>:: <a href="https://www.soasme.com/techshack.weekly/categories.html">Categories</a></div>
                <!-- <span class="feed"><a href="">RSS</a> | <a href="">Atom</a></span> -->
            </div>
            <div class="col-lg-2"></div>
        </div>
    </div>
    <script type="text/javascript">
    var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
    document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
    </script>
    <script type="text/javascript">
    try {
        var pageTracker = _gat._getTracker("UA-36183732-2");
    pageTracker._trackPageview();
    } catch(err) {}</script>
</body>
</html>
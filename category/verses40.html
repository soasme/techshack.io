<!DOCTYPE html>
<html lang="en">
<head>
    <title>Techshack Weekly </title>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0-beta.3/css/bootstrap.min.css" />
        <link rel="stylesheet" href="https://www.soasme.com/techshack.weekly/theme/css/main.css" type="text/css" />
        <link href="https://www.soasme.com/techshack.weekly/" type="application/atom+xml" rel="alternate" title="Techshack Weekly ATOM Feed" />

        <!--[if IE]>
                <script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->

        <!--[if lte IE 7]>
                <link rel="stylesheet" type="text/css" media="all" href="https://www.soasme.com/techshack.weekly/css/ie.css"/>
                <script src="https://www.soasme.com/techshack.weekly/js/IE8.js" type="text/javascript"></script><![endif]-->

        <!--[if lt IE 7]>
                <link rel="stylesheet" type="text/css" media="all" href="https://www.soasme.com/techshack.weekly/css/ie6.css"/><![endif]-->

</head>

<body>
    <div class="container">
        <div class="row">
            <div class="col-lg-2"></div>
            <div id="content" class="col-lg-6">
                <div class="entry">
        
        

 
                <section id="content" class="body">
            <div>
                <article class="hentry">
                    <header>
                        <h3>
                            <a href="https://www.soasme.com/techshack.weekly/verses/0bceb223-e2c9-4496-a514-f5f791e7946e.html" rel="bookmark"
                                title="Permalink to InfluxDB 如何做 Clustering，当然，只是曾经这样做"
                                >InfluxDB 如何做 Clustering，当然，只是曾经这样做</a>
                        </h3>
                    </header>
                    <div class="entry-content">
                        <p><a href="https://docs.influxdata.com/influxdb/v0.9/guides/clustering/">查看原文</a></p>
<p>InfluxDB 在 1.4 以后 Clustering 变为商业版才能用，但我们可以在之前的版本中看到它原本的设计意图：使用 3 个节点加入 raft cluster 成为 raft peers 选举领导，剩下的节点只做为数据节点不参与领导选举。</p>
<ul>
<li>在理解了这样的设计之后，要想启动 Clustering，就需要按顺序启动前三个节点。前三个节点在三台主机上运行，各自有不同的 conf，最重要的配置是设置 bind 的地址。<ul>
<li>第一个节点正常启动: <code>service influxdb start</code></li>
<li>第二个节点需要设置环境变量：<code>INFLUXD_OPTS="-join hostname_1:port_1" service influxdb start</code></li>
<li>第三个节点类似：启动节点的时候设置环境变量 <code>INFLUXD_OPTS="-join hostname_1:port_1,hostname_2:port_2"</code></li>
</ul>
</li>
<li>可以使用 …</li></ul>
                        <a class="readmore" href="https://www.soasme.com/techshack.weekly/verses/0bceb223-e2c9-4496-a514-f5f791e7946e.html"
                            >read more</a>
                    </div><!-- /.entry-content -->
                </article>
            </div>


        

 
            <div>
                <article class="hentry">
                    <header>
                        <h3>
                            <a href="https://www.soasme.com/techshack.weekly/verses/1035dbe4-16b7-414b-9c80-ddcd2a59b00d.html" rel="bookmark"
                                title="Permalink to 使用 Python 做 Linux System 编程"
                                >使用 Python 做 Linux System 编程</a>
                        </h3>
                    </header>
                    <div class="entry-content">
                        <p><a href="http://echorand.me/linux-system-mining-with-python.html">查看原文</a></p>
<p>本文介绍了使用 Python 获取很多 Linux 系统参数的方法。</p>
<ul>
<li><code>platform</code> 模块就提供了很多信息。<ul>
<li><code>platform.uname()</code> 获取 uname 信息，得到一个 tuple 的数据：包括操作系统，node name, release, version 等信息。</li>
<li><code>platform.architecture()</code> 获取系统架构，看支持 32 位还是 64 位。</li>
</ul>
</li>
<li><code>open('/proc/cpuinfo').readlines()</code> 可以获取 CPU 信息</li>
<li><code>open('/proc/meminfo').readlines()</code> 可以获取 内存 信息</li>
<li><code>open('/proc/net/dev').readlines()</code> 可以获取 …</li></ul>
                        <a class="readmore" href="https://www.soasme.com/techshack.weekly/verses/1035dbe4-16b7-414b-9c80-ddcd2a59b00d.html"
                            >read more</a>
                    </div><!-- /.entry-content -->
                </article>
            </div>


        

 
            <div>
                <article class="hentry">
                    <header>
                        <h3>
                            <a href="https://www.soasme.com/techshack.weekly/verses/4e5923a3-acd2-422f-b312-bd1e498aa0cf.html" rel="bookmark"
                                title="Permalink to UnQLite - 一款进程内的 NoSQL 数据库"
                                >UnQLite - 一款进程内的 NoSQL 数据库</a>
                        </h3>
                    </header>
                    <div class="entry-content">
                        <p><a href="https://github.com/symisc/unqlite">查看原文</a></p>
<p>UnQLite 项目在 2018 年 1 月份重新进入活跃开发，它是一款自包含的，无服务，完全无配置的，有事务的进程内 NoSQL 数据库引擎。这个项目和 MongoDB, Redis 类似可以提供文档存储，也和BerkeleyDB, LevelDB 类似可以提供 kv 存储。你可以理解为它是一个嵌入到应用进程内部的 NoSQL，这意味着它自己完全没有进程运行着，它运行在进程里面。它的数据就直接存储在磁盘的单个文件上。</p>
                        <a class="readmore" href="https://www.soasme.com/techshack.weekly/verses/4e5923a3-acd2-422f-b312-bd1e498aa0cf.html"
                            >read more</a>
                    </div><!-- /.entry-content -->
                </article>
            </div>


        

 
            <div>
                <article class="hentry">
                    <header>
                        <h3>
                            <a href="https://www.soasme.com/techshack.weekly/verses/ab63ae2c-108c-4479-b3d0-7f4eee05da31.html" rel="bookmark"
                                title="Permalink to Simplicity by Distributing Complexity"
                                >Simplicity by Distributing Complexity</a>
                        </h3>
                    </header>
                    <div class="entry-content">
                        <p><a href="https://jobs.zalando.com/tech/blog/simplicity-by-distributing-complexity/index.html">查看原文</a></p>
<p>本文讲了一个常见的需求：客户端需要一份数据，而这份数据需要从各个子系统里抓来聚合。</p>
<ul>
<li>一种解决方案是：在各个子系统前端放置一个聚合器。聚合器的实现就是从各个系统灌数据进来，然后处理完丢给客户端。</li>
<li>另一种解决方案是：在各个子系统中间穿插放置小聚合器。尽管全局服务依赖变复杂了，但每个单个小聚合器的逻辑也变简单了（事实上如果分析下数据流会发现这种解决方案的数据流也更简单）</li>
</ul>
                        <a class="readmore" href="https://www.soasme.com/techshack.weekly/verses/ab63ae2c-108c-4479-b3d0-7f4eee05da31.html"
                            >read more</a>
                    </div><!-- /.entry-content -->
                </article>
            </div>


        

 
            <div>
                <article class="hentry">
                    <header>
                        <h3>
                            <a href="https://www.soasme.com/techshack.weekly/verses/ca4a3e12-5fe9-4f77-b8f6-9379ab60c416.html" rel="bookmark"
                                title="Permalink to 如何使用 Git 将某个分支的文件复制到另外一个分支去？"
                                >如何使用 Git 将某个分支的文件复制到另外一个分支去？</a>
                        </h3>
                    </header>
                    <div class="entry-content">
                        <p><a href="http://jasonrudolph.com/blog/2009/02/25/git-tip-how-to-merge-specific-files-from-another-branch/">查看原文</a></p>
<p>如果有需求在一个分支工作调试，另一个分支提交PR，那将工作分支的代码复制到提交PR分支的场景就出现了。git cherry-pick？慢了一些，一个文件可能提交了很多个，那要 cherry-pick 好多次才能完整得到文件。</p>
<p>正解是只需要通过 checkout 即可：<code>git checkout dev /path/to/file</code></p>
<p>这里很好理解这个命令，checkout 字面意义就是签出，上面的命令就是将 dev 分支的某个代码文件整个签出到目前的工作目录中。</p>
                        <a class="readmore" href="https://www.soasme.com/techshack.weekly/verses/ca4a3e12-5fe9-4f77-b8f6-9379ab60c416.html"
                            >read more</a>
                    </div><!-- /.entry-content -->
                </article>
            </div>


        

 
            <div>
                <article class="hentry">
                    <header>
                        <h3>
                            <a href="https://www.soasme.com/techshack.weekly/verses/da056ff4-cc29-474c-b85e-54f7cd0f8161.html" rel="bookmark"
                                title="Permalink to 学习 Grafana 的基本概念"
                                >学习 Grafana 的基本概念</a>
                        </h3>
                    </header>
                    <div class="entry-content">
                        <p><a href="http://docs.grafana.org/guides/basic_concepts/">查看原文</a></p>
<p>这是一篇自底向上学习 Grafana 中所有核心概念的 Getting Started 级别的文章，Grafana 中的基础概念有：数据源（Data Source），组织（Organization），用户（User），行（Row），面板（Panel），查询编辑器（Query Editor），仪表盘（Dashboard）。</p>
<ul>
<li>Data Source: 提供数据的服务就是 Data Source。每种 Data Source 都有自己定制过的 Query Editor。</li>
<li>Organization：需求：一个 Grafana 示例可以给多个组织提供服务。</li>
<li>User：用户属于 Organization，可以被授予角色，一般用于验证身份。</li>
<li>Row：一行 12 个单位 …</li></ul>
                        <a class="readmore" href="https://www.soasme.com/techshack.weekly/verses/da056ff4-cc29-474c-b85e-54f7cd0f8161.html"
                            >read more</a>
                    </div><!-- /.entry-content -->
                </article>
            </div>


        

 
            <div>
                <article class="hentry">
                    <header>
                        <h3>
                            <a href="https://www.soasme.com/techshack.weekly/verses/0e37dc23-1a94-4593-a1f5-ac5b1a77fee1.html" rel="bookmark"
                                title="Permalink to 温习 父进程/僵尸进程/孤儿进程 的概念"
                                >温习 父进程/僵尸进程/孤儿进程 的概念</a>
                        </h3>
                    </header>
                    <div class="entry-content">
                        <p><a href="https://en.wikipedia.org/wiki/Parent_process">查看原文</a></p>
<p>在 Unix-like 的操作系统中，除了 process 0, 其它所有进程都是 fork 产生的。调用了 fork 的进程就是父进程，被新建的进程就是子进程。Process 0 是在启动的时候创建的，fork 出了 process 1，自己变成 swapper。Process 1 是系统中所有其它进程的祖先。</p>
<p>在 Linux 中，还有 Parent 和 Real Parent 这两种概念。Parent 是子进程死后接收 SIGCHLD 的进程，real parent 是在多线程环境中创建了子进程的那个线程。</p>
<p>僵尸进程：当进程退出，操作系统释放了大部分资源，但关于资源消耗和退出码这些数据仍然保留，因为父进程可能需要子进程是否成功运行以及系统资源消耗量这些信息。默认情况下，操作系统像父亲发送 SIGCHLD …</p>
                        <a class="readmore" href="https://www.soasme.com/techshack.weekly/verses/0e37dc23-1a94-4593-a1f5-ac5b1a77fee1.html"
                            >read more</a>
                    </div><!-- /.entry-content -->
                </article>
            </div>


        

 
            <div>
                <article class="hentry">
                    <header>
                        <h3>
                            <a href="https://www.soasme.com/techshack.weekly/verses/11b30b3f-ab97-43b5-8ba7-5600019f316d.html" rel="bookmark"
                                title="Permalink to Man 文档阅读 - environ.7"
                                >Man 文档阅读 - environ.7</a>
                        </h3>
                    </header>
                    <div class="entry-content">
                        <p><a href="http://man7.org/linux/man-pages/man7/environ.7.html">查看原文</a></p>
<p>在 C 程序中，<code>environ</code> 是用户的环境变量。它是一个指向 char** 的指针，指向的数组的最后一个元素是 NULL。当 exec 启动一个进程的时候，进程会被塞入一个字符串数组作为环境变量。当 fork 出一个子进程的时候，子进程会拿到父进程的环境变量的拷贝。当进程运行的时候，可以通过 getenv, putenv, setenv 和 unsetenv 来操作环境变量。</p>
<p>Shell 环境中可以用 export (sh), setenv (csh) 设置环境变量。Shell 的初始环境变量在 /etc/environment 中配置，所有用户登录时会读取。另外，系统全局的配置 /etc/profile 和用户个人的配置也会被加进来。Bourne-style 的风格是用 <code>name=value</code> 这样的格式 …</p>
                        <a class="readmore" href="https://www.soasme.com/techshack.weekly/verses/11b30b3f-ab97-43b5-8ba7-5600019f316d.html"
                            >read more</a>
                    </div><!-- /.entry-content -->
                </article>
            </div>


        

 
            <div>
                <article class="hentry">
                    <header>
                        <h3>
                            <a href="https://www.soasme.com/techshack.weekly/verses/6d48e3b6-39d9-494a-acb4-9be5b61f3366.html" rel="bookmark"
                                title="Permalink to 温习 PID (Process identifier) 的概念"
                                >温习 PID (Process identifier) 的概念</a>
                        </h3>
                    </header>
                    <div class="entry-content">
                        <p><a href="https://en.wikipedia.org/wiki/Process_identifier">查看原文</a></p>
<p>大多数操作系统都有 PID 这个概念，用于给一个进程到唯一标识位，我们用它操作进程，例如发送信号，杀掉，调优先级等。</p>
<p>在 Unix 系统中，有 2 个 PID 是特殊的：0, 1</p>
<ul>
<li>PID=0: 也叫 swapper 或 sched, 翻译大概叫交换进程。它专门用于处理分页，其实更多是内核的一部分。</li>
<li>PID=1: 通常是 init 进程，用于开关机和托管孤儿进程。历史上倒是没有标准说 1 号一定是 init，只是 kernel 最开始搞出来的进程就自然而然分配到了 1。</li>
<li>PID=N: 递增到上限后，不同的系统从诸如 100， 300 之类的低端数字重新开始递增，寻找可用的 …</li></ul>
                        <a class="readmore" href="https://www.soasme.com/techshack.weekly/verses/6d48e3b6-39d9-494a-acb4-9be5b61f3366.html"
                            >read more</a>
                    </div><!-- /.entry-content -->
                </article>
            </div>


        

 
            <div>
                <article class="hentry">
                    <header>
                        <h3>
                            <a href="https://www.soasme.com/techshack.weekly/verses/c4e958b4-0c67-452c-871e-4cd9290de71b.html" rel="bookmark"
                                title="Permalink to 对字符串应用 `strlen()` 和 `sizeof()` 的不同点"
                                >对字符串应用 `strlen()` 和 `sizeof()` 的不同点</a>
                        </h3>
                    </header>
                    <div class="entry-content">
                        <p><a href="https://www.geeksforgeeks.org/difference-strlen-sizeof-string-c-reviewed/">查看原文</a></p>
<p><code>sizeof</code> 是编译时的一元运算符，用于计算操作量的 size；<code>strlen()</code> 则是运行时的函数，定义于 <code>string.h</code> 中，虽然都有计算大小这种功能，但他们概念不同，使用场景也不同。</p>
<ul>
<li><code>sizeof</code> 返回 <code>size_t</code> 类型，可以应用在任何类型上，int 可以，struct 也可以。</li>
<li><code>strlen()</code> 返回 <code>size_t</code> 类型，应用在一个指向数组的指针，运行的时候它会数内存地址，直到遇到了 NULL。这个函数的主要任务是算字符串长度（不包括 \0)</li>
<li>上面提到的编译时和运行时是个很大的区别，这意味着 sizeof 不关心具体值，它只关心 type 的 size, 而 strlen 关心的是运行时的 C-style NULL-terminated string 具体值的长度。</li>
</ul>
<p>课后习题 …</p>
                        <a class="readmore" href="https://www.soasme.com/techshack.weekly/verses/c4e958b4-0c67-452c-871e-4cd9290de71b.html"
                            >read more</a>
                    </div><!-- /.entry-content -->
                </article>
            </div>

<p class="paginator">
        <a href="https://www.soasme.com/techshack.weekly/category/verses39.html">&laquo;</a>
    Page 40 / 54
        <a href="https://www.soasme.com/techshack.weekly/category/verses41.html">&raquo;</a>
</p>
            </section><!-- /#content -->

                </div>

                <hr>
                <div id="footer" class="col-lg-12">
                    <nav>
                        <ul>
                        </ul>
                    </nav>
                </div>
            </div>
            <div id="sidebar" class="col-lg-4">
                <h1>
                    <a href="https://www.soasme.com/techshack.weekly " title="Techshack Weekly">
                        <img src="https://www.soasme.com/techshack.weekly/images/logo-200x50.png" />
                    </a>
                </h1>
                <span class="description"> </span>
                <div><div class="entry-subscription">
    <h5>Techshack Weekly</h5>
    <br>
    专注于后端技术阅读
    <br>
    目前有上百位订阅者。
    <br>
    订阅 <a href="https://www.soasme.com/techshack.weekly/feeds/issues.atom.xml">RSS</a>
    <br>
    欢迎加入 <a href="https://t.me/techshack">Telegram Channel</a> ，
    <br>
    <iframe src="https://tgwidget.com/widget/count/?id=5a66b26483ba88e7118b4568" frameborder="0" scrolling="no" horizontalscrolling="no" verticalscrolling="no" width="160px" height="50px" async></iframe>
    <br>
    关注推特 <a href="https://twitter.com/techshackweekly">@techshackweekly</a>。
    <br>
    <a href="https://twitter.com/TechshackWeekly?ref_src=twsrc%5Etfw" class="twitter-follow-button" data-show-count="false">Follow @TechshackWeekly</a><script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>
    <hr>
</div></div>
                <div><!-- Begin MailChimp Signup Form -->
<link href="//cdn-images.mailchimp.com/embedcode/slim-10_7.css" rel="stylesheet" type="text/css">
<style type="text/css">
    #mc_embed_signup{background:#fff; clear:left; font:14px Helvetica,Arial,sans-serif;  width:250px;}
    /* Add your own MailChimp form style overrides in your site stylesheet or in this style block.
       We recommend moving this block and the preceding CSS link to the HEAD of your HTML file. */
</style>
<div id="mc_embed_signup">
<form action="https://soasme.us17.list-manage.com/subscribe/post?u=617c1cb80ba1b0cbf828df387&amp;id=10442a8ee6" method="post" id="mc-embedded-subscribe-form" name="mc-embedded-subscribe-form" class="validate" target="_blank" novalidate>
    <div id="mc_embed_signup_scroll">
    <label for="mce-EMAIL">Subscribe to our mailing list</label>
    <input type="email" value="" name="EMAIL" class="email" id="mce-EMAIL" placeholder="email address" required>
    <!-- real people should not fill this in and expect good things - do not remove this or risk form bot signups-->
    <div style="position: absolute; left: -5000px;" aria-hidden="true"><input type="text" name="b_617c1cb80ba1b0cbf828df387_10442a8ee6" tabindex="-1" value=""></div>
    <div class="clear"><input type="submit" value="Subscribe" name="subscribe" id="mc-embedded-subscribe" class="button"></div>
    </div>
</form>
</div>

<!--End mc_embed_signup--></div>
                    <div>:: <a href="https://www.soasme.com/techshack.weekly/categories.html">Categories</a></div>
                <!-- <span class="feed"><a href="">RSS</a> | <a href="">Atom</a></span> -->
            </div>
            <div class="col-lg-2"></div>
        </div>
    </div>
    <script type="text/javascript">
    var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
    document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
    </script>
    <script type="text/javascript">
    try {
        var pageTracker = _gat._getTracker("UA-36183732-2");
    pageTracker._trackPageview();
    } catch(err) {}</script>
</body>
</html>
<!DOCTYPE html>
<html lang="en">
<head>
    <title>Techshack Weekly </title>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0-beta.3/css/bootstrap.min.css" />
        <link rel="stylesheet" href="https://www.soasme.com/techshack.weekly/theme/css/main.css" type="text/css" />
        <link href="https://www.soasme.com/techshack.weekly/" type="application/atom+xml" rel="alternate" title="Techshack Weekly ATOM Feed" />

        <!--[if IE]>
                <script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->

        <!--[if lte IE 7]>
                <link rel="stylesheet" type="text/css" media="all" href="https://www.soasme.com/techshack.weekly/css/ie.css"/>
                <script src="https://www.soasme.com/techshack.weekly/js/IE8.js" type="text/javascript"></script><![endif]-->

        <!--[if lt IE 7]>
                <link rel="stylesheet" type="text/css" media="all" href="https://www.soasme.com/techshack.weekly/css/ie6.css"/><![endif]-->

</head>

<body>
    <div class="container">
        <div class="row">
            <div class="col-lg-2"></div>
            <div id="content" class="col-lg-6">
                <div class="entry">
        
        

 
                <section id="content" class="body">
            <div>
                <article class="hentry">
                    <header>
                        <h3>
                            <a href="https://www.soasme.com/techshack.weekly/verses/791abd30-73e7-448c-92f3-246bbbe2dfe7.html" rel="bookmark"
                                title="Permalink to 重新设计 Redux"
                                >重新设计 Redux</a>
                        </h3>
                    </header>
                    <div class="entry-content">
                        <p><a href="https://hackernoon.com/redesigning-redux-b2baee8b8a38">查看原文</a></p>
<p>这篇文章回答了三个问题：是否真的需要库管理状态，Redux 为什么会流行，以及如何改进状态管理。</p>
<ul>
<li>前端开发的核心就是如何管理状态。在 React 中，状态就有组件内部状态，子组件从父组件获得的状态，以及树中的组件订阅 Root Provider 提供的状态。状态都放在 view 里面倒是方便，但是问题在于如果设计变了，整个程序就要重写。那么最合适的做法可能就是把状态都放在 root component 里面。如果在将 State 移出 view lib，那么就是 Redux 这种路数了（它通过 provider/consumer pattern 在 Redux 和 Tree 之间同步状态）。</li>
<li>^ Redux 的核心数据结构其实可以用 <code>global.state = {}</code> 来表示。</li>
<li>Redux 为 ^ 这个数据结构附加的功能是绑定了一套工具函数的流水线 …</li></ul>
                        <a class="readmore" href="https://www.soasme.com/techshack.weekly/verses/791abd30-73e7-448c-92f3-246bbbe2dfe7.html"
                            >read more</a>
                    </div><!-- /.entry-content -->
                </article>
            </div>


        

 
            <div>
                <article class="hentry">
                    <header>
                        <h3>
                            <a href="https://www.soasme.com/techshack.weekly/verses/666697f9-3328-4660-97d9-0ff44fe36583.html" rel="bookmark"
                                title="Permalink to Syslog 简介"
                                >Syslog 简介</a>
                        </h3>
                    </header>
                    <div class="entry-content">
                        <p><a href="https://www.gnu.org/software/libc/manual/html_node/Overview-of-Syslog.html">查看原文</a></p>
<p>系统日志要处理的类型有各种各样，例如 ftp 来了新连接，kernel 发现硬盘坏了，DNS 服务器报告统计信息等等。大部分消息就地转储，以后来了问题用来追查。如果是很紧急的消息，可以通过设定立即通知系统管理员。大部分 Unix 操作系统提供了 syslog，它的 daemon 程序叫 syslogd，相关的配置存储在 <code>/etc/syslog.conf</code>，监听 Unix sock name 是 <code>/dev/log</code>。除了可以记录本地的日志，它也可以通过 UDP 接受来自其它主机的消息，或者 kernel 直接把消息暂存在 kernel message ring 中，待 syslogd 进程起了以后发过去。一条 syslog 消息的两个最重要的信息：facility …</p>
                        <a class="readmore" href="https://www.soasme.com/techshack.weekly/verses/666697f9-3328-4660-97d9-0ff44fe36583.html"
                            >read more</a>
                    </div><!-- /.entry-content -->
                </article>
            </div>


        

 
            <div>
                <article class="hentry">
                    <header>
                        <h3>
                            <a href="https://www.soasme.com/techshack.weekly/verses/771cbf63-b922-45f7-9fb2-8dba928f6737.html" rel="bookmark"
                                title="Permalink to 如何集成测试 microservices"
                                >如何集成测试 microservices</a>
                        </h3>
                    </header>
                    <div class="entry-content">
                        <p><a href="http://blog.launchdarkly.com/testing-microservices-a-sane-approach-pre-production-in-production/">查看原文</a></p>
<p>本文讲的是 A Sane Approach Pre-Production &amp; In Production。真是的超级长的一篇，看完了原文觉得要吐血。作者认为正确的方法不是写成千上万的本地测试，也不是把几十种服务拉到本地来跑，而是应该 1) instrument services 2) understand operational semantic of services。</p>
<p>Testing in production 需要的手段有 A/B testing，特性开关，Canary，分布式追踪，监控等等。作者认为写一百个测试也挡不住一个坏掉的地方会把整个服务搞挂掉。与其在上面搞得心累，不如把 unhealthy 也看成一种 healthy，让程序尽可能地能扛 failure。真的要搞挂了，用类似 Canary 这种手段以最快的速度回滚，只让最小的用户受到影响。</p>
                        <a class="readmore" href="https://www.soasme.com/techshack.weekly/verses/771cbf63-b922-45f7-9fb2-8dba928f6737.html"
                            >read more</a>
                    </div><!-- /.entry-content -->
                </article>
            </div>


        

 
            <div>
                <article class="hentry">
                    <header>
                        <h3>
                            <a href="https://www.soasme.com/techshack.weekly/verses/7fcc4f42-18b8-4049-a348-ecfb6db985ef.html" rel="bookmark"
                                title="Permalink to Terminal v/s tty v/s console v/s shell 的区别"
                                >Terminal v/s tty v/s console v/s shell 的区别</a>
                        </h3>
                    </header>
                    <div class="entry-content">
                        <p><a href="https://unix.stackexchange.com/questions/4126/what-is-the-exact-difference-between-a-terminal-a-shell-a-tty-and-a-con">查看原文</a></p>
<p>这篇 stackexchange 问答回答了 terminal, tty, console, shell 这些名词的区别。简单来说，terminal 是文本输入输出的环境，tty 是 terminal 的行话，shell 是命令行解释器，console 是 terminal 的物理实体。当然，从词源上讲，terminal 是电线的终端，shell 是龟壳，tty 是个奇怪的缩写，console 是一种控制台或者仪表盘。</p>
<p>这些名词会让人觉得混淆的地方在于，他们都和我们操纵电脑的装置有关系。tty 之所以有这种缩写，是因为早期 Unix 是通过一种叫 teletypewriter 的远程打印装置输入命令。至于现在，这个名词还保留在系统里，不过已经只是作为 <code>/dev/tty</code> 这样的设备文件还存在着。与之相关联的，是被我们称为 pseudo-tty …</p>
                        <a class="readmore" href="https://www.soasme.com/techshack.weekly/verses/7fcc4f42-18b8-4049-a348-ecfb6db985ef.html"
                            >read more</a>
                    </div><!-- /.entry-content -->
                </article>
            </div>


        

 
            <div>
                <article class="hentry">
                    <header>
                        <h3>
                            <a href="https://www.soasme.com/techshack.weekly/verses/a97675f7-0e6e-4756-9f94-8e9e02270c9e.html" rel="bookmark"
                                title="Permalink to Bytecode - 一款 Python 字节码编译工具"
                                >Bytecode - 一款 Python 字节码编译工具</a>
                        </h3>
                    </header>
                    <div class="entry-content">
                        <p><a href="http://bytecode.readthedocs.io/en/latest/usage.html">查看原文</a></p>
<p>bytecode 是一款 Python (3.4+) 的字节码编译工具，它可以让你写 bytecode，进而通过 <code>exec(bytecode.to_code())</code> 执行它。</p>
<p>衍生思考：感觉比较有用的场景是写 DSL。用一个语法解析工具解析自定义的语法规则，然后将切分好的 Token 映射成 Bytecode，进而让 Python 解释器执行它。以下的小例子可以用于进制转换，分别展示了运行结果及其源代码。当然，只是为了验证下可行性，要想写出 Robust 的 DSL 代码，还需要很多细节上的考虑。</p>
<p>运行结果：</p>
<div class="highlight"><pre><span></span><code>$ ./simple-pipe <span class="s1">&#39;15 | bin&#39;</span>
0b1111

$ ./simple-pipe <span class="s1">&#39;15 | oct&#39;</span>
0o17

$ ./simple-pipe <span class="s1">&#39;15 | hex&#39;</span>
0xf
</code></pre></div>


<p>源代码：</p>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1 …</pre></div></td></tr></table>
                        <a class="readmore" href="https://www.soasme.com/techshack.weekly/verses/a97675f7-0e6e-4756-9f94-8e9e02270c9e.html"
                            >read more</a>
                    </div><!-- /.entry-content -->
                </article>
            </div>


        

 
            <div>
                <article class="hentry">
                    <header>
                        <h3>
                            <a href="https://www.soasme.com/techshack.weekly/verses/efa09f76-9f7a-44ac-b18f-5cf1b7a2cf06.html" rel="bookmark"
                                title="Permalink to Postmortem: CA 信任链没安装造成的一次大型悲剧"
                                >Postmortem: CA 信任链没安装造成的一次大型悲剧</a>
                        </h3>
                    </header>
                    <div class="entry-content">
                        <p><a href="https://ayende.com/blog/181953-A/production-postmortem-the-unavailable-linux-server">查看原文</a></p>
<p>本文介绍了一个团队关于一台 Linux Server 完全无法响应用户请求，但是 CPU / IO 负载等等指标又好的不能再好的 Case。事情简单说来是这样子的：他们使用了 Let's Encrypt 证书，他们的服务器上没有安装 SSL 证书的整个 chain，导致每来一个用户请求，服务器就需要向外部发送 HTTP 请求获取 ca chain；很不巧，防火墙还把这种请求给墙了，所以就会看到长达两分钟的 timeout。从这份 postmortem 里面，我们可以学到很多知识点：</p>
<ul>
<li>使用 strace 可以看到具体进程发生的系统调用。如果想看到哪里卡了，用 strace 一查 syscall 的调用序列就知道。</li>
<li>在一次 SSL handshake 中，如果服务器没有安装 entire certificate chain …</li></ul>
                        <a class="readmore" href="https://www.soasme.com/techshack.weekly/verses/efa09f76-9f7a-44ac-b18f-5cf1b7a2cf06.html"
                            >read more</a>
                    </div><!-- /.entry-content -->
                </article>
            </div>


        

 
            <div>
                <article class="hentry">
                    <header>
                        <h3>
                            <a href="https://www.soasme.com/techshack.weekly/verses/fe447683-4f28-48da-ad47-54b666e61d7f.html" rel="bookmark"
                                title="Permalink to Daemon 是通过两次 fork 产生的"
                                >Daemon 是通过两次 fork 产生的</a>
                        </h3>
                    </header>
                    <div class="entry-content">
                        <p><a href="https://stackoverflow.com/questions/881388/what-is-the-reason-for-performing-a-double-fork-when-creating-a-daemon">查看原文</a></p>
<p>Unix 上创建 Daemon 进程的常规手段是两次 Fork，根本目的是为了同 Controlling Terminal 分离开。</p>
<p>以 Sander Marechal 的<a href="http://web.archive.org/web/20131017130434/http://www.jejik.com/articles/2007/02/a_simple_unix_linux_daemon_in_python/">这段代码</a> 为例，初始进程进行第一次 fork，然后 <code>setcwd('/'); setsid(); umask(0)</code>，接着进行第二次 fork，然后关闭 stdin, stdout, stderr，最后将进程 ID 写入到 pidfile。</p>
<ul>
<li>Daemon 一般以 root 身份运行，所以 cwd=/, umask=000</li>
<li>一次 fork 后的子进程 setsid，变成了一个无 tty 关联的 session leader …</li></ul>
                        <a class="readmore" href="https://www.soasme.com/techshack.weekly/verses/fe447683-4f28-48da-ad47-54b666e61d7f.html"
                            >read more</a>
                    </div><!-- /.entry-content -->
                </article>
            </div>


        

 
            <div>
                <article class="hentry">
                    <header>
                        <h3>
                            <a href="https://www.soasme.com/techshack.weekly/verses/d7ea72d5-82d7-402b-9876-4023de627381.html" rel="bookmark"
                                title="Permalink to Curl cheat sheet"
                                >Curl cheat sheet</a>
                        </h3>
                    </header>
                    <div class="entry-content">
                        <p><a href="https://daniel.haxx.se/blog/2015/09/16/a-curl-cheat-sheet/">查看原文</a></p>
<p>这篇是 Curl 的作者写的 Curl Cheat Sheet。里面包含了几个 Curl 最常用的十几个命令选项。</p>
<ul>
<li><code>-v</code>: 详细模式，一般用于 debug</li>
<li><code>-s</code>: Silent, 把还有多久下载完这个信息去掉，一般用在自动化的脚本中</li>
<li><code>-d "str" -d @file</code> 指定参数</li>
<li><code>-u user:auth</code> 设定用户名与密码</li>
<li><code>-x host:port</code> 设定代理</li>
<li>`-H "name: value" 设定 header</li>
<li><code>-L</code> 302 的时候跟着跳转，否则只会得到 302 结果</li>
<li><code>--compressed</code> 拿到压缩的响应</li>
<li><code>-k</code> 省略掉 ssl certificate 的验证，一般用在自签名证书上 …</li></ul>
                        <a class="readmore" href="https://www.soasme.com/techshack.weekly/verses/d7ea72d5-82d7-402b-9876-4023de627381.html"
                            >read more</a>
                    </div><!-- /.entry-content -->
                </article>
            </div>


        

 
            <div>
                <article class="hentry">
                    <header>
                        <h3>
                            <a href="https://www.soasme.com/techshack.weekly/verses/8450a9da-62ab-47ab-8753-c8da02bb173d.html" rel="bookmark"
                                title="Permalink to 压缩 Docker 镜像大小的一些技巧"
                                >压缩 Docker 镜像大小的一些技巧</a>
                        </h3>
                    </header>
                    <div class="entry-content">
                        <p><a href="https://learnk8s.io/blog/smaller-docker-images">查看原文</a></p>
<p>本文介绍了一些减小 Docker Image 大小的技巧。更小的镜像，部署可以更快。镜像变大很大一个原因是每添加一个 RUN/ COPY / ADD 到 Dockerfile 中，构建后就会增加新的一个 Layer。这些层存储着前后版本之间的信息。在之前 Docker 特性还不够多的时候，唯一的办法是压缩到仅剩一个 RUN，在 RUN 中的命令用 <code>&amp;&amp;</code> 来拼接运行。现在，最适合这个场景的技巧叫 multi-stage build。通过多次写 FROM，可以将基于上一次的 BASE Image 构建出来的东西，复制到下一次 BASE Image 去，复制的过程中会合并成仅剩一个 Layer。举例：</p>
<div class="highlight"><pre><span></span><code><span class="err">FROM node:8 as build</span>
<span class="err">WORKDIR /app …</span></code></pre></div>
                        <a class="readmore" href="https://www.soasme.com/techshack.weekly/verses/8450a9da-62ab-47ab-8753-c8da02bb173d.html"
                            >read more</a>
                    </div><!-- /.entry-content -->
                </article>
            </div>


        

 
            <div>
                <article class="hentry">
                    <header>
                        <h3>
                            <a href="https://www.soasme.com/techshack.weekly/verses/a17b6263-86e5-491c-8768-79a28ec0301f.html" rel="bookmark"
                                title="Permalink to CSS Var 简介"
                                >CSS Var 简介</a>
                        </h3>
                    </header>
                    <div class="entry-content">
                        <p><a href="https://medium.freecodecamp.org/learn-css-variables-in-5-minutes-80cf63b4025d">查看原文</a></p>
<p>CSS Custom Properties，也叫 CSS Variables，是浏览器内建的功能，等价于 LESS / SASS 提供的变量功能。目前已有超过 77% 的浏览器支持这一特性。简单来说，它使用 <code>--name: #fff</code> 声明变量，使用 <code>var(name)</code> 获取值，在 JavaScript 中可以用 <code>getComputedStyle(document.querySelector(el)).getPropertyValue('--name')</code> 获取值。</p>
<p>可以使用 :root 声明全局 CSS Var，也可以将 <code>--xyz: 10px</code> 这种值写在任意一个 css 选择器里。Var 可以被复写，从而完成浏览器适配。：</p>
<div class="highlight"><pre><span></span><code><span class="err">:</span><span class="nf">root</span> <span class="err">{</span> <span class="p">--</span><span class="no">default …</span></code></pre></div>
                        <a class="readmore" href="https://www.soasme.com/techshack.weekly/verses/a17b6263-86e5-491c-8768-79a28ec0301f.html"
                            >read more</a>
                    </div><!-- /.entry-content -->
                </article>
            </div>

<p class="paginator">
        <a href="https://www.soasme.com/techshack.weekly/category/verses31.html">&laquo;</a>
    Page 32 / 54
        <a href="https://www.soasme.com/techshack.weekly/category/verses33.html">&raquo;</a>
</p>
            </section><!-- /#content -->

                </div>

                <hr>
                <div id="footer" class="col-lg-12">
                    <nav>
                        <ul>
                        </ul>
                    </nav>
                </div>
            </div>
            <div id="sidebar" class="col-lg-4">
                <h1>
                    <a href="https://www.soasme.com/techshack.weekly " title="Techshack Weekly">
                        <img src="https://www.soasme.com/techshack.weekly/images/logo-200x50.png" />
                    </a>
                </h1>
                <span class="description"> </span>
                <div><div class="entry-subscription">
    <h5>Techshack Weekly</h5>
    <br>
    专注于后端技术阅读
    <br>
    目前有上百位订阅者。
    <br>
    订阅 <a href="https://www.soasme.com/techshack.weekly/feeds/issues.atom.xml">RSS</a>
    <br>
    欢迎加入 <a href="https://t.me/techshack">Telegram Channel</a> ，
    <br>
    <iframe src="https://tgwidget.com/widget/count/?id=5a66b26483ba88e7118b4568" frameborder="0" scrolling="no" horizontalscrolling="no" verticalscrolling="no" width="160px" height="50px" async></iframe>
    <br>
    关注推特 <a href="https://twitter.com/techshackweekly">@techshackweekly</a>。
    <br>
    <a href="https://twitter.com/TechshackWeekly?ref_src=twsrc%5Etfw" class="twitter-follow-button" data-show-count="false">Follow @TechshackWeekly</a><script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>
    <hr>
</div></div>
                <div><!-- Begin MailChimp Signup Form -->
<link href="//cdn-images.mailchimp.com/embedcode/slim-10_7.css" rel="stylesheet" type="text/css">
<style type="text/css">
    #mc_embed_signup{background:#fff; clear:left; font:14px Helvetica,Arial,sans-serif;  width:250px;}
    /* Add your own MailChimp form style overrides in your site stylesheet or in this style block.
       We recommend moving this block and the preceding CSS link to the HEAD of your HTML file. */
</style>
<div id="mc_embed_signup">
<form action="https://soasme.us17.list-manage.com/subscribe/post?u=617c1cb80ba1b0cbf828df387&amp;id=10442a8ee6" method="post" id="mc-embedded-subscribe-form" name="mc-embedded-subscribe-form" class="validate" target="_blank" novalidate>
    <div id="mc_embed_signup_scroll">
    <label for="mce-EMAIL">Subscribe to our mailing list</label>
    <input type="email" value="" name="EMAIL" class="email" id="mce-EMAIL" placeholder="email address" required>
    <!-- real people should not fill this in and expect good things - do not remove this or risk form bot signups-->
    <div style="position: absolute; left: -5000px;" aria-hidden="true"><input type="text" name="b_617c1cb80ba1b0cbf828df387_10442a8ee6" tabindex="-1" value=""></div>
    <div class="clear"><input type="submit" value="Subscribe" name="subscribe" id="mc-embedded-subscribe" class="button"></div>
    </div>
</form>
</div>

<!--End mc_embed_signup--></div>
                    <div>:: <a href="https://www.soasme.com/techshack.weekly/categories.html">Categories</a></div>
                <!-- <span class="feed"><a href="">RSS</a> | <a href="">Atom</a></span> -->
            </div>
            <div class="col-lg-2"></div>
        </div>
    </div>
    <script type="text/javascript">
    var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
    document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
    </script>
    <script type="text/javascript">
    try {
        var pageTracker = _gat._getTracker("UA-36183732-2");
    pageTracker._trackPageview();
    } catch(err) {}</script>
</body>
</html>